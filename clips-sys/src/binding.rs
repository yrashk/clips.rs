/* automatically generated by rust-bindgen */

pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 25;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const LINUX: ::std::os::raw::c_uint = 0;
pub const DARWIN: ::std::os::raw::c_uint = 0;
pub const MAC_XCD: ::std::os::raw::c_uint = 0;
pub const WIN_MVC: ::std::os::raw::c_uint = 0;
pub const UNIX_V: ::std::os::raw::c_uint = 0;
pub const UNIX_7: ::std::os::raw::c_uint = 0;
pub const WIN_GCC: ::std::os::raw::c_uint = 0;
pub const GENERIC: ::std::os::raw::c_uint = 1;
pub const IBM: ::std::os::raw::c_uint = 0;
pub const RUN_TIME: ::std::os::raw::c_uint = 0;
pub const DEFRULE_CONSTRUCT: ::std::os::raw::c_uint = 1;
pub const DEFMODULE_CONSTRUCT: ::std::os::raw::c_uint = 1;
pub const DEFTEMPLATE_CONSTRUCT: ::std::os::raw::c_uint = 1;
pub const FACT_SET_QUERIES: ::std::os::raw::c_uint = 1;
pub const DEFFACTS_CONSTRUCT: ::std::os::raw::c_uint = 1;
pub const DEFGLOBAL_CONSTRUCT: ::std::os::raw::c_uint = 1;
pub const DEFFUNCTION_CONSTRUCT: ::std::os::raw::c_uint = 1;
pub const DEFGENERIC_CONSTRUCT: ::std::os::raw::c_uint = 1;
pub const OBJECT_SYSTEM: ::std::os::raw::c_uint = 1;
pub const DEFINSTANCES_CONSTRUCT: ::std::os::raw::c_uint = 1;
pub const INSTANCE_SET_QUERIES: ::std::os::raw::c_uint = 1;
pub const BLOAD_INSTANCES: ::std::os::raw::c_uint = 1;
pub const BSAVE_INSTANCES: ::std::os::raw::c_uint = 1;
pub const EXTENDED_MATH_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const TEXTPRO_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const BLOAD_ONLY: ::std::os::raw::c_uint = 0;
pub const BLOAD: ::std::os::raw::c_uint = 0;
pub const BLOAD_AND_BSAVE: ::std::os::raw::c_uint = 1;
pub const CONSTRUCT_COMPILER: ::std::os::raw::c_uint = 1;
pub const API_HEADER: &'static [u8; 8usize] = b"clips.h\x00";
pub const IO_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const STRING_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const MULTIFIELD_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const DEBUGGING_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const PROFILING_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const WINDOW_INTERFACE: ::std::os::raw::c_uint = 0;
pub const DEVELOPER: ::std::os::raw::c_uint = 0;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timeval_defined: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const USER_ENVIRONMENT_DATA: ::std::os::raw::c_uint = 70;
pub const MAXIMUM_ENVIRONMENT_POSITIONS: ::std::os::raw::c_uint = 100;
pub const MAXIMUM_USER_DATA_RECORDS: ::std::os::raw::c_uint = 100;
pub const USER_DATA_DATA: ::std::os::raw::c_uint = 56;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const _LIBC_LIMITS_H_: ::std::os::raw::c_uint = 1;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const NR_OPEN: ::std::os::raw::c_uint = 1024;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 65536;
pub const ARG_MAX: ::std::os::raw::c_uint = 131072;
pub const LINK_MAX: ::std::os::raw::c_uint = 127;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const PATH_MAX: ::std::os::raw::c_uint = 4096;
pub const PIPE_BUF: ::std::os::raw::c_uint = 4096;
pub const XATTR_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const XATTR_SIZE_MAX: ::std::os::raw::c_uint = 65536;
pub const XATTR_LIST_MAX: ::std::os::raw::c_uint = 65536;
pub const RTSIG_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 16384;
pub const DELAYTIMER_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const LOGIN_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const HOST_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const MQ_PRIO_MAX: ::std::os::raw::c_uint = 32768;
pub const SEM_VALUE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 255;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 32767;
pub const EXACTLY: ::std::os::raw::c_uint = 0;
pub const AT_LEAST: ::std::os::raw::c_uint = 1;
pub const NO_MORE_THAN: ::std::os::raw::c_uint = 2;
pub const RANGE: ::std::os::raw::c_uint = 3;
pub const LHS: ::std::os::raw::c_uint = 0;
pub const RHS: ::std::os::raw::c_uint = 1;
pub const NESTED_RHS: ::std::os::raw::c_uint = 2;
pub const NEGATIVE: ::std::os::raw::c_uint = 0;
pub const POSITIVE: ::std::os::raw::c_uint = 1;
pub const EOS: u8 = b'\x00';
pub const INSIDE: ::std::os::raw::c_uint = 0;
pub const OUTSIDE: ::std::os::raw::c_uint = 1;
pub const LESS_THAN: ::std::os::raw::c_uint = 0;
pub const GREATER_THAN: ::std::os::raw::c_uint = 1;
pub const EQUAL: ::std::os::raw::c_uint = 2;
pub const APPLICATION_NAME: &'static [u8; 6usize] = b"CLIPS\x00";
pub const COMMAND_PROMPT: &'static [u8; 8usize] = b"CLIPS> \x00";
pub const VERSION_STRING: &'static [u8; 5usize] = b"6.40\x00";
pub const CREATION_DATE_STRING: &'static [u8; 9usize] = b"11/30/17\x00";
pub const BANNER_STRING: &'static [u8; 40usize] =
    b"         CLIPS (Cypher Beta 11/30/17)\\n\x00";
pub const OBJECT_TYPE_NAME: &'static [u8; 7usize] = b"OBJECT\x00";
pub const USER_TYPE_NAME: &'static [u8; 5usize] = b"USER\x00";
pub const PRIMITIVE_TYPE_NAME: &'static [u8; 10usize] = b"PRIMITIVE\x00";
pub const NUMBER_TYPE_NAME: &'static [u8; 7usize] = b"NUMBER\x00";
pub const INTEGER_TYPE_NAME: &'static [u8; 8usize] = b"INTEGER\x00";
pub const FLOAT_TYPE_NAME: &'static [u8; 6usize] = b"FLOAT\x00";
pub const SYMBOL_TYPE_NAME: &'static [u8; 7usize] = b"SYMBOL\x00";
pub const STRING_TYPE_NAME: &'static [u8; 7usize] = b"STRING\x00";
pub const MULTIFIELD_TYPE_NAME: &'static [u8; 11usize] = b"MULTIFIELD\x00";
pub const LEXEME_TYPE_NAME: &'static [u8; 7usize] = b"LEXEME\x00";
pub const ADDRESS_TYPE_NAME: &'static [u8; 8usize] = b"ADDRESS\x00";
pub const EXTERNAL_ADDRESS_TYPE_NAME: &'static [u8; 17usize] =
    b"EXTERNAL-ADDRESS\x00";
pub const FACT_ADDRESS_TYPE_NAME: &'static [u8; 13usize] =
    b"FACT-ADDRESS\x00";
pub const INSTANCE_TYPE_NAME: &'static [u8; 9usize] = b"INSTANCE\x00";
pub const INSTANCE_NAME_TYPE_NAME: &'static [u8; 14usize] =
    b"INSTANCE-NAME\x00";
pub const INSTANCE_ADDRESS_TYPE_NAME: &'static [u8; 17usize] =
    b"INSTANCE-ADDRESS\x00";
pub const OBJECT_TYPE_CODE: ::std::os::raw::c_uint = 9;
pub const PRIMITIVE_TYPE_CODE: ::std::os::raw::c_uint = 10;
pub const NUMBER_TYPE_CODE: ::std::os::raw::c_uint = 11;
pub const LEXEME_TYPE_CODE: ::std::os::raw::c_uint = 12;
pub const ADDRESS_TYPE_CODE: ::std::os::raw::c_uint = 13;
pub const INSTANCE_TYPE_CODE: ::std::os::raw::c_uint = 14;
pub const FLOAT_TYPE: ::std::os::raw::c_uint = 0;
pub const INTEGER_TYPE: ::std::os::raw::c_uint = 1;
pub const SYMBOL_TYPE: ::std::os::raw::c_uint = 2;
pub const STRING_TYPE: ::std::os::raw::c_uint = 3;
pub const MULTIFIELD_TYPE: ::std::os::raw::c_uint = 4;
pub const EXTERNAL_ADDRESS_TYPE: ::std::os::raw::c_uint = 5;
pub const FACT_ADDRESS_TYPE: ::std::os::raw::c_uint = 6;
pub const INSTANCE_ADDRESS_TYPE: ::std::os::raw::c_uint = 7;
pub const INSTANCE_NAME_TYPE: ::std::os::raw::c_uint = 8;
pub const VOID_TYPE: ::std::os::raw::c_uint = 9;
pub const BITMAP_TYPE: ::std::os::raw::c_uint = 11;
pub const FCALL: ::std::os::raw::c_uint = 30;
pub const GCALL: ::std::os::raw::c_uint = 31;
pub const PCALL: ::std::os::raw::c_uint = 32;
pub const GBL_VARIABLE: ::std::os::raw::c_uint = 33;
pub const MF_GBL_VARIABLE: ::std::os::raw::c_uint = 34;
pub const SF_VARIABLE: ::std::os::raw::c_uint = 35;
pub const MF_VARIABLE: ::std::os::raw::c_uint = 36;
pub const BITMAPARRAY: ::std::os::raw::c_uint = 39;
pub const FACT_PN_CMP1: ::std::os::raw::c_uint = 50;
pub const FACT_JN_CMP1: ::std::os::raw::c_uint = 51;
pub const FACT_JN_CMP2: ::std::os::raw::c_uint = 52;
pub const FACT_SLOT_LENGTH: ::std::os::raw::c_uint = 53;
pub const FACT_PN_VAR1: ::std::os::raw::c_uint = 54;
pub const FACT_PN_VAR2: ::std::os::raw::c_uint = 55;
pub const FACT_PN_VAR3: ::std::os::raw::c_uint = 56;
pub const FACT_JN_VAR1: ::std::os::raw::c_uint = 57;
pub const FACT_JN_VAR2: ::std::os::raw::c_uint = 58;
pub const FACT_JN_VAR3: ::std::os::raw::c_uint = 59;
pub const FACT_PN_CONSTANT1: ::std::os::raw::c_uint = 60;
pub const FACT_PN_CONSTANT2: ::std::os::raw::c_uint = 61;
pub const FACT_STORE_MULTIFIELD: ::std::os::raw::c_uint = 62;
pub const DEFTEMPLATE_PTR: ::std::os::raw::c_uint = 63;
pub const OBJ_GET_SLOT_PNVAR1: ::std::os::raw::c_uint = 70;
pub const OBJ_GET_SLOT_PNVAR2: ::std::os::raw::c_uint = 71;
pub const OBJ_GET_SLOT_JNVAR1: ::std::os::raw::c_uint = 72;
pub const OBJ_GET_SLOT_JNVAR2: ::std::os::raw::c_uint = 73;
pub const OBJ_SLOT_LENGTH: ::std::os::raw::c_uint = 74;
pub const OBJ_PN_CONSTANT: ::std::os::raw::c_uint = 75;
pub const OBJ_PN_CMP1: ::std::os::raw::c_uint = 76;
pub const OBJ_JN_CMP1: ::std::os::raw::c_uint = 77;
pub const OBJ_PN_CMP2: ::std::os::raw::c_uint = 78;
pub const OBJ_JN_CMP2: ::std::os::raw::c_uint = 79;
pub const OBJ_PN_CMP3: ::std::os::raw::c_uint = 80;
pub const OBJ_JN_CMP3: ::std::os::raw::c_uint = 81;
pub const DEFCLASS_PTR: ::std::os::raw::c_uint = 82;
pub const HANDLER_GET: ::std::os::raw::c_uint = 83;
pub const HANDLER_PUT: ::std::os::raw::c_uint = 84;
pub const DEFGLOBAL_PTR: ::std::os::raw::c_uint = 90;
pub const PROC_PARAM: ::std::os::raw::c_uint = 95;
pub const PROC_WILD_PARAM: ::std::os::raw::c_uint = 96;
pub const PROC_GET_BIND: ::std::os::raw::c_uint = 97;
pub const PROC_BIND: ::std::os::raw::c_uint = 98;
pub const UNKNOWN_VALUE: ::std::os::raw::c_uint = 173;
pub const INTEGER_OR_FLOAT: ::std::os::raw::c_uint = 180;
pub const SYMBOL_OR_STRING: ::std::os::raw::c_uint = 181;
pub const INSTANCE_OR_INSTANCE_NAME: ::std::os::raw::c_uint = 182;
pub const CREATOR_STRING: &'static [u8; 5usize] = b"CLIS\x00";
pub const C_POINTER_EXTERNAL_ADDRESS: ::std::os::raw::c_uint = 0;
pub const MAXIMUM_PRIMITIVES: ::std::os::raw::c_uint = 150;
pub const MAXIMUM_EXTERNAL_ADDRESS_TYPES: ::std::os::raw::c_uint = 10;
pub const BITS_PER_BYTE: ::std::os::raw::c_uint = 8;
pub const EVALUATION_DATA: ::std::os::raw::c_uint = 44;
pub const UTILITY_DATA: ::std::os::raw::c_uint = 55;
pub const DEFMODULE_DATA: ::std::os::raw::c_uint = 4;
pub const CONSTRUCT_DATA: ::std::os::raw::c_uint = 42;
pub const EXPRESSION_HASH_SIZE: ::std::os::raw::c_uint = 503;
pub const EXPRESSION_DATA: ::std::os::raw::c_uint = 45;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const MEM_TABLE_SIZE: ::std::os::raw::c_uint = 500;
pub const MEMORY_DATA: ::std::os::raw::c_uint = 59;
pub const SYMBOL_HASH_SIZE: ::std::os::raw::c_uint = 63559;
pub const FLOAT_HASH_SIZE: ::std::os::raw::c_uint = 8191;
pub const INTEGER_HASH_SIZE: ::std::os::raw::c_uint = 8191;
pub const BITMAP_HASH_SIZE: ::std::os::raw::c_uint = 8191;
pub const EXTERNAL_ADDRESS_HASH_SIZE: ::std::os::raw::c_uint = 8191;
pub const SYMBOL_DATA: ::std::os::raw::c_uint = 49;
pub const EXTERNAL_FUNCTION_DATA: ::std::os::raw::c_uint = 50;
pub const SIZE_FUNCTION_HASH: ::std::os::raw::c_uint = 517;
pub const COMMANDLINE_DATA: ::std::os::raw::c_uint = 40;
pub const PRINT_UTILITY_DATA: ::std::os::raw::c_uint = 53;
pub const ROUTER_DATA: ::std::os::raw::c_uint = 46;
pub const FILE_ROUTER_DATA: ::std::os::raw::c_uint = 47;
pub const STRING_ROUTER_DATA: ::std::os::raw::c_uint = 48;
pub const _SETJMP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_SETJMP_H: ::std::os::raw::c_uint = 1;
pub const SCANNER_DATA: ::std::os::raw::c_uint = 57;
pub const WATCH_DATA: ::std::os::raw::c_uint = 54;
pub const BLOAD_DATA: ::std::os::raw::c_uint = 38;
pub const CONSTRUCT_HEADER_SIZE: ::std::os::raw::c_uint = 20;
pub const BSAVE_DATA: ::std::os::raw::c_uint = 39;
pub const SIZE_PATTERN_HASH: ::std::os::raw::c_uint = 16231;
pub const INITIAL_BETA_HASH_SIZE: ::std::os::raw::c_uint = 17;
pub const MAX_DEFRULE_SALIENCE: ::std::os::raw::c_uint = 10000;
pub const MIN_DEFRULE_SALIENCE: ::std::os::raw::c_int = -10000;
pub const AGENDA_DATA: ::std::os::raw::c_uint = 17;
pub const CONSTRUCT_COMPILER_DATA: ::std::os::raw::c_uint = 41;
pub const SIZE_CONSTRAINT_HASH: ::std::os::raw::c_uint = 167;
pub const CONSTRAINT_DATA: ::std::os::raw::c_uint = 43;
pub const ALPHA_MEMORY_HASH_SIZE: ::std::os::raw::c_uint = 63559;
pub const DEFRULE_DATA: ::std::os::raw::c_uint = 16;
pub const ENGINE_DATA: ::std::os::raw::c_uint = 18;
pub const MAX_PATTERNS_CHECKED: ::std::os::raw::c_uint = 64;
pub const DEFFACTS_DATA: ::std::os::raw::c_uint = 0;
pub const DEFTEMPLATE_DATA: ::std::os::raw::c_uint = 5;
pub const SIZE_FACT_HASH: ::std::os::raw::c_uint = 16231;
pub const FACTS_DATA: ::std::os::raw::c_uint = 3;
pub const DEFGLOBAL_DATA: ::std::os::raw::c_uint = 1;
pub const DEFFUNCTION_DATA: ::std::os::raw::c_uint = 23;
pub const DEFGENERIC_DATA: ::std::os::raw::c_uint = 27;
pub const MAX_TRAVERSALS: ::std::os::raw::c_uint = 256;
pub const TRAVERSAL_BYTES: ::std::os::raw::c_uint = 32;
pub const VALUE_REQUIRED: ::std::os::raw::c_uint = 0;
pub const VALUE_PROHIBITED: ::std::os::raw::c_uint = 1;
pub const VALUE_NOT_REQUIRED: ::std::os::raw::c_uint = 2;
pub const CLASS_TABLE_HASH_SIZE: ::std::os::raw::c_uint = 167;
pub const SLOT_NAME_TABLE_HASH_SIZE: ::std::os::raw::c_uint = 167;
pub const ISA_ID: ::std::os::raw::c_uint = 0;
pub const NAME_ID: ::std::os::raw::c_uint = 1;
pub const DEFCLASS_DATA: ::std::os::raw::c_uint = 21;
pub const PRIMITIVE_CLASSES: ::std::os::raw::c_uint = 9;
pub const DEFINSTANCES_DATA: ::std::os::raw::c_uint = 22;
pub const INSTANCE_TABLE_HASH_SIZE: ::std::os::raw::c_uint = 8191;
pub const INSTANCE_DATA: ::std::os::raw::c_uint = 29;
pub const INSTANCE_FILE_DATA: ::std::os::raw::c_uint = 30;
pub const MESSAGE_HANDLER_DATA: ::std::os::raw::c_uint = 32;
pub const INIT_STRING: &'static [u8; 5usize] = b"init\x00";
pub const DELETE_STRING: &'static [u8; 7usize] = b"delete\x00";
pub const PRINT_STRING: &'static [u8; 6usize] = b"print\x00";
pub const CREATE_STRING: &'static [u8; 7usize] = b"create\x00";
pub const OBJECT_ASSERT: ::std::os::raw::c_uint = 1;
pub const OBJECT_RETRACT: ::std::os::raw::c_uint = 2;
pub const OBJECT_MODIFY: ::std::os::raw::c_uint = 3;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __bindgen_anon_1: pthread_cond_t__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: pthread_cond_t__bindgen_ty_1__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) .
                __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) .
                __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( __high ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_1 )
                ) . __wseq as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __wseq ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_1 )
                ) . __wseq32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __wseq32 ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ) .
                __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ) .
                __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( __high ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_2 )
                ) . __g1_start as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( __g1_start ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_2 )
                ) . __g1_start32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( __g1_start32 ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_refs as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __g_refs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_size as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __g_size
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g1_orig_size as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __g1_orig_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wrefs as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __wrefs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_signals as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __g_signals ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __wrphase_futex as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wrphase_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writers_futex as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writers_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad3 as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad4 as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __cur_writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __cur_writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct environmentData {
    pub _bitfield_1: u8,
    pub context: *mut ::std::os::raw::c_void,
    pub TrueSymbol: *mut CLIPSLexeme,
    pub FalseSymbol: *mut CLIPSLexeme,
    pub VoidConstant: *mut CLIPSVoid,
    pub theData: *mut *mut ::std::os::raw::c_void,
    pub cleanupFunctions: *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut Environment)>,
    pub listOfCleanupEnvironmentFunctions: *mut environmentCleanupFunction,
    pub next: *mut environmentData,
}
#[test]
fn bindgen_test_layout_environmentData() {
    assert_eq!(::std::mem::size_of::<environmentData>() , 72usize , concat ! (
               "Size of: " , stringify ! ( environmentData ) ));
    assert_eq! (::std::mem::align_of::<environmentData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( environmentData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentData ) ) . context as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( environmentData ) ,
                "::" , stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentData ) ) . TrueSymbol as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( environmentData ) ,
                "::" , stringify ! ( TrueSymbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentData ) ) . FalseSymbol as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( environmentData ) ,
                "::" , stringify ! ( FalseSymbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentData ) ) . VoidConstant as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( environmentData ) ,
                "::" , stringify ! ( VoidConstant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentData ) ) . theData as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( environmentData ) ,
                "::" , stringify ! ( theData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentData ) ) . cleanupFunctions as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( environmentData ) ,
                "::" , stringify ! ( cleanupFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentData ) ) .
                listOfCleanupEnvironmentFunctions as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! ( environmentData ) ,
                "::" , stringify ! ( listOfCleanupEnvironmentFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentData ) ) . next as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( environmentData ) ,
                "::" , stringify ! ( next ) ));
}
impl Clone for environmentData {
    fn clone(&self) -> Self { *self }
}
impl environmentData {
    #[inline]
    pub fn initialized(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(initialized: ::std::os::raw::c_uint) -> u8 {
        ({ 0 } | ((initialized as u32 as u8) << 0usize) & (1u64 as u8))
    }
}
pub type Environment = environmentData;
pub type EnvironmentCleanupFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment)>;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct clipsVoid {
    pub header: TypeHeader,
}
#[test]
fn bindgen_test_layout_clipsVoid() {
    assert_eq!(::std::mem::size_of::<clipsVoid>() , 2usize , concat ! (
               "Size of: " , stringify ! ( clipsVoid ) ));
    assert_eq! (::std::mem::align_of::<clipsVoid>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( clipsVoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsVoid ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsVoid ) , "::" ,
                stringify ! ( header ) ));
}
impl Clone for clipsVoid {
    fn clone(&self) -> Self { *self }
}
pub type CLIPSVoid = clipsVoid;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct clipsLexeme {
    pub header: TypeHeader,
    pub next: *mut CLIPSLexeme,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_clipsLexeme() {
    assert_eq!(::std::mem::size_of::<clipsLexeme>() , 40usize , concat ! (
               "Size of: " , stringify ! ( clipsLexeme ) ));
    assert_eq! (::std::mem::align_of::<clipsLexeme>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( clipsLexeme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsLexeme ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsLexeme ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsLexeme ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsLexeme ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsLexeme ) ) . count as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsLexeme ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsLexeme ) ) . contents as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsLexeme ) , "::" ,
                stringify ! ( contents ) ));
}
impl Clone for clipsLexeme {
    fn clone(&self) -> Self { *self }
}
impl clipsLexeme {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn neededSymbol(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededSymbol(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967288u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(permanent: ::std::os::raw::c_uint,
                          markedEphemeral: ::std::os::raw::c_uint,
                          neededSymbol: ::std::os::raw::c_uint,
                          bucket: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((permanent as u32 as u32) << 0usize) &
                                (1u64 as u32))
                   } |
                       ((markedEphemeral as u32 as u32) << 1usize) &
                           (2u64 as u32))
              } | ((neededSymbol as u32 as u32) << 2usize) & (4u64 as u32))
         } | ((bucket as u32 as u32) << 3usize) & (4294967288u64 as u32))
    }
}
pub type CLIPSLexeme = clipsLexeme;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct clipsFloat {
    pub header: TypeHeader,
    pub next: *mut CLIPSFloat,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: f64,
}
#[test]
fn bindgen_test_layout_clipsFloat() {
    assert_eq!(::std::mem::size_of::<clipsFloat>() , 40usize , concat ! (
               "Size of: " , stringify ! ( clipsFloat ) ));
    assert_eq! (::std::mem::align_of::<clipsFloat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( clipsFloat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsFloat ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsFloat ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsFloat ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsFloat ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsFloat ) ) . count as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsFloat ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsFloat ) ) . contents as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsFloat ) , "::" ,
                stringify ! ( contents ) ));
}
impl Clone for clipsFloat {
    fn clone(&self) -> Self { *self }
}
impl clipsFloat {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn neededFloat(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededFloat(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967288u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(permanent: ::std::os::raw::c_uint,
                          markedEphemeral: ::std::os::raw::c_uint,
                          neededFloat: ::std::os::raw::c_uint,
                          bucket: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((permanent as u32 as u32) << 0usize) &
                                (1u64 as u32))
                   } |
                       ((markedEphemeral as u32 as u32) << 1usize) &
                           (2u64 as u32))
              } | ((neededFloat as u32 as u32) << 2usize) & (4u64 as u32))
         } | ((bucket as u32 as u32) << 3usize) & (4294967288u64 as u32))
    }
}
pub type CLIPSFloat = clipsFloat;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct clipsInteger {
    pub header: TypeHeader,
    pub next: *mut CLIPSInteger,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_clipsInteger() {
    assert_eq!(::std::mem::size_of::<clipsInteger>() , 40usize , concat ! (
               "Size of: " , stringify ! ( clipsInteger ) ));
    assert_eq! (::std::mem::align_of::<clipsInteger>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( clipsInteger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsInteger ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsInteger ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsInteger ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsInteger ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsInteger ) ) . count as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsInteger ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsInteger ) ) . contents as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsInteger ) , "::" ,
                stringify ! ( contents ) ));
}
impl Clone for clipsInteger {
    fn clone(&self) -> Self { *self }
}
impl clipsInteger {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn neededInteger(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededInteger(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967288u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(permanent: ::std::os::raw::c_uint,
                          markedEphemeral: ::std::os::raw::c_uint,
                          neededInteger: ::std::os::raw::c_uint,
                          bucket: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((permanent as u32 as u32) << 0usize) &
                                (1u64 as u32))
                   } |
                       ((markedEphemeral as u32 as u32) << 1usize) &
                           (2u64 as u32))
              } | ((neededInteger as u32 as u32) << 2usize) & (4u64 as u32))
         } | ((bucket as u32 as u32) << 3usize) & (4294967288u64 as u32))
    }
}
pub type CLIPSInteger = clipsInteger;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct clipsBitMap {
    pub header: TypeHeader,
    pub next: *mut CLIPSBitMap,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: *const ::std::os::raw::c_char,
    pub size: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_clipsBitMap() {
    assert_eq!(::std::mem::size_of::<clipsBitMap>() , 48usize , concat ! (
               "Size of: " , stringify ! ( clipsBitMap ) ));
    assert_eq! (::std::mem::align_of::<clipsBitMap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( clipsBitMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsBitMap ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsBitMap ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsBitMap ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsBitMap ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsBitMap ) ) . count as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsBitMap ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsBitMap ) ) . contents as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsBitMap ) , "::" ,
                stringify ! ( contents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsBitMap ) ) . size as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsBitMap ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for clipsBitMap {
    fn clone(&self) -> Self { *self }
}
impl clipsBitMap {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn neededBitMap(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededBitMap(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967288u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(permanent: ::std::os::raw::c_uint,
                          markedEphemeral: ::std::os::raw::c_uint,
                          neededBitMap: ::std::os::raw::c_uint,
                          bucket: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((permanent as u32 as u32) << 0usize) &
                                (1u64 as u32))
                   } |
                       ((markedEphemeral as u32 as u32) << 1usize) &
                           (2u64 as u32))
              } | ((neededBitMap as u32 as u32) << 2usize) & (4u64 as u32))
         } | ((bucket as u32 as u32) << 3usize) & (4294967288u64 as u32))
    }
}
pub type CLIPSBitMap = clipsBitMap;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct clipsExternalAddress {
    pub header: TypeHeader,
    pub next: *mut CLIPSExternalAddress,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: *mut ::std::os::raw::c_void,
    pub type_: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_clipsExternalAddress() {
    assert_eq!(::std::mem::size_of::<clipsExternalAddress>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( clipsExternalAddress )
               ));
    assert_eq! (::std::mem::align_of::<clipsExternalAddress>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( clipsExternalAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsExternalAddress ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsExternalAddress )
                , "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsExternalAddress ) ) . next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsExternalAddress )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsExternalAddress ) ) . count as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsExternalAddress )
                , "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsExternalAddress ) ) . contents as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsExternalAddress )
                , "::" , stringify ! ( contents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsExternalAddress ) ) . type_ as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( clipsExternalAddress )
                , "::" , stringify ! ( type_ ) ));
}
impl Clone for clipsExternalAddress {
    fn clone(&self) -> Self { *self }
}
impl clipsExternalAddress {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn neededPointer(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededPointer(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967288u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(permanent: ::std::os::raw::c_uint,
                          markedEphemeral: ::std::os::raw::c_uint,
                          neededPointer: ::std::os::raw::c_uint,
                          bucket: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((permanent as u32 as u32) << 0usize) &
                                (1u64 as u32))
                   } |
                       ((markedEphemeral as u32 as u32) << 1usize) &
                           (2u64 as u32))
              } | ((neededPointer as u32 as u32) << 2usize) & (4u64 as u32))
         } | ((bucket as u32 as u32) << 3usize) & (4294967288u64 as u32))
    }
}
pub type CLIPSExternalAddress = clipsExternalAddress;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct typeHeader {
    pub type_: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_typeHeader() {
    assert_eq!(::std::mem::size_of::<typeHeader>() , 2usize , concat ! (
               "Size of: " , stringify ! ( typeHeader ) ));
    assert_eq! (::std::mem::align_of::<typeHeader>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( typeHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const typeHeader ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( typeHeader ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for typeHeader {
    fn clone(&self) -> Self { *self }
}
pub type TypeHeader = typeHeader;

#[repr(C)]
#[derive(Copy)]
pub struct multifield {
    pub header: TypeHeader,
    pub busyCount: ::std::os::raw::c_uint,
    pub length: usize,
    pub next: *mut Multifield,
    pub contents: [CLIPSValue; 1usize],
}
#[test]
fn bindgen_test_layout_multifield() {
    assert_eq!(::std::mem::size_of::<multifield>() , 32usize , concat ! (
               "Size of: " , stringify ! ( multifield ) ));
    assert_eq! (::std::mem::align_of::<multifield>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( multifield ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifield ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( multifield ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifield ) ) . busyCount as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( multifield ) , "::" ,
                stringify ! ( busyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifield ) ) . length as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( multifield ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifield ) ) . next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( multifield ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifield ) ) . contents as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( multifield ) , "::" ,
                stringify ! ( contents ) ));
}
impl Clone for multifield {
    fn clone(&self) -> Self { *self }
}
pub type Multifield = multifield;

#[repr(C)]
#[derive(Copy)]
pub struct clipsValue {
    pub __bindgen_anon_1: clipsValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union clipsValue__bindgen_ty_1 {
    pub value: *mut ::std::os::raw::c_void,
    pub header: *mut TypeHeader,
    pub lexemeValue: *mut CLIPSLexeme,
    pub floatValue: *mut CLIPSFloat,
    pub integerValue: *mut CLIPSInteger,
    pub voidValue: *mut CLIPSVoid,
    pub multifieldValue: *mut Multifield,
    pub factValue: *mut Fact,
    pub instanceValue: *mut Instance,
    pub externalAddressValue: *mut CLIPSExternalAddress,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_clipsValue__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<clipsValue__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( clipsValue__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<clipsValue__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( clipsValue__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) . header as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) .
                lexemeValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! ( lexemeValue
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) . floatValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! ( floatValue )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) .
                integerValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! ( integerValue
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) . voidValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! ( voidValue )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) .
                multifieldValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! (
                multifieldValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) . factValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! ( factValue )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) .
                instanceValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! (
                instanceValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clipsValue__bindgen_ty_1 ) ) .
                externalAddressValue as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                clipsValue__bindgen_ty_1 ) , "::" , stringify ! (
                externalAddressValue ) ));
}
impl Clone for clipsValue__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_clipsValue() {
    assert_eq!(::std::mem::size_of::<clipsValue>() , 8usize , concat ! (
               "Size of: " , stringify ! ( clipsValue ) ));
    assert_eq! (::std::mem::align_of::<clipsValue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( clipsValue ) ));
}
impl Clone for clipsValue {
    fn clone(&self) -> Self { *self }
}
pub type CLIPSValue = clipsValue;

#[repr(C)]
#[derive(Copy)]
pub struct udfValue {
    pub supplementalInfo: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: udfValue__bindgen_ty_1,
    pub begin: usize,
    pub range: usize,
    pub next: *mut udfValue,
}
#[repr(C)]
#[derive(Copy)]
pub union udfValue__bindgen_ty_1 {
    pub value: *mut ::std::os::raw::c_void,
    pub header: *mut TypeHeader,
    pub lexemeValue: *mut CLIPSLexeme,
    pub floatValue: *mut CLIPSFloat,
    pub integerValue: *mut CLIPSInteger,
    pub voidValue: *mut CLIPSVoid,
    pub multifieldValue: *mut Multifield,
    pub factValue: *mut Fact,
    pub instanceValue: *mut Instance,
    pub externalAddressValue: *mut CLIPSExternalAddress,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_udfValue__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<udfValue__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( udfValue__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<udfValue__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( udfValue__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) . lexemeValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( lexemeValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) . floatValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( floatValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) . integerValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( integerValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) . voidValue as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( voidValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) .
                multifieldValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( multifieldValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) . factValue as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( factValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) .
                instanceValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( instanceValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue__bindgen_ty_1 ) ) .
                externalAddressValue as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( udfValue__bindgen_ty_1
                ) , "::" , stringify ! ( externalAddressValue ) ));
}
impl Clone for udfValue__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_udfValue() {
    assert_eq!(::std::mem::size_of::<udfValue>() , 40usize , concat ! (
               "Size of: " , stringify ! ( udfValue ) ));
    assert_eq! (::std::mem::align_of::<udfValue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( udfValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue ) ) . supplementalInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue ) , "::" ,
                stringify ! ( supplementalInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue ) ) . begin as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue ) , "::" ,
                stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue ) ) . range as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue ) , "::" ,
                stringify ! ( range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfValue ) ) . next as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( udfValue ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for udfValue {
    fn clone(&self) -> Self { *self }
}
pub type UDFValue = udfValue;
#[repr(C)]
#[derive(Copy)]
pub struct fact {
    pub __bindgen_anon_1: fact__bindgen_ty_1,
    pub whichDeftemplate: *mut Deftemplate,
    pub list: *mut ::std::os::raw::c_void,
    pub factIndex: ::std::os::raw::c_longlong,
    pub hashValue: ::std::os::raw::c_ulong,
    pub _bitfield_1: u8,
    pub previousFact: *mut Fact,
    pub nextFact: *mut Fact,
    pub previousTemplateFact: *mut Fact,
    pub nextTemplateFact: *mut Fact,
    pub basisSlots: *mut Multifield,
    pub theProposition: Multifield,
}
#[repr(C)]
#[derive(Copy)]
pub union fact__bindgen_ty_1 {
    pub patternHeader: patternEntity,
    pub header: TypeHeader,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_fact__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<fact__bindgen_ty_1>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( fact__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<fact__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( fact__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact__bindgen_ty_1 ) ) . patternHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fact__bindgen_ty_1 ) ,
                "::" , stringify ! ( patternHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact__bindgen_ty_1 ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fact__bindgen_ty_1 ) ,
                "::" , stringify ! ( header ) ));
}
impl Clone for fact__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_fact() {
    assert_eq!(::std::mem::size_of::<fact>() , 152usize , concat ! (
               "Size of: " , stringify ! ( fact ) ));
    assert_eq! (::std::mem::align_of::<fact>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . whichDeftemplate as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( whichDeftemplate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . list as * const _ as usize } ,
                48usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . factIndex as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( factIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . hashValue as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( hashValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . previousFact as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( previousFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . nextFact as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( nextFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . previousTemplateFact as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( previousTemplateFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . nextTemplateFact as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( nextTemplateFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . basisSlots as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( basisSlots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fact ) ) . theProposition as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( fact ) , "::" ,
                stringify ! ( theProposition ) ));
}
impl Clone for fact {
    fn clone(&self) -> Self { *self }
}
impl fact {
    #[inline]
    pub fn garbage(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_garbage(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(garbage: ::std::os::raw::c_uint) -> u8 {
        ({ 0 } | ((garbage as u32 as u8) << 0usize) & (1u64 as u8))
    }
}
pub type Fact = fact;
#[repr(C)]
#[derive(Copy)]
pub struct instance {
    pub __bindgen_anon_1: instance__bindgen_ty_1,
    pub partialMatchList: *mut ::std::os::raw::c_void,
    pub basisSlots: *mut InstanceSlot,
    pub _bitfield_1: u8,
    pub name: *mut CLIPSLexeme,
    pub hashTableIndex: ::std::os::raw::c_uint,
    pub busy: ::std::os::raw::c_uint,
    pub cls: *mut Defclass,
    pub prvClass: *mut Instance,
    pub nxtClass: *mut Instance,
    pub prvHash: *mut Instance,
    pub nxtHash: *mut Instance,
    pub prvList: *mut Instance,
    pub nxtList: *mut Instance,
    pub slotAddresses: *mut *mut InstanceSlot,
    pub slots: *mut InstanceSlot,
}
#[repr(C)]
#[derive(Copy)]
pub union instance__bindgen_ty_1 {
    pub patternHeader: patternEntity,
    pub header: TypeHeader,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_instance__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<instance__bindgen_ty_1>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( instance__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<instance__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( instance__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance__bindgen_ty_1 ) ) .
                patternHeader as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( instance__bindgen_ty_1
                ) , "::" , stringify ! ( patternHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance__bindgen_ty_1 ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( instance__bindgen_ty_1
                ) , "::" , stringify ! ( header ) ));
}
impl Clone for instance__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_instance() {
    assert_eq!(::std::mem::size_of::<instance>() , 152usize , concat ! (
               "Size of: " , stringify ! ( instance ) ));
    assert_eq! (::std::mem::align_of::<instance>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . partialMatchList as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( partialMatchList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . basisSlots as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( basisSlots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . name as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . hashTableIndex as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( hashTableIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . busy as * const _ as usize
                } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( busy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . cls as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( cls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . prvClass as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( prvClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . nxtClass as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( nxtClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . prvHash as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( prvHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . nxtHash as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( nxtHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . prvList as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( prvList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . nxtList as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( nxtList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . slotAddresses as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( slotAddresses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instance ) ) . slots as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( instance ) , "::" ,
                stringify ! ( slots ) ));
}
impl Clone for instance {
    fn clone(&self) -> Self { *self }
}
impl instance {
    #[inline]
    pub fn installed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_installed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn garbage(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_garbage(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn initSlotsCalled(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_initSlotsCalled(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn initializeInProgress(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_initializeInProgress(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reteSynchronized(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reteSynchronized(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(installed: ::std::os::raw::c_uint,
                          garbage: ::std::os::raw::c_uint,
                          initSlotsCalled: ::std::os::raw::c_uint,
                          initializeInProgress: ::std::os::raw::c_uint,
                          reteSynchronized: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((installed as u32 as u8) << 0usize) &
                                     (1u64 as u8))
                        } | ((garbage as u32 as u8) << 1usize) & (2u64 as u8))
                   } |
                       ((initSlotsCalled as u32 as u8) << 2usize) &
                           (4u64 as u8))
              } |
                  ((initializeInProgress as u32 as u8) << 3usize) &
                      (8u64 as u8))
         } | ((reteSynchronized as u32 as u8) << 4usize) & (16u64 as u8))
    }
}
pub type Instance = instance;

#[repr(C)]
#[derive(Copy)]
pub struct expr {
    pub type_: ::std::os::raw::c_ushort,
    pub __bindgen_anon_1: expr__bindgen_ty_1,
    pub argList: *mut Expression,
    pub nextArg: *mut Expression,
}
#[repr(C)]
#[derive(Copy)]
pub union expr__bindgen_ty_1 {
    pub value: *mut ::std::os::raw::c_void,
    pub lexemeValue: *mut CLIPSLexeme,
    pub floatValue: *mut CLIPSFloat,
    pub integerValue: *mut CLIPSInteger,
    pub bitMapValue: *mut CLIPSBitMap,
    pub constructValue: *mut ConstructHeader,
    pub functionValue: *mut FunctionDefinition,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_expr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<expr__bindgen_ty_1>() , 8usize , concat !
               ( "Size of: " , stringify ! ( expr__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<expr__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( expr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr__bindgen_ty_1 ) ) . value as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expr__bindgen_ty_1 ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr__bindgen_ty_1 ) ) . lexemeValue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expr__bindgen_ty_1 ) ,
                "::" , stringify ! ( lexemeValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr__bindgen_ty_1 ) ) . floatValue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expr__bindgen_ty_1 ) ,
                "::" , stringify ! ( floatValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr__bindgen_ty_1 ) ) . integerValue as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expr__bindgen_ty_1 ) ,
                "::" , stringify ! ( integerValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr__bindgen_ty_1 ) ) . bitMapValue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expr__bindgen_ty_1 ) ,
                "::" , stringify ! ( bitMapValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr__bindgen_ty_1 ) ) . constructValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expr__bindgen_ty_1 ) ,
                "::" , stringify ! ( constructValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr__bindgen_ty_1 ) ) . functionValue as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expr__bindgen_ty_1 ) ,
                "::" , stringify ! ( functionValue ) ));
}
impl Clone for expr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_expr() {
    assert_eq!(::std::mem::size_of::<expr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( expr ) ));
    assert_eq! (::std::mem::align_of::<expr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr ) ) . type_ as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expr ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr ) ) . argList as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( expr ) , "::" ,
                stringify ! ( argList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expr ) ) . nextArg as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( expr ) , "::" ,
                stringify ! ( nextArg ) ));
}
impl Clone for expr {
    fn clone(&self) -> Self { *self }
}
pub type Expression = expr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct functionDefinition {
    pub callFunctionName: *mut CLIPSLexeme,
    pub actualFunctionName: *const ::std::os::raw::c_char,
    pub unknownReturnValueType: ::std::os::raw::c_uint,
    pub functionPointer: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut Environment,
                                                                    arg2:
                                                                        *mut UDFContext,
                                                                    arg3:
                                                                        *mut UDFValue)>,
    pub parser: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut Environment,
                                                           arg2: *mut expr,
                                                           arg3:
                                                               *const ::std::os::raw::c_char)
                                          -> *mut expr>,
    pub restrictions: *mut CLIPSLexeme,
    pub minArgs: ::std::os::raw::c_ushort,
    pub maxArgs: ::std::os::raw::c_ushort,
    pub overloadable: bool,
    pub sequenceuseok: bool,
    pub neededFunction: bool,
    pub bsaveIndex: ::std::os::raw::c_ulong,
    pub next: *mut functionDefinition,
    pub usrData: *mut userData,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_functionDefinition() {
    assert_eq!(::std::mem::size_of::<functionDefinition>() , 88usize , concat
               ! ( "Size of: " , stringify ! ( functionDefinition ) ));
    assert_eq! (::std::mem::align_of::<functionDefinition>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( functionDefinition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . callFunctionName
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( callFunctionName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) .
                actualFunctionName as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( actualFunctionName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) .
                unknownReturnValueType as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( unknownReturnValueType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . functionPointer
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( functionPointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . parser as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( parser ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . restrictions as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( restrictions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . minArgs as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( minArgs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . maxArgs as *
                const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( maxArgs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . overloadable as
                * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( overloadable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . sequenceuseok as
                * const _ as usize } , 53usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( sequenceuseok ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . neededFunction
                as * const _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( neededFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . bsaveIndex as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( bsaveIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . next as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . usrData as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( usrData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionDefinition ) ) . context as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( functionDefinition ) ,
                "::" , stringify ! ( context ) ));
}
impl Clone for functionDefinition {
    fn clone(&self) -> Self { *self }
}
pub type FunctionDefinition = functionDefinition;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct udfContext {
    pub environment: *mut Environment,
    pub context: *mut ::std::os::raw::c_void,
    pub theFunction: *mut FunctionDefinition,
    pub lastPosition: ::std::os::raw::c_uint,
    pub lastArg: *mut Expression,
    pub returnValue: *mut UDFValue,
}
#[test]
fn bindgen_test_layout_udfContext() {
    assert_eq!(::std::mem::size_of::<udfContext>() , 48usize , concat ! (
               "Size of: " , stringify ! ( udfContext ) ));
    assert_eq! (::std::mem::align_of::<udfContext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( udfContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfContext ) ) . environment as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udfContext ) , "::" ,
                stringify ! ( environment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfContext ) ) . context as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( udfContext ) , "::" ,
                stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfContext ) ) . theFunction as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( udfContext ) , "::" ,
                stringify ! ( theFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfContext ) ) . lastPosition as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( udfContext ) , "::" ,
                stringify ! ( lastPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfContext ) ) . lastArg as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( udfContext ) , "::" ,
                stringify ! ( lastArg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udfContext ) ) . returnValue as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( udfContext ) , "::" ,
                stringify ! ( returnValue ) ));
}
impl Clone for udfContext {
    fn clone(&self) -> Self { *self }
}
pub type UDFContext = udfContext;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct entityRecord {
    pub name: *const ::std::os::raw::c_char,
    pub _bitfield_1: u16,
    pub shortPrintFunction: EntityPrintFunction,
    pub longPrintFunction: EntityPrintFunction,
    pub deleteFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *mut Environment)
                                                  -> bool>,
    pub evaluateFunction: EntityEvaluationFunction,
    pub getNextFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *mut ::std::os::raw::c_void)
                                                   ->
                                                       *mut ::std::os::raw::c_void>,
    pub decrementBusyCount: EntityBusyCountFunction,
    pub incrementBusyCount: EntityBusyCountFunction,
    pub propagateDepth: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *mut ::std::os::raw::c_void)>,
    pub markNeeded: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ::std::os::raw::c_void,
                                                               arg2:
                                                                   *mut ::std::os::raw::c_void)>,
    pub install: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut ::std::os::raw::c_void,
                                                            arg2:
                                                                *mut ::std::os::raw::c_void)>,
    pub deinstall: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void,
                                                              arg2:
                                                                  *mut ::std::os::raw::c_void)>,
    pub usrData: *mut userData,
}
#[test]
fn bindgen_test_layout_entityRecord() {
    assert_eq!(::std::mem::size_of::<entityRecord>() , 112usize , concat ! (
               "Size of: " , stringify ! ( entityRecord ) ));
    assert_eq! (::std::mem::align_of::<entityRecord>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( entityRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . shortPrintFunction as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( shortPrintFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . longPrintFunction as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( longPrintFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . deleteFunction as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( deleteFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . evaluateFunction as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( evaluateFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . getNextFunction as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( getNextFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . decrementBusyCount as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( decrementBusyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . incrementBusyCount as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( incrementBusyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . propagateDepth as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( propagateDepth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . markNeeded as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( markNeeded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . install as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( install ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . deinstall as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( deinstall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const entityRecord ) ) . usrData as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( entityRecord ) , "::" ,
                stringify ! ( usrData ) ));
}
impl Clone for entityRecord {
    fn clone(&self) -> Self { *self }
}
impl entityRecord {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8191u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8191u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn copyToEvaluate(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8192u64 as u16;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_copyToEvaluate(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8192u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn bitMap(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16384u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bitMap(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16384u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn addsToRuleComplexity(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_addsToRuleComplexity(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: ::std::os::raw::c_uint,
                          copyToEvaluate: ::std::os::raw::c_uint,
                          bitMap: ::std::os::raw::c_uint,
                          addsToRuleComplexity: ::std::os::raw::c_uint)
     -> u16 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((type_ as u32 as u16) << 0usize) &
                                (8191u64 as u16))
                   } |
                       ((copyToEvaluate as u32 as u16) << 13usize) &
                           (8192u64 as u16))
              } | ((bitMap as u32 as u16) << 14usize) & (16384u64 as u16))
         } |
             ((addsToRuleComplexity as u32 as u16) << 15usize) &
                 (32768u64 as u16))
    }
}
pub type EntityRecord = entityRecord;
pub type EntityPrintFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)>;
pub type EntityEvaluationFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *mut ::std::os::raw::c_void,
                                               arg3: *mut UDFValue) -> bool>;
pub type EntityBusyCountFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct patternEntityRecord {
    pub base: entityRecord,
    pub decrementBasisCount: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment,
                                                                        arg2:
                                                                            *mut ::std::os::raw::c_void)>,
    pub incrementBasisCount: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment,
                                                                        arg2:
                                                                            *mut ::std::os::raw::c_void)>,
    pub matchFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut Environment,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_void)>,
    pub synchronized: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut Environment,
                                                                 arg2:
                                                                     *mut ::std::os::raw::c_void)
                                                -> bool>,
    pub isDeleted: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut Environment,
                                                              arg2:
                                                                  *mut ::std::os::raw::c_void)
                                             -> bool>,
}
#[test]
fn bindgen_test_layout_patternEntityRecord() {
    assert_eq!(::std::mem::size_of::<patternEntityRecord>() , 152usize ,
               concat ! ( "Size of: " , stringify ! ( patternEntityRecord )
               ));
    assert_eq! (::std::mem::align_of::<patternEntityRecord>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( patternEntityRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntityRecord ) ) . base as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntityRecord ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntityRecord ) ) .
                decrementBasisCount as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( patternEntityRecord ) ,
                "::" , stringify ! ( decrementBasisCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntityRecord ) ) .
                incrementBasisCount as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( patternEntityRecord ) ,
                "::" , stringify ! ( incrementBasisCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntityRecord ) ) . matchFunction
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntityRecord ) ,
                "::" , stringify ! ( matchFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntityRecord ) ) . synchronized as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntityRecord ) ,
                "::" , stringify ! ( synchronized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntityRecord ) ) . isDeleted as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntityRecord ) ,
                "::" , stringify ! ( isDeleted ) ));
}
impl Clone for patternEntityRecord {
    fn clone(&self) -> Self { *self }
}
pub type PatternEntityRecord = patternEntityRecord;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct patternEntity {
    pub header: TypeHeader,
    pub theInfo: *mut patternEntityRecord,
    pub dependents: *mut ::std::os::raw::c_void,
    pub busyCount: ::std::os::raw::c_uint,
    pub timeTag: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_patternEntity() {
    assert_eq!(::std::mem::size_of::<patternEntity>() , 40usize , concat ! (
               "Size of: " , stringify ! ( patternEntity ) ));
    assert_eq! (::std::mem::align_of::<patternEntity>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( patternEntity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntity ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntity ) , "::"
                , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntity ) ) . theInfo as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntity ) , "::"
                , stringify ! ( theInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntity ) ) . dependents as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntity ) , "::"
                , stringify ! ( dependents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntity ) ) . busyCount as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntity ) , "::"
                , stringify ! ( busyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternEntity ) ) . timeTag as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( patternEntity ) , "::"
                , stringify ! ( timeTag ) ));
}
impl Clone for patternEntity {
    fn clone(&self) -> Self { *self }
}
pub type PatternEntity = patternEntity;
pub type BoolCallFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
pub type VoidCallFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
pub type VoidCallFunctionWithArg =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *mut ::std::os::raw::c_void,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct environmentCleanupFunction {
    pub name: *const ::std::os::raw::c_char,
    pub func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             *mut Environment)>,
    pub priority: ::std::os::raw::c_int,
    pub next: *mut environmentCleanupFunction,
}
#[test]
fn bindgen_test_layout_environmentCleanupFunction() {
    assert_eq!(::std::mem::size_of::<environmentCleanupFunction>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( environmentCleanupFunction ) ));
    assert_eq! (::std::mem::align_of::<environmentCleanupFunction>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( environmentCleanupFunction )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentCleanupFunction ) ) . name as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                environmentCleanupFunction ) , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentCleanupFunction ) ) . func as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                environmentCleanupFunction ) , "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentCleanupFunction ) ) . priority
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                environmentCleanupFunction ) , "::" , stringify ! ( priority )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const environmentCleanupFunction ) ) . next as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                environmentCleanupFunction ) , "::" , stringify ! ( next ) ));
}
impl Clone for environmentCleanupFunction {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn AllocateEnvironmentData(arg1: *mut Environment,
                                   arg2: ::std::os::raw::c_uint, arg3: usize,
                                   arg4: EnvironmentCleanupFunction) -> bool;
}
extern "C" {
    pub fn AddEnvironmentCleanupFunction(arg1: *mut Environment,
                                         arg2: *const ::std::os::raw::c_char,
                                         arg3: EnvironmentCleanupFunction,
                                         arg4: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn GetEnvironmentContext(arg1: *mut Environment)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SetEnvironmentContext(arg1: *mut Environment,
                                 arg2: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exprHashNode {
    pub hashval: ::std::os::raw::c_uint,
    pub count: ::std::os::raw::c_uint,
    pub exp: *mut Expression,
    pub next: *mut exprHashNode,
    pub bsaveID: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_exprHashNode() {
    assert_eq!(::std::mem::size_of::<exprHashNode>() , 32usize , concat ! (
               "Size of: " , stringify ! ( exprHashNode ) ));
    assert_eq! (::std::mem::align_of::<exprHashNode>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( exprHashNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exprHashNode ) ) . hashval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( exprHashNode ) , "::" ,
                stringify ! ( hashval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exprHashNode ) ) . count as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( exprHashNode ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exprHashNode ) ) . exp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( exprHashNode ) , "::" ,
                stringify ! ( exp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exprHashNode ) ) . next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( exprHashNode ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exprHashNode ) ) . bsaveID as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( exprHashNode ) , "::" ,
                stringify ! ( bsaveID ) ));
}
impl Clone for exprHashNode {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct savedContexts {
    pub rtn: bool,
    pub brk: bool,
    pub nxt: *mut savedContexts,
}
#[test]
fn bindgen_test_layout_savedContexts() {
    assert_eq!(::std::mem::size_of::<savedContexts>() , 16usize , concat ! (
               "Size of: " , stringify ! ( savedContexts ) ));
    assert_eq! (::std::mem::align_of::<savedContexts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( savedContexts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const savedContexts ) ) . rtn as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( savedContexts ) , "::"
                , stringify ! ( rtn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const savedContexts ) ) . brk as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( savedContexts ) , "::"
                , stringify ! ( brk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const savedContexts ) ) . nxt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( savedContexts ) , "::"
                , stringify ! ( nxt ) ));
}
impl Clone for savedContexts {
    fn clone(&self) -> Self { *self }
}
pub type SavedContexts = savedContexts;
extern "C" {
    pub fn ConstantExpression(arg1: *mut expr) -> bool;
}
extern "C" {
    pub fn PrintExpression(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *mut expr);
}
extern "C" {
    pub fn ExpressionSize(arg1: *mut expr) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CountArguments(arg1: *mut expr) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn CopyExpression(arg1: *mut Environment, arg2: *mut expr)
     -> *mut expr;
}
extern "C" {
    pub fn ExpressionContainsVariables(arg1: *mut expr, arg2: bool) -> bool;
}
extern "C" {
    pub fn IdenticalExpression(arg1: *mut expr, arg2: *mut expr) -> bool;
}
extern "C" {
    pub fn GenConstant(arg1: *mut Environment, arg2: ::std::os::raw::c_ushort,
                       arg3: *mut ::std::os::raw::c_void) -> *mut expr;
}
extern "C" {
    pub fn CheckArgumentAgainstRestriction(arg1: *mut Environment,
                                           arg2: *mut expr,
                                           arg3: ::std::os::raw::c_uint)
     -> bool;
}
extern "C" {
    pub fn ConstantType(arg1: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn CombineExpressions(arg1: *mut Environment, arg2: *mut expr,
                              arg3: *mut expr) -> *mut expr;
}
extern "C" {
    pub fn AppendExpressions(arg1: *mut expr, arg2: *mut expr) -> *mut expr;
}
extern "C" {
    pub fn NegateExpression(arg1: *mut Environment, arg2: *mut expr)
     -> *mut expr;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct construct {
    pub constructName: *const ::std::os::raw::c_char,
    pub pluralName: *const ::std::os::raw::c_char,
    pub parseFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut Environment,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char)
                                                 -> bool>,
    pub findFunction: FindConstructFunction,
    pub getConstructNameFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ConstructHeader)
                                                            ->
                                                                *mut CLIPSLexeme>,
    pub getPPFormFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ConstructHeader)
                                                     ->
                                                         *const ::std::os::raw::c_char>,
    pub getModuleItemFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ConstructHeader)
                                                         ->
                                                             *mut defmoduleItemHeader>,
    pub getNextItemFunction: GetNextConstructFunction,
    pub setNextItemFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ConstructHeader,
                                                                        arg2:
                                                                            *mut ConstructHeader)>,
    pub isConstructDeletableFunction: IsConstructDeletableFunction,
    pub deleteFunction: DeleteConstructFunction,
    pub freeFunction: FreeConstructFunction,
    pub next: *mut Construct,
}
#[test]
fn bindgen_test_layout_construct() {
    assert_eq!(::std::mem::size_of::<construct>() , 104usize , concat ! (
               "Size of: " , stringify ! ( construct ) ));
    assert_eq! (::std::mem::align_of::<construct>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( construct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . constructName as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( constructName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . pluralName as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( pluralName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . parseFunction as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( parseFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . findFunction as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( findFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . getConstructNameFunction
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( getConstructNameFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . getPPFormFunction as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( getPPFormFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . getModuleItemFunction as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( getModuleItemFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . getNextItemFunction as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( getNextItemFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . setNextItemFunction as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( setNextItemFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) .
                isConstructDeletableFunction as * const _ as usize } , 72usize
                , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( isConstructDeletableFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . deleteFunction as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( deleteFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . freeFunction as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( freeFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const construct ) ) . next as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( construct ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for construct {
    fn clone(&self) -> Self { *self }
}
pub type Construct = construct;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct userData {
    pub dataID: ::std::os::raw::c_uchar,
    pub next: *mut userData,
}
#[test]
fn bindgen_test_layout_userData() {
    assert_eq!(::std::mem::size_of::<userData>() , 16usize , concat ! (
               "Size of: " , stringify ! ( userData ) ));
    assert_eq! (::std::mem::align_of::<userData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( userData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const userData ) ) . dataID as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( userData ) , "::" ,
                stringify ! ( dataID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const userData ) ) . next as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( userData ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for userData {
    fn clone(&self) -> Self { *self }
}
pub type USER_DATA = userData;
pub type USER_DATA_PTR = *mut userData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct userDataRecord {
    pub dataID: ::std::os::raw::c_uchar,
    pub createUserData: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut Environment)
                                                  ->
                                                      *mut ::std::os::raw::c_void>,
    pub deleteUserData: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut Environment,
                                                                   arg2:
                                                                       *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_userDataRecord() {
    assert_eq!(::std::mem::size_of::<userDataRecord>() , 24usize , concat ! (
               "Size of: " , stringify ! ( userDataRecord ) ));
    assert_eq! (::std::mem::align_of::<userDataRecord>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( userDataRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const userDataRecord ) ) . dataID as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( userDataRecord ) , "::"
                , stringify ! ( dataID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const userDataRecord ) ) . createUserData as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( userDataRecord ) , "::"
                , stringify ! ( createUserData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const userDataRecord ) ) . deleteUserData as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( userDataRecord ) , "::"
                , stringify ! ( deleteUserData ) ));
}
impl Clone for userDataRecord {
    fn clone(&self) -> Self { *self }
}
pub type USER_DATA_RECORD = userDataRecord;
pub type USER_DATA_RECORD_PTR = *mut userDataRecord;
#[repr(C)]
#[derive(Copy)]
pub struct userDataData {
    pub UserDataRecordArray: [*mut userDataRecord; 100usize],
    pub UserDataRecordCount: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_userDataData() {
    assert_eq!(::std::mem::size_of::<userDataData>() , 808usize , concat ! (
               "Size of: " , stringify ! ( userDataData ) ));
    assert_eq! (::std::mem::align_of::<userDataData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( userDataData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const userDataData ) ) . UserDataRecordArray as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( userDataData ) , "::" ,
                stringify ! ( UserDataRecordArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const userDataData ) ) . UserDataRecordCount as
                * const _ as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( userDataData ) , "::" ,
                stringify ! ( UserDataRecordCount ) ));
}
impl Clone for userDataData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeUserDataData(arg1: *mut Environment);
}
extern "C" {
    pub fn InstallUserDataRecord(arg1: *mut Environment,
                                 arg2: *mut userDataRecord)
     -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn FetchUserData(arg1: *mut Environment,
                         arg2: ::std::os::raw::c_uchar,
                         arg3: *mut *mut userData) -> *mut userData;
}
extern "C" {
    pub fn TestUserData(arg1: ::std::os::raw::c_uchar, arg2: *mut userData)
     -> *mut userData;
}
extern "C" {
    pub fn ClearUserDataList(arg1: *mut Environment, arg2: *mut userData);
}
extern "C" {
    pub fn DeleteUserData(arg1: *mut Environment,
                          arg2: ::std::os::raw::c_uchar, arg3: *mut userData)
     -> *mut userData;
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct defmodule {
    pub header: ConstructHeader,
    pub itemsArray: *mut *mut DefmoduleItemHeader,
    pub importList: *mut PortItem,
    pub exportList: *mut PortItem,
    pub visitedFlag: bool,
}
#[test]
fn bindgen_test_layout_defmodule() {
    assert_eq!(::std::mem::size_of::<defmodule>() , 96usize , concat ! (
               "Size of: " , stringify ! ( defmodule ) ));
    assert_eq! (::std::mem::align_of::<defmodule>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defmodule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmodule ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defmodule ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmodule ) ) . itemsArray as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( defmodule ) , "::" ,
                stringify ! ( itemsArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmodule ) ) . importList as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( defmodule ) , "::" ,
                stringify ! ( importList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmodule ) ) . exportList as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( defmodule ) , "::" ,
                stringify ! ( exportList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmodule ) ) . visitedFlag as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( defmodule ) , "::" ,
                stringify ! ( visitedFlag ) ));
}
impl Clone for defmodule {
    fn clone(&self) -> Self { *self }
}
pub type Defmodule = defmodule;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct portItem {
    pub moduleName: *mut CLIPSLexeme,
    pub constructType: *mut CLIPSLexeme,
    pub constructName: *mut CLIPSLexeme,
    pub next: *mut PortItem,
}
#[test]
fn bindgen_test_layout_portItem() {
    assert_eq!(::std::mem::size_of::<portItem>() , 32usize , concat ! (
               "Size of: " , stringify ! ( portItem ) ));
    assert_eq! (::std::mem::align_of::<portItem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( portItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const portItem ) ) . moduleName as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( portItem ) , "::" ,
                stringify ! ( moduleName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const portItem ) ) . constructType as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( portItem ) , "::" ,
                stringify ! ( constructType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const portItem ) ) . constructName as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( portItem ) , "::" ,
                stringify ! ( constructName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const portItem ) ) . next as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( portItem ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for portItem {
    fn clone(&self) -> Self { *self }
}
pub type PortItem = portItem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defmoduleItemHeader {
    pub theModule: *mut Defmodule,
    pub firstItem: *mut ConstructHeader,
    pub lastItem: *mut ConstructHeader,
}
#[test]
fn bindgen_test_layout_defmoduleItemHeader() {
    assert_eq!(::std::mem::size_of::<defmoduleItemHeader>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( defmoduleItemHeader ) ));
    assert_eq! (::std::mem::align_of::<defmoduleItemHeader>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( defmoduleItemHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleItemHeader ) ) . theModule as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleItemHeader ) ,
                "::" , stringify ! ( theModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleItemHeader ) ) . firstItem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleItemHeader ) ,
                "::" , stringify ! ( firstItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleItemHeader ) ) . lastItem as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleItemHeader ) ,
                "::" , stringify ! ( lastItem ) ));
}
impl Clone for defmoduleItemHeader {
    fn clone(&self) -> Self { *self }
}
pub type DefmoduleItemHeader = defmoduleItemHeader;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct moduleItem {
    pub name: *const ::std::os::raw::c_char,
    pub moduleIndex: ::std::os::raw::c_uint,
    pub allocateFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut Environment)
                                                    ->
                                                        *mut ::std::os::raw::c_void>,
    pub freeFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut Environment,
                                                                 arg2:
                                                                     *mut ::std::os::raw::c_void)>,
    pub bloadModuleReference: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut Environment,
                                                                         arg2:
                                                                             ::std::os::raw::c_ulong)
                                                        ->
                                                            *mut ::std::os::raw::c_void>,
    pub constructsToCModuleReference: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                     *mut Environment,
                                                                                 arg2:
                                                                                     *mut FILE,
                                                                                 arg3:
                                                                                     ::std::os::raw::c_ulong,
                                                                                 arg4:
                                                                                     ::std::os::raw::c_uint,
                                                                                 arg5:
                                                                                     ::std::os::raw::c_uint)>,
    pub findFunction: FindConstructFunction,
    pub next: *mut ModuleItem,
}
#[test]
fn bindgen_test_layout_moduleItem() {
    assert_eq!(::std::mem::size_of::<moduleItem>() , 64usize , concat ! (
               "Size of: " , stringify ! ( moduleItem ) ));
    assert_eq! (::std::mem::align_of::<moduleItem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( moduleItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleItem ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleItem ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleItem ) ) . moduleIndex as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleItem ) , "::" ,
                stringify ! ( moduleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleItem ) ) . allocateFunction as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleItem ) , "::" ,
                stringify ! ( allocateFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleItem ) ) . freeFunction as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleItem ) , "::" ,
                stringify ! ( freeFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleItem ) ) . bloadModuleReference as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleItem ) , "::" ,
                stringify ! ( bloadModuleReference ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleItem ) ) .
                constructsToCModuleReference as * const _ as usize } , 40usize
                , concat ! (
                "Alignment of field: " , stringify ! ( moduleItem ) , "::" ,
                stringify ! ( constructsToCModuleReference ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleItem ) ) . findFunction as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleItem ) , "::" ,
                stringify ! ( findFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleItem ) ) . next as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleItem ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for moduleItem {
    fn clone(&self) -> Self { *self }
}
pub type ModuleItem = moduleItem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct constructHeader {
    pub constructType: ConstructType,
    pub name: *mut CLIPSLexeme,
    pub ppForm: *const ::std::os::raw::c_char,
    pub whichModule: *mut DefmoduleItemHeader,
    pub bsaveID: ::std::os::raw::c_ulong,
    pub next: *mut ConstructHeader,
    pub usrData: *mut userData,
    pub env: *mut Environment,
}
#[test]
fn bindgen_test_layout_constructHeader() {
    assert_eq!(::std::mem::size_of::<constructHeader>() , 64usize , concat ! (
               "Size of: " , stringify ! ( constructHeader ) ));
    assert_eq! (::std::mem::align_of::<constructHeader>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( constructHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructHeader ) ) . constructType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( constructHeader ) ,
                "::" , stringify ! ( constructType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructHeader ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( constructHeader ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructHeader ) ) . ppForm as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( constructHeader ) ,
                "::" , stringify ! ( ppForm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructHeader ) ) . whichModule as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( constructHeader ) ,
                "::" , stringify ! ( whichModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructHeader ) ) . bsaveID as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( constructHeader ) ,
                "::" , stringify ! ( bsaveID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructHeader ) ) . next as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( constructHeader ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructHeader ) ) . usrData as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( constructHeader ) ,
                "::" , stringify ! ( usrData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructHeader ) ) . env as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( constructHeader ) ,
                "::" , stringify ! ( env ) ));
}
impl Clone for constructHeader {
    fn clone(&self) -> Self { *self }
}
pub type ConstructHeader = constructHeader;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct moduleStackItem {
    pub changeFlag: bool,
    pub theModule: *mut Defmodule,
    pub next: *mut ModuleStackItem,
}
#[test]
fn bindgen_test_layout_moduleStackItem() {
    assert_eq!(::std::mem::size_of::<moduleStackItem>() , 24usize , concat ! (
               "Size of: " , stringify ! ( moduleStackItem ) ));
    assert_eq! (::std::mem::align_of::<moduleStackItem>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( moduleStackItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleStackItem ) ) . changeFlag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleStackItem ) ,
                "::" , stringify ! ( changeFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleStackItem ) ) . theModule as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleStackItem ) ,
                "::" , stringify ! ( theModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduleStackItem ) ) . next as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( moduleStackItem ) ,
                "::" , stringify ! ( next ) ));
}
impl Clone for moduleStackItem {
    fn clone(&self) -> Self { *self }
}
pub type ModuleStackItem = moduleStackItem;
pub type AllocateModuleFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment)
                              -> *mut ::std::os::raw::c_void>;
pub type FreeModuleFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ConstructType {
    DEFMODULE = 0,
    DEFRULE = 1,
    DEFTEMPLATE = 2,
    DEFFACTS = 3,
    DEFGLOBAL = 4,
    DEFFUNCTION = 5,
    DEFGENERIC = 6,
    DEFMETHOD = 7,
    DEFCLASS = 8,
    DEFMESSAGE_HANDLER = 9,
    DEFINSTANCES = 10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callFunctionItem {
    _unused: [u8; 0],
}
pub type CallFunctionItem = callFunctionItem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callFunctionItemWithArg {
    pub name: *const ::std::os::raw::c_char,
    pub func: VoidCallFunctionWithArg,
    pub priority: ::std::os::raw::c_int,
    pub next: *mut callFunctionItemWithArg,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_callFunctionItemWithArg() {
    assert_eq!(::std::mem::size_of::<callFunctionItemWithArg>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( callFunctionItemWithArg ) ));
    assert_eq! (::std::mem::align_of::<callFunctionItemWithArg>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( callFunctionItemWithArg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callFunctionItemWithArg ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callFunctionItemWithArg
                ) , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callFunctionItemWithArg ) ) . func as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( callFunctionItemWithArg
                ) , "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callFunctionItemWithArg ) ) . priority as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( callFunctionItemWithArg
                ) , "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callFunctionItemWithArg ) ) . next as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( callFunctionItemWithArg
                ) , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callFunctionItemWithArg ) ) . context as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( callFunctionItemWithArg
                ) , "::" , stringify ! ( context ) ));
}
impl Clone for callFunctionItemWithArg {
    fn clone(&self) -> Self { *self }
}
pub type CallFunctionItemWithArg = callFunctionItemWithArg;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct boolCallFunctionItem {
    pub name: *const ::std::os::raw::c_char,
    pub func: BoolCallFunction,
    pub priority: ::std::os::raw::c_int,
    pub next: *mut boolCallFunctionItem,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_boolCallFunctionItem() {
    assert_eq!(::std::mem::size_of::<boolCallFunctionItem>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( boolCallFunctionItem )
               ));
    assert_eq! (::std::mem::align_of::<boolCallFunctionItem>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( boolCallFunctionItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boolCallFunctionItem ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( boolCallFunctionItem )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boolCallFunctionItem ) ) . func as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( boolCallFunctionItem )
                , "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boolCallFunctionItem ) ) . priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( boolCallFunctionItem )
                , "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boolCallFunctionItem ) ) . next as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( boolCallFunctionItem )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boolCallFunctionItem ) ) . context as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( boolCallFunctionItem )
                , "::" , stringify ! ( context ) ));
}
impl Clone for boolCallFunctionItem {
    fn clone(&self) -> Self { *self }
}
pub type BoolCallFunctionItem = boolCallFunctionItem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct voidCallFunctionItem {
    pub name: *const ::std::os::raw::c_char,
    pub func: VoidCallFunction,
    pub priority: ::std::os::raw::c_int,
    pub next: *mut voidCallFunctionItem,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_voidCallFunctionItem() {
    assert_eq!(::std::mem::size_of::<voidCallFunctionItem>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( voidCallFunctionItem )
               ));
    assert_eq! (::std::mem::align_of::<voidCallFunctionItem>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( voidCallFunctionItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const voidCallFunctionItem ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( voidCallFunctionItem )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const voidCallFunctionItem ) ) . func as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( voidCallFunctionItem )
                , "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const voidCallFunctionItem ) ) . priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( voidCallFunctionItem )
                , "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const voidCallFunctionItem ) ) . next as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( voidCallFunctionItem )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const voidCallFunctionItem ) ) . context as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( voidCallFunctionItem )
                , "::" , stringify ! ( context ) ));
}
impl Clone for voidCallFunctionItem {
    fn clone(&self) -> Self { *self }
}
pub type VoidCallFunctionItem = voidCallFunctionItem;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SaveScope { LOCAL_SAVE = 0, VISIBLE_SAVE = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DefaultType {
    NO_DEFAULT = 0,
    STATIC_DEFAULT = 1,
    DYNAMIC_DEFAULT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PutSlotError {
    PSE_NO_ERROR = 0,
    PSE_NULL_POINTER_ERROR = 1,
    PSE_INVALID_TARGET_ERROR = 2,
    PSE_SLOT_NOT_FOUND_ERROR = 3,
    PSE_TYPE_ERROR = 4,
    PSE_RANGE_ERROR = 5,
    PSE_ALLOWED_VALUES_ERROR = 6,
    PSE_CARDINALITY_ERROR = 7,
    PSE_ALLOWED_CLASSES_ERROR = 8,
    PSE_EVALUATION_ERROR = 9,
    PSE_RULE_NETWORK_ERROR = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GetSlotError {
    GSE_NO_ERROR = 0,
    GSE_NULL_POINTER_ERROR = 1,
    GSE_INVALID_TARGET_ERROR = 2,
    GSE_SLOT_NOT_FOUND_ERROR = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CLIPSType {
    FLOAT_BIT = 1,
    INTEGER_BIT = 2,
    SYMBOL_BIT = 4,
    STRING_BIT = 8,
    MULTIFIELD_BIT = 16,
    EXTERNAL_ADDRESS_BIT = 32,
    FACT_ADDRESS_BIT = 64,
    INSTANCE_ADDRESS_BIT = 128,
    INSTANCE_NAME_BIT = 256,
    VOID_BIT = 512,
    BOOLEAN_BIT = 1024,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct functionCallBuilder {
    pub fcbEnv: *mut Environment,
    pub contents: *mut CLIPSValue,
    pub bufferReset: usize,
    pub length: usize,
    pub bufferMaximum: usize,
}
#[test]
fn bindgen_test_layout_functionCallBuilder() {
    assert_eq!(::std::mem::size_of::<functionCallBuilder>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( functionCallBuilder ) ));
    assert_eq! (::std::mem::align_of::<functionCallBuilder>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( functionCallBuilder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionCallBuilder ) ) . fcbEnv as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( functionCallBuilder ) ,
                "::" , stringify ! ( fcbEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionCallBuilder ) ) . contents as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( functionCallBuilder ) ,
                "::" , stringify ! ( contents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionCallBuilder ) ) . bufferReset as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( functionCallBuilder ) ,
                "::" , stringify ! ( bufferReset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionCallBuilder ) ) . length as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( functionCallBuilder ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const functionCallBuilder ) ) . bufferMaximum
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( functionCallBuilder ) ,
                "::" , stringify ! ( bufferMaximum ) ));
}
impl Clone for functionCallBuilder {
    fn clone(&self) -> Self { *self }
}
pub type FunctionCallBuilder = functionCallBuilder;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FunctionCallBuilderError {
    FCBE_NO_ERROR = 0,
    FCBE_NULL_POINTER_ERROR = 1,
    FCBE_FUNCTION_NOT_FOUND_ERROR = 2,
    FCBE_INVALID_FUNCTION_ERROR = 3,
    FCBE_ARGUMENT_COUNT_ERROR = 4,
    FCBE_ARGUMENT_TYPE_ERROR = 5,
    FCBE_PROCESSING_ERROR = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct externalAddressType {
    pub name: *const ::std::os::raw::c_char,
    pub shortPrintFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut Environment,
                                                                       arg2:
                                                                           *const ::std::os::raw::c_char,
                                                                       arg3:
                                                                           *mut ::std::os::raw::c_void)>,
    pub longPrintFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut Environment,
                                                                      arg2:
                                                                          *const ::std::os::raw::c_char,
                                                                      arg3:
                                                                          *mut ::std::os::raw::c_void)>,
    pub discardFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut Environment,
                                                                    arg2:
                                                                        *mut ::std::os::raw::c_void)
                                                   -> bool>,
    pub newFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut UDFContext,
                                                                arg2:
                                                                    *mut UDFValue)>,
    pub callFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut UDFContext,
                                                                 arg2:
                                                                     *mut UDFValue,
                                                                 arg3:
                                                                     *mut UDFValue)
                                                -> bool>,
}
#[test]
fn bindgen_test_layout_externalAddressType() {
    assert_eq!(::std::mem::size_of::<externalAddressType>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( externalAddressType ) ));
    assert_eq! (::std::mem::align_of::<externalAddressType>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( externalAddressType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const externalAddressType ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( externalAddressType ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const externalAddressType ) ) .
                shortPrintFunction as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( externalAddressType ) ,
                "::" , stringify ! ( shortPrintFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const externalAddressType ) ) .
                longPrintFunction as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( externalAddressType ) ,
                "::" , stringify ! ( longPrintFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const externalAddressType ) ) . discardFunction
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( externalAddressType ) ,
                "::" , stringify ! ( discardFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const externalAddressType ) ) . newFunction as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( externalAddressType ) ,
                "::" , stringify ! ( newFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const externalAddressType ) ) . callFunction as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( externalAddressType ) ,
                "::" , stringify ! ( callFunction ) ));
}
impl Clone for externalAddressType {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct evaluationData {
    pub CurrentExpression: *mut expr,
    pub EvaluationError: bool,
    pub HaltExecution: bool,
    pub CurrentEvaluationDepth: ::std::os::raw::c_int,
    pub numberOfAddressTypes: ::std::os::raw::c_int,
    pub PrimitivesArray: [*mut entityRecord; 150usize],
    pub ExternalAddressTypes: [*mut externalAddressType; 10usize],
}
#[test]
fn bindgen_test_layout_evaluationData() {
    assert_eq!(::std::mem::size_of::<evaluationData>() , 1304usize , concat !
               ( "Size of: " , stringify ! ( evaluationData ) ));
    assert_eq! (::std::mem::align_of::<evaluationData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( evaluationData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const evaluationData ) ) . CurrentExpression as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( evaluationData ) , "::"
                , stringify ! ( CurrentExpression ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const evaluationData ) ) . EvaluationError as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( evaluationData ) , "::"
                , stringify ! ( EvaluationError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const evaluationData ) ) . HaltExecution as *
                const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( evaluationData ) , "::"
                , stringify ! ( HaltExecution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const evaluationData ) ) .
                CurrentEvaluationDepth as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( evaluationData ) , "::"
                , stringify ! ( CurrentEvaluationDepth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const evaluationData ) ) . numberOfAddressTypes
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( evaluationData ) , "::"
                , stringify ! ( numberOfAddressTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const evaluationData ) ) . PrimitivesArray as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( evaluationData ) , "::"
                , stringify ! ( PrimitivesArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const evaluationData ) ) . ExternalAddressTypes
                as * const _ as usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( evaluationData ) , "::"
                , stringify ! ( ExternalAddressTypes ) ));
}
impl Clone for evaluationData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeEvaluationData(arg1: *mut Environment);
}
extern "C" {
    pub fn EvaluateExpression(arg1: *mut Environment, arg2: *mut expr,
                              arg3: *mut UDFValue) -> bool;
}
extern "C" {
    pub fn SetEvaluationError(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn GetEvaluationError(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetHaltExecution(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn GetHaltExecution(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn ReturnValues(arg1: *mut Environment, arg2: *mut UDFValue,
                        arg3: bool);
}
extern "C" {
    pub fn WriteUDFValue(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn WriteCLIPSValue(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *mut CLIPSValue);
}
extern "C" {
    pub fn SetMultifieldErrorValue(arg1: *mut Environment,
                                   arg2: *mut UDFValue);
}
extern "C" {
    pub fn CopyDataObject(arg1: *mut Environment, arg2: *mut UDFValue,
                          arg3: *mut UDFValue, arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn AtomInstall(arg1: *mut Environment, arg2: ::std::os::raw::c_ushort,
                       arg3: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn AtomDeinstall(arg1: *mut Environment,
                         arg2: ::std::os::raw::c_ushort,
                         arg3: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn Retain(arg1: *mut Environment, arg2: *mut TypeHeader);
}
extern "C" {
    pub fn Release(arg1: *mut Environment, arg2: *mut TypeHeader);
}
extern "C" {
    pub fn RetainCV(arg1: *mut Environment, arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn ReleaseCV(arg1: *mut Environment, arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn RetainUDFV(arg1: *mut Environment, arg2: *mut UDFValue);
}
extern "C" {
    pub fn ReleaseUDFV(arg1: *mut Environment, arg2: *mut UDFValue);
}
extern "C" {
    pub fn ConvertValueToExpression(arg1: *mut Environment,
                                    arg2: *mut UDFValue) -> *mut expr;
}
extern "C" {
    pub fn GetAtomicHashValue(arg1: ::std::os::raw::c_ushort,
                              arg2: *mut ::std::os::raw::c_void,
                              arg3: ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn InstallPrimitive(arg1: *mut Environment, arg2: *mut entityRecord,
                            arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn InstallExternalAddressType(arg1: *mut Environment,
                                      arg2: *mut externalAddressType)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TransferDataObjectValues(arg1: *mut UDFValue, arg2: *mut UDFValue);
}
extern "C" {
    pub fn FunctionReferenceExpression(arg1: *mut Environment,
                                       arg2: *const ::std::os::raw::c_char)
     -> *mut expr;
}
extern "C" {
    pub fn GetFunctionReference(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: *mut Expression) -> bool;
}
extern "C" {
    pub fn DOsEqual(arg1: *mut UDFValue, arg2: *mut UDFValue) -> bool;
}
extern "C" {
    pub fn EvaluateAndStoreInDataObject(arg1: *mut Environment, arg2: bool,
                                        arg3: *mut Expression,
                                        arg4: *mut UDFValue, arg5: bool)
     -> bool;
}
extern "C" {
    pub fn ResetErrorFlags(arg1: *mut Environment);
}
extern "C" {
    pub fn CreateFunctionCallBuilder(arg1: *mut Environment, arg2: usize)
     -> *mut FunctionCallBuilder;
}
extern "C" {
    pub fn FCBAppendUDFValue(arg1: *mut FunctionCallBuilder,
                             arg2: *mut UDFValue);
}
extern "C" {
    pub fn FCBAppend(arg1: *mut FunctionCallBuilder, arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn FCBAppendCLIPSInteger(arg1: *mut FunctionCallBuilder,
                                 arg2: *mut CLIPSInteger);
}
extern "C" {
    pub fn FCBAppendInteger(arg1: *mut FunctionCallBuilder,
                            arg2: ::std::os::raw::c_longlong);
}
extern "C" {
    pub fn FCBAppendCLIPSFloat(arg1: *mut FunctionCallBuilder,
                               arg2: *mut CLIPSFloat);
}
extern "C" {
    pub fn FCBAppendFloat(arg1: *mut FunctionCallBuilder, arg2: f64);
}
extern "C" {
    pub fn FCBAppendCLIPSLexeme(arg1: *mut FunctionCallBuilder,
                                arg2: *mut CLIPSLexeme);
}
extern "C" {
    pub fn FCBAppendSymbol(arg1: *mut FunctionCallBuilder,
                           arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn FCBAppendString(arg1: *mut FunctionCallBuilder,
                           arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn FCBAppendInstanceName(arg1: *mut FunctionCallBuilder,
                                 arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn FCBAppendCLIPSExternalAddress(arg1: *mut FunctionCallBuilder,
                                         arg2: *mut CLIPSExternalAddress);
}
extern "C" {
    pub fn FCBAppendFact(arg1: *mut FunctionCallBuilder, arg2: *mut Fact);
}
extern "C" {
    pub fn FCBAppendInstance(arg1: *mut FunctionCallBuilder,
                             arg2: *mut Instance);
}
extern "C" {
    pub fn FCBAppendMultifield(arg1: *mut FunctionCallBuilder,
                               arg2: *mut Multifield);
}
extern "C" {
    pub fn FCBDispose(arg1: *mut FunctionCallBuilder);
}
extern "C" {
    pub fn FCBReset(arg1: *mut FunctionCallBuilder);
}
extern "C" {
    pub fn FCBCall(arg1: *mut FunctionCallBuilder,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut CLIPSValue)
     -> FunctionCallBuilderError;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gcBlock {
    pub newGarbageFrame: garbageFrame,
    pub oldGarbageFrame: *mut garbageFrame,
    pub result: *mut UDFValue,
}
#[test]
fn bindgen_test_layout_gcBlock() {
    assert_eq!(::std::mem::size_of::<gcBlock>() , 88usize , concat ! (
               "Size of: " , stringify ! ( gcBlock ) ));
    assert_eq! (::std::mem::align_of::<gcBlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( gcBlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcBlock ) ) . newGarbageFrame as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gcBlock ) , "::" ,
                stringify ! ( newGarbageFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcBlock ) ) . oldGarbageFrame as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( gcBlock ) , "::" ,
                stringify ! ( oldGarbageFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gcBlock ) ) . result as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( gcBlock ) , "::" ,
                stringify ! ( result ) ));
}
impl Clone for gcBlock {
    fn clone(&self) -> Self { *self }
}
pub type GCBlock = gcBlock;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stringBuilder {
    pub sbEnv: *mut Environment,
    pub contents: *mut ::std::os::raw::c_char,
    pub bufferReset: usize,
    pub length: usize,
    pub bufferMaximum: usize,
}
#[test]
fn bindgen_test_layout_stringBuilder() {
    assert_eq!(::std::mem::size_of::<stringBuilder>() , 40usize , concat ! (
               "Size of: " , stringify ! ( stringBuilder ) ));
    assert_eq! (::std::mem::align_of::<stringBuilder>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stringBuilder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringBuilder ) ) . sbEnv as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stringBuilder ) , "::"
                , stringify ! ( sbEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringBuilder ) ) . contents as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stringBuilder ) , "::"
                , stringify ! ( contents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringBuilder ) ) . bufferReset as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stringBuilder ) , "::"
                , stringify ! ( bufferReset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringBuilder ) ) . length as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( stringBuilder ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringBuilder ) ) . bufferMaximum as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( stringBuilder ) , "::"
                , stringify ! ( bufferMaximum ) ));
}
impl Clone for stringBuilder {
    fn clone(&self) -> Self { *self }
}
pub type StringBuilder = stringBuilder;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct trackedMemory {
    pub theMemory: *mut ::std::os::raw::c_void,
    pub next: *mut trackedMemory,
    pub prev: *mut trackedMemory,
    pub memSize: usize,
}
#[test]
fn bindgen_test_layout_trackedMemory() {
    assert_eq!(::std::mem::size_of::<trackedMemory>() , 32usize , concat ! (
               "Size of: " , stringify ! ( trackedMemory ) ));
    assert_eq! (::std::mem::align_of::<trackedMemory>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( trackedMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trackedMemory ) ) . theMemory as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( trackedMemory ) , "::"
                , stringify ! ( theMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trackedMemory ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( trackedMemory ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trackedMemory ) ) . prev as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( trackedMemory ) , "::"
                , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trackedMemory ) ) . memSize as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( trackedMemory ) , "::"
                , stringify ! ( memSize ) ));
}
impl Clone for trackedMemory {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct garbageFrame {
    pub dirty: bool,
    pub priorFrame: *mut garbageFrame,
    pub ephemeralSymbolList: *mut ephemeron,
    pub ephemeralFloatList: *mut ephemeron,
    pub ephemeralIntegerList: *mut ephemeron,
    pub ephemeralBitMapList: *mut ephemeron,
    pub ephemeralExternalAddressList: *mut ephemeron,
    pub ListOfMultifields: *mut Multifield,
    pub LastMultifield: *mut Multifield,
}
#[test]
fn bindgen_test_layout_garbageFrame() {
    assert_eq!(::std::mem::size_of::<garbageFrame>() , 72usize , concat ! (
               "Size of: " , stringify ! ( garbageFrame ) ));
    assert_eq! (::std::mem::align_of::<garbageFrame>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( garbageFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) . dirty as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( dirty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) . priorFrame as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( priorFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) . ephemeralSymbolList as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( ephemeralSymbolList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) . ephemeralFloatList as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( ephemeralFloatList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) . ephemeralIntegerList
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( ephemeralIntegerList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) . ephemeralBitMapList as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( ephemeralBitMapList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) .
                ephemeralExternalAddressList as * const _ as usize } , 48usize
                , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( ephemeralExternalAddressList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) . ListOfMultifields as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( ListOfMultifields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const garbageFrame ) ) . LastMultifield as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( garbageFrame ) , "::" ,
                stringify ! ( LastMultifield ) ));
}
impl Clone for garbageFrame {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct utilityData {
    pub ListOfCleanupFunctions: *mut voidCallFunctionItem,
    pub ListOfPeriodicFunctions: *mut voidCallFunctionItem,
    pub PeriodicFunctionsEnabled: bool,
    pub YieldFunctionEnabled: bool,
    pub YieldTimeFunction: ::std::option::Option<unsafe extern "C" fn()>,
    pub trackList: *mut trackedMemory,
    pub MasterGarbageFrame: garbageFrame,
    pub CurrentGarbageFrame: *mut garbageFrame,
}
#[test]
fn bindgen_test_layout_utilityData() {
    assert_eq!(::std::mem::size_of::<utilityData>() , 120usize , concat ! (
               "Size of: " , stringify ! ( utilityData ) ));
    assert_eq! (::std::mem::align_of::<utilityData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( utilityData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const utilityData ) ) . ListOfCleanupFunctions
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( utilityData ) , "::" ,
                stringify ! ( ListOfCleanupFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const utilityData ) ) . ListOfPeriodicFunctions
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( utilityData ) , "::" ,
                stringify ! ( ListOfPeriodicFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const utilityData ) ) .
                PeriodicFunctionsEnabled as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( utilityData ) , "::" ,
                stringify ! ( PeriodicFunctionsEnabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const utilityData ) ) . YieldFunctionEnabled as
                * const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( utilityData ) , "::" ,
                stringify ! ( YieldFunctionEnabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const utilityData ) ) . YieldTimeFunction as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( utilityData ) , "::" ,
                stringify ! ( YieldTimeFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const utilityData ) ) . trackList as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( utilityData ) , "::" ,
                stringify ! ( trackList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const utilityData ) ) . MasterGarbageFrame as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( utilityData ) , "::" ,
                stringify ! ( MasterGarbageFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const utilityData ) ) . CurrentGarbageFrame as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( utilityData ) , "::" ,
                stringify ! ( CurrentGarbageFrame ) ));
}
impl Clone for utilityData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeUtilityData(arg1: *mut Environment);
}
extern "C" {
    pub fn AddCleanupFunction(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: VoidCallFunction,
                              arg4: ::std::os::raw::c_int,
                              arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn AddPeriodicFunction(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: VoidCallFunction,
                               arg4: ::std::os::raw::c_int,
                               arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn RemoveCleanupFunction(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn RemovePeriodicFunction(arg1: *mut Environment,
                                  arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn CopyString(arg1: *mut Environment,
                      arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn DeleteString(arg1: *mut Environment,
                        arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn AppendStrings(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn StringPrintForm(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AppendToString(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *mut ::std::os::raw::c_char, arg4: *mut usize,
                          arg5: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn InsertInString(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char, arg3: usize,
                          arg4: *mut ::std::os::raw::c_char, arg5: *mut usize,
                          arg6: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn AppendNToString(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *mut ::std::os::raw::c_char, arg4: usize,
                           arg5: *mut usize, arg6: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnlargeString(arg1: *mut Environment, arg2: usize,
                         arg3: *mut ::std::os::raw::c_char, arg4: *mut usize,
                         arg5: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ExpandStringWithChar(arg1: *mut Environment,
                                arg2: ::std::os::raw::c_int,
                                arg3: *mut ::std::os::raw::c_char,
                                arg4: *mut usize, arg5: *mut usize,
                                arg6: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn AddVoidFunctionToCallList(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: ::std::os::raw::c_int,
                                     arg4: VoidCallFunction,
                                     arg5: *mut VoidCallFunctionItem,
                                     arg6: *mut ::std::os::raw::c_void)
     -> *mut VoidCallFunctionItem;
}
extern "C" {
    pub fn AddBoolFunctionToCallList(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: ::std::os::raw::c_int,
                                     arg4: BoolCallFunction,
                                     arg5: *mut BoolCallFunctionItem,
                                     arg6: *mut ::std::os::raw::c_void)
     -> *mut BoolCallFunctionItem;
}
extern "C" {
    pub fn RemoveVoidFunctionFromCallList(arg1: *mut Environment,
                                          arg2: *const ::std::os::raw::c_char,
                                          arg3: *mut VoidCallFunctionItem,
                                          arg4: *mut bool)
     -> *mut VoidCallFunctionItem;
}
extern "C" {
    pub fn RemoveBoolFunctionFromCallList(arg1: *mut Environment,
                                          arg2: *const ::std::os::raw::c_char,
                                          arg3: *mut BoolCallFunctionItem,
                                          arg4: *mut bool)
     -> *mut BoolCallFunctionItem;
}
extern "C" {
    pub fn DeallocateVoidCallList(arg1: *mut Environment,
                                  arg2: *mut VoidCallFunctionItem);
}
extern "C" {
    pub fn DeallocateBoolCallList(arg1: *mut Environment,
                                  arg2: *mut BoolCallFunctionItem);
}
extern "C" {
    pub fn AddFunctionToCallListWithArg(arg1: *mut Environment,
                                        arg2: *const ::std::os::raw::c_char,
                                        arg3: ::std::os::raw::c_int,
                                        arg4: VoidCallFunctionWithArg,
                                        arg5: *mut CallFunctionItemWithArg,
                                        arg6: *mut ::std::os::raw::c_void)
     -> *mut CallFunctionItemWithArg;
}
extern "C" {
    pub fn RemoveFunctionFromCallListWithArg(arg1: *mut Environment,
                                             arg2:
                                                 *const ::std::os::raw::c_char,
                                             arg3:
                                                 *mut callFunctionItemWithArg,
                                             arg4: *mut bool)
     -> *mut CallFunctionItemWithArg;
}
extern "C" {
    pub fn DeallocateCallListWithArg(arg1: *mut Environment,
                                     arg2: *mut callFunctionItemWithArg);
}
extern "C" {
    pub fn GetVoidFunctionFromCallList(arg1: *mut Environment,
                                       arg2: *const ::std::os::raw::c_char,
                                       arg3: *mut VoidCallFunctionItem)
     -> *mut VoidCallFunctionItem;
}
extern "C" {
    pub fn GetBoolFunctionFromCallList(arg1: *mut Environment,
                                       arg2: *const ::std::os::raw::c_char,
                                       arg3: *mut BoolCallFunctionItem)
     -> *mut BoolCallFunctionItem;
}
extern "C" {
    pub fn ItemHashValue(arg1: *mut Environment,
                         arg2: ::std::os::raw::c_ushort,
                         arg3: *mut ::std::os::raw::c_void, arg4: usize)
     -> usize;
}
extern "C" {
    pub fn YieldTime(arg1: *mut Environment);
}
extern "C" {
    pub fn EnablePeriodicFunctions(arg1: *mut Environment, arg2: bool)
     -> bool;
}
extern "C" {
    pub fn EnableYieldFunction(arg1: *mut Environment, arg2: bool) -> bool;
}
extern "C" {
    pub fn AddTrackedMemory(arg1: *mut Environment,
                            arg2: *mut ::std::os::raw::c_void, arg3: usize)
     -> *mut trackedMemory;
}
extern "C" {
    pub fn RemoveTrackedMemory(arg1: *mut Environment,
                               arg2: *mut trackedMemory);
}
extern "C" {
    pub fn UTF8Increment(arg1: *const ::std::os::raw::c_char,
                         arg2: *mut usize);
}
extern "C" {
    pub fn UTF8Offset(arg1: *const ::std::os::raw::c_char, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn UTF8Length(arg1: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn UTF8CharNum(arg1: *const ::std::os::raw::c_char, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn RestorePriorGarbageFrame(arg1: *mut Environment,
                                    arg2: *mut garbageFrame,
                                    arg3: *mut garbageFrame,
                                    arg4: *mut UDFValue);
}
extern "C" {
    pub fn CallCleanupFunctions(arg1: *mut Environment);
}
extern "C" {
    pub fn CallPeriodicTasks(arg1: *mut Environment);
}
extern "C" {
    pub fn CleanCurrentGarbageFrame(arg1: *mut Environment,
                                    arg2: *mut UDFValue);
}
extern "C" {
    pub fn GCBlockStart(arg1: *mut Environment, arg2: *mut GCBlock);
}
extern "C" {
    pub fn GCBlockEnd(arg1: *mut Environment, arg2: *mut GCBlock);
}
extern "C" {
    pub fn GCBlockEndUDF(arg1: *mut Environment, arg2: *mut GCBlock,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn CreateStringBuilder(arg1: *mut Environment, arg2: usize)
     -> *mut StringBuilder;
}
extern "C" {
    pub fn SBDispose(arg1: *mut StringBuilder);
}
extern "C" {
    pub fn SBAppend(arg1: *mut StringBuilder,
                    arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SBAppendInteger(arg1: *mut StringBuilder,
                           arg2: ::std::os::raw::c_longlong);
}
extern "C" {
    pub fn SBAppendFloat(arg1: *mut StringBuilder, arg2: f64);
}
extern "C" {
    pub fn SBAddChar(arg1: *mut StringBuilder, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SBReset(arg1: *mut StringBuilder);
}
extern "C" {
    pub fn SBCopy(arg1: *mut StringBuilder) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetPeriodicFunctionContext(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
pub type FindConstructFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char)
                              -> *mut ConstructHeader>;
pub type GetNextConstructFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: *mut ConstructHeader)
                              -> *mut ConstructHeader>;
pub type IsConstructDeletableFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ConstructHeader)
                              -> bool>;
pub type DeleteConstructFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ConstructHeader,
                                               arg2: *mut Environment)
                              -> bool>;
pub type FreeConstructFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: *mut ConstructHeader)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defmoduleData {
    pub LastModuleItem: *mut moduleItem,
    pub AfterModuleChangeFunctions: *mut voidCallFunctionItem,
    pub ModuleStack: *mut ModuleStackItem,
    pub CallModuleChangeFunctions: bool,
    pub ListOfDefmodules: *mut Defmodule,
    pub CurrentModule: *mut Defmodule,
    pub LastDefmodule: *mut Defmodule,
    pub NumberOfModuleItems: ::std::os::raw::c_uint,
    pub ListOfModuleItems: *mut moduleItem,
    pub ModuleChangeIndex: ::std::os::raw::c_long,
    pub MainModuleRedefinable: bool,
    pub ListOfPortConstructItems: *mut portConstructItem,
    pub NumberOfDefmodules: ::std::os::raw::c_ushort,
    pub AfterModuleDefinedFunctions: *mut voidCallFunctionItem,
    pub DefmoduleCodeItem: *mut CodeGeneratorItem,
    pub BNumberOfDefmodules: ::std::os::raw::c_ulong,
    pub NumberOfPortItems: ::std::os::raw::c_ulong,
    pub PortItemArray: *mut portItem,
    pub DefmoduleArray: *mut Defmodule,
}
#[test]
fn bindgen_test_layout_defmoduleData() {
    assert_eq!(::std::mem::size_of::<defmoduleData>() , 152usize , concat ! (
               "Size of: " , stringify ! ( defmoduleData ) ));
    assert_eq! (::std::mem::align_of::<defmoduleData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defmoduleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . LastModuleItem as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( LastModuleItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) .
                AfterModuleChangeFunctions as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( AfterModuleChangeFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . ModuleStack as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( ModuleStack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) .
                CallModuleChangeFunctions as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( CallModuleChangeFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . ListOfDefmodules as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( ListOfDefmodules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . CurrentModule as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( CurrentModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . LastDefmodule as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( LastDefmodule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . NumberOfModuleItems
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( NumberOfModuleItems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . ListOfModuleItems as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( ListOfModuleItems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . ModuleChangeIndex as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( ModuleChangeIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . MainModuleRedefinable
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( MainModuleRedefinable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) .
                ListOfPortConstructItems as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( ListOfPortConstructItems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . NumberOfDefmodules as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( NumberOfDefmodules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) .
                AfterModuleDefinedFunctions as * const _ as usize } , 104usize
                , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( AfterModuleDefinedFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . DefmoduleCodeItem as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( DefmoduleCodeItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . BNumberOfDefmodules
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( BNumberOfDefmodules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . NumberOfPortItems as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( NumberOfPortItems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . PortItemArray as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( PortItemArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmoduleData ) ) . DefmoduleArray as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( defmoduleData ) , "::"
                , stringify ! ( DefmoduleArray ) ));
}
impl Clone for defmoduleData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeDefmodules(arg1: *mut Environment);
}
extern "C" {
    pub fn FindDefmodule(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char)
     -> *mut Defmodule;
}
extern "C" {
    pub fn DefmoduleName(arg1: *mut Defmodule)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefmodulePPForm(arg1: *mut Defmodule)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetNextDefmodule(arg1: *mut Environment, arg2: *mut Defmodule)
     -> *mut Defmodule;
}
extern "C" {
    pub fn RemoveAllDefmodules(arg1: *mut Environment,
                               arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn AllocateModuleStorage() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RegisterModuleItem(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: AllocateModuleFunction,
                              arg4: FreeModuleFunction,
                              arg5:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut Environment,
                                                                             arg2:
                                                                                 ::std::os::raw::c_ulong)
                                                            ->
                                                                *mut ::std::os::raw::c_void>,
                              arg6:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut Environment,
                                                                             arg2:
                                                                                 *mut FILE,
                                                                             arg3:
                                                                                 ::std::os::raw::c_ulong,
                                                                             arg4:
                                                                                 ::std::os::raw::c_uint,
                                                                             arg5:
                                                                                 ::std::os::raw::c_uint)>,
                              arg7: FindConstructFunction)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn GetModuleItem(arg1: *mut Environment, arg2: *mut Defmodule,
                         arg3: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SetModuleItem(arg1: *mut Environment, arg2: *mut Defmodule,
                         arg3: ::std::os::raw::c_uint,
                         arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn GetCurrentModule(arg1: *mut Environment) -> *mut Defmodule;
}
extern "C" {
    pub fn SetCurrentModule(arg1: *mut Environment, arg2: *mut Defmodule)
     -> *mut Defmodule;
}
extern "C" {
    pub fn GetCurrentModuleCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetCurrentModuleCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetNumberOfModuleItems(arg1: *mut Environment)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn CreateMainModule(arg1: *mut Environment,
                            arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SetListOfDefmodules(arg1: *mut Environment, arg2: *mut Defmodule);
}
extern "C" {
    pub fn GetListOfModuleItems(arg1: *mut Environment) -> *mut moduleItem;
}
extern "C" {
    pub fn FindModuleItem(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char)
     -> *mut moduleItem;
}
extern "C" {
    pub fn SaveCurrentModule(arg1: *mut Environment);
}
extern "C" {
    pub fn RestoreCurrentModule(arg1: *mut Environment);
}
extern "C" {
    pub fn AddAfterModuleChangeFunction(arg1: *mut Environment,
                                        arg2: *const ::std::os::raw::c_char,
                                        arg3: VoidCallFunction,
                                        arg4: ::std::os::raw::c_int,
                                        arg5: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn IllegalModuleSpecifierMessage(arg1: *mut Environment);
}
extern "C" {
    pub fn AllocateDefmoduleGlobals(arg1: *mut Environment);
}
extern "C" {
    pub fn GetNumberOfDefmodules(arg1: *mut Environment)
     -> ::std::os::raw::c_ushort;
}
pub type SaveCallFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: *mut Defmodule,
                                               arg3:
                                                   *const ::std::os::raw::c_char,
                                               arg4:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct saveCallFunctionItem {
    pub name: *const ::std::os::raw::c_char,
    pub func: SaveCallFunction,
    pub priority: ::std::os::raw::c_int,
    pub next: *mut SaveCallFunctionItem,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_saveCallFunctionItem() {
    assert_eq!(::std::mem::size_of::<saveCallFunctionItem>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( saveCallFunctionItem )
               ));
    assert_eq! (::std::mem::align_of::<saveCallFunctionItem>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( saveCallFunctionItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const saveCallFunctionItem ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( saveCallFunctionItem )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const saveCallFunctionItem ) ) . func as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( saveCallFunctionItem )
                , "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const saveCallFunctionItem ) ) . priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( saveCallFunctionItem )
                , "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const saveCallFunctionItem ) ) . next as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( saveCallFunctionItem )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const saveCallFunctionItem ) ) . context as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( saveCallFunctionItem )
                , "::" , stringify ! ( context ) ));
}
impl Clone for saveCallFunctionItem {
    fn clone(&self) -> Self { *self }
}
pub type SaveCallFunctionItem = saveCallFunctionItem;
pub type ParserErrorFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3:
                                                   *const ::std::os::raw::c_char,
                                               arg4:
                                                   *const ::std::os::raw::c_char,
                                               arg5: ::std::os::raw::c_long,
                                               arg6:
                                                   *mut ::std::os::raw::c_void)>;
pub type BeforeResetFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment)
                              -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct constructData {
    pub ClearReadyInProgress: bool,
    pub ClearInProgress: bool,
    pub ResetReadyInProgress: bool,
    pub ResetInProgress: bool,
    pub ClearReadyLocks: ::std::os::raw::c_short,
    pub DanglingConstructs: ::std::os::raw::c_int,
    pub ListOfSaveFunctions: *mut SaveCallFunctionItem,
    pub PrintWhileLoading: bool,
    pub LoadInProgress: bool,
    pub WatchCompilations: bool,
    pub CheckSyntaxMode: bool,
    pub ParsingConstruct: bool,
    pub ErrorString: *mut ::std::os::raw::c_char,
    pub WarningString: *mut ::std::os::raw::c_char,
    pub ParsingFileName: *mut ::std::os::raw::c_char,
    pub ErrorFileName: *mut ::std::os::raw::c_char,
    pub WarningFileName: *mut ::std::os::raw::c_char,
    pub ErrLineNumber: ::std::os::raw::c_long,
    pub WrnLineNumber: ::std::os::raw::c_long,
    pub errorCaptureRouterCount: ::std::os::raw::c_int,
    pub MaxErrChars: usize,
    pub CurErrPos: usize,
    pub MaxWrnChars: usize,
    pub CurWrnPos: usize,
    pub ParserErrorCallback: ParserErrorFunction,
    pub ParserErrorContext: *mut ::std::os::raw::c_void,
    pub ListOfConstructs: *mut Construct,
    pub ListOfResetFunctions: *mut voidCallFunctionItem,
    pub ListOfClearFunctions: *mut voidCallFunctionItem,
    pub ListOfClearReadyFunctions: *mut boolCallFunctionItem,
    pub Executing: bool,
    pub BeforeResetCallback: BeforeResetFunction,
}
#[test]
fn bindgen_test_layout_constructData() {
    assert_eq!(::std::mem::size_of::<constructData>() , 192usize , concat ! (
               "Size of: " , stringify ! ( constructData ) ));
    assert_eq! (::std::mem::align_of::<constructData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( constructData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ClearReadyInProgress
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ClearReadyInProgress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ClearInProgress as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ClearInProgress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ResetReadyInProgress
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ResetReadyInProgress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ResetInProgress as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ResetInProgress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ClearReadyLocks as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ClearReadyLocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . DanglingConstructs as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( DanglingConstructs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ListOfSaveFunctions
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ListOfSaveFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . PrintWhileLoading as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( PrintWhileLoading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . LoadInProgress as *
                const _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( LoadInProgress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . WatchCompilations as
                * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( WatchCompilations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . CheckSyntaxMode as *
                const _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( CheckSyntaxMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ParsingConstruct as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ParsingConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ErrorString as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ErrorString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . WarningString as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( WarningString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ParsingFileName as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ParsingFileName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ErrorFileName as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ErrorFileName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . WarningFileName as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( WarningFileName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ErrLineNumber as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ErrLineNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . WrnLineNumber as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( WrnLineNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) .
                errorCaptureRouterCount as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( errorCaptureRouterCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . MaxErrChars as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( MaxErrChars ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . CurErrPos as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( CurErrPos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . MaxWrnChars as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( MaxWrnChars ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . CurWrnPos as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( CurWrnPos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ParserErrorCallback
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ParserErrorCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ParserErrorContext as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ParserErrorContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ListOfConstructs as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ListOfConstructs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ListOfResetFunctions
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ListOfResetFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . ListOfClearFunctions
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ListOfClearFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) .
                ListOfClearReadyFunctions as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( ListOfClearReadyFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . Executing as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( Executing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructData ) ) . BeforeResetCallback
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( constructData ) , "::"
                , stringify ! ( BeforeResetCallback ) ));
}
impl Clone for constructData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn Clear(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn Reset(arg1: *mut Environment);
}
extern "C" {
    pub fn Save(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn InitializeConstructData(arg1: *mut Environment);
}
extern "C" {
    pub fn AddResetFunction(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: VoidCallFunction,
                            arg4: ::std::os::raw::c_int,
                            arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn RemoveResetFunction(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn AddClearReadyFunction(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: BoolCallFunction,
                                 arg4: ::std::os::raw::c_int,
                                 arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn RemoveClearReadyFunction(arg1: *mut Environment,
                                    arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn AddClearFunction(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: VoidCallFunction,
                            arg4: ::std::os::raw::c_int,
                            arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn RemoveClearFunction(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn IncrementClearReadyLocks(arg1: *mut Environment);
}
extern "C" {
    pub fn DecrementClearReadyLocks(arg1: *mut Environment);
}
extern "C" {
    pub fn AddConstruct(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *const ::std::os::raw::c_char,
                        arg4:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut Environment,
                                                                       arg2:
                                                                           *const ::std::os::raw::c_char)
                                                      -> bool>,
                        arg5: FindConstructFunction,
                        arg6:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ConstructHeader)
                                                      -> *mut CLIPSLexeme>,
                        arg7:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ConstructHeader)
                                                      ->
                                                          *const ::std::os::raw::c_char>,
                        arg8:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ConstructHeader)
                                                      ->
                                                          *mut defmoduleItemHeader>,
                        arg9: GetNextConstructFunction,
                        arg10:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ConstructHeader,
                                                                       arg2:
                                                                           *mut ConstructHeader)>,
                        arg11: IsConstructDeletableFunction,
                        arg12: DeleteConstructFunction,
                        arg13: FreeConstructFunction) -> *mut Construct;
}
extern "C" {
    pub fn RemoveConstruct(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn SetCompilationsWatch(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn GetCompilationsWatch(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetPrintWhileLoading(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn GetPrintWhileLoading(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetLoadInProgress(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn GetLoadInProgress(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn ExecutingConstruct(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetExecutingConstruct(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn InitializeConstructs(arg1: *mut Environment);
}
extern "C" {
    pub fn SetBeforeResetFunction(arg1: *mut Environment,
                                  arg2: BeforeResetFunction)
     -> BeforeResetFunction;
}
extern "C" {
    pub fn ResetCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClearCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClearReady(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn FindConstruct(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char)
     -> *mut Construct;
}
extern "C" {
    pub fn DeinstallConstructHeader(arg1: *mut Environment,
                                    arg2: *mut ConstructHeader);
}
extern "C" {
    pub fn DestroyConstructHeader(arg1: *mut Environment,
                                  arg2: *mut ConstructHeader);
}
extern "C" {
    pub fn SetParserErrorCallback(arg1: *mut Environment,
                                  arg2: ParserErrorFunction,
                                  arg3: *mut ::std::os::raw::c_void)
     -> ParserErrorFunction;
}
extern "C" {
    pub fn AddSaveFunction(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: SaveCallFunction,
                           arg4: ::std::os::raw::c_int,
                           arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn RemoveSaveFunction(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn AddSaveFunctionToCallList(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: ::std::os::raw::c_int,
                                     arg4: SaveCallFunction,
                                     arg5: *mut SaveCallFunctionItem,
                                     arg6: *mut ::std::os::raw::c_void)
     -> *mut SaveCallFunctionItem;
}
extern "C" {
    pub fn RemoveSaveFunctionFromCallList(arg1: *mut Environment,
                                          arg2: *const ::std::os::raw::c_char,
                                          arg3: *mut SaveCallFunctionItem,
                                          arg4: *mut bool)
     -> *mut SaveCallFunctionItem;
}
extern "C" {
    pub fn DeallocateSaveCallList(arg1: *mut Environment,
                                  arg2: *mut SaveCallFunctionItem);
}
pub type EXPRESSION_HN = exprHashNode;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct expressionData {
    pub PTR_AND: *mut FunctionDefinition,
    pub PTR_OR: *mut FunctionDefinition,
    pub PTR_EQ: *mut FunctionDefinition,
    pub PTR_NEQ: *mut FunctionDefinition,
    pub PTR_NOT: *mut FunctionDefinition,
    pub ExpressionHashTable: *mut *mut EXPRESSION_HN,
    pub NumberOfExpressions: ::std::os::raw::c_ulong,
    pub ExpressionArray: *mut Expression,
    pub ExpressionCount: ::std::os::raw::c_ulong,
    pub svContexts: *mut SavedContexts,
    pub ReturnContext: bool,
    pub BreakContext: bool,
    pub SequenceOpMode: bool,
}
#[test]
fn bindgen_test_layout_expressionData() {
    assert_eq!(::std::mem::size_of::<expressionData>() , 88usize , concat ! (
               "Size of: " , stringify ! ( expressionData ) ));
    assert_eq! (::std::mem::align_of::<expressionData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( expressionData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . PTR_AND as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( PTR_AND ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . PTR_OR as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( PTR_OR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . PTR_EQ as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( PTR_EQ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . PTR_NEQ as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( PTR_NEQ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . PTR_NOT as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( PTR_NOT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . ExpressionHashTable
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( ExpressionHashTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . NumberOfExpressions
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( NumberOfExpressions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . ExpressionArray as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( ExpressionArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . ExpressionCount as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( ExpressionCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . svContexts as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( svContexts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . ReturnContext as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( ReturnContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . BreakContext as *
                const _ as usize } , 81usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( BreakContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const expressionData ) ) . SequenceOpMode as *
                const _ as usize } , 82usize , concat ! (
                "Alignment of field: " , stringify ! ( expressionData ) , "::"
                , stringify ! ( SequenceOpMode ) ));
}
impl Clone for expressionData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    
    pub fn ReturnExpression(arg1: *mut Environment, arg2: *mut Expression);
}
extern "C" {
    pub fn ExpressionInstall(arg1: *mut Environment, arg2: *mut Expression);
}
extern "C" {
    pub fn ExpressionDeinstall(arg1: *mut Environment, arg2: *mut Expression);
}
extern "C" {
    pub fn PackExpression(arg1: *mut Environment, arg2: *mut Expression)
     -> *mut Expression;
}
extern "C" {
    pub fn ReturnPackedExpression(arg1: *mut Environment,
                                  arg2: *mut Expression);
}
extern "C" {
    pub fn InitExpressionData(arg1: *mut Environment);
}
extern "C" {
    pub fn InitExpressionPointers(arg1: *mut Environment);
}
extern "C" {
    pub fn SetSequenceOperatorRecognition(arg1: *mut Environment, arg2: bool)
     -> bool;
}
extern "C" {
    pub fn GetSequenceOperatorRecognition(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn AddHashedExpression(arg1: *mut Environment, arg2: *mut Expression)
     -> *mut Expression;
}
extern "C" {
    pub fn RemoveHashedExpression(arg1: *mut Environment,
                                  arg2: *mut Expression);
}
extern "C" {
    pub fn HashedExpressionIndex(arg1: *mut Environment,
                                 arg2: *mut Expression)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn GetLogicalName(arg1: *mut UDFContext,
                          arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetFileName(arg1: *mut UDFContext)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetConstructName(arg1: *mut UDFContext,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ExpectedCountError(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: ::std::os::raw::c_int,
                              arg4: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn OpenErrorMessage(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn CheckFunctionArgCount(arg1: *mut Environment,
                                 arg2: *mut functionDefinition,
                                 arg3: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn ExpectedTypeError0(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn ExpectedTypeError1(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: ::std::os::raw::c_uint,
                              arg4: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ExpectedTypeError2(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn GetModuleName(arg1: *mut UDFContext, arg2: ::std::os::raw::c_uint,
                         arg3: *mut bool) -> *mut Defmodule;
}
extern "C" {
    pub fn GetFactOrInstanceArgument(arg1: *mut UDFContext,
                                     arg2: ::std::os::raw::c_uint,
                                     arg3: *mut UDFValue)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn IllegalLogicalNameMessage(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct memoryPtr {
    pub next: *mut memoryPtr,
}
#[test]
fn bindgen_test_layout_memoryPtr() {
    assert_eq!(::std::mem::size_of::<memoryPtr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( memoryPtr ) ));
    assert_eq! (::std::mem::align_of::<memoryPtr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( memoryPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memoryPtr ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memoryPtr ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for memoryPtr {
    fn clone(&self) -> Self { *self }
}
pub type OutOfMemoryFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: usize) -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct memoryData {
    pub MemoryAmount: ::std::os::raw::c_longlong,
    pub MemoryCalls: ::std::os::raw::c_longlong,
    pub ConserveMemory: bool,
    pub OutOfMemoryCallback: OutOfMemoryFunction,
    pub TempMemoryPtr: *mut memoryPtr,
    pub MemoryTable: *mut *mut memoryPtr,
    pub TempSize: usize,
}
#[test]
fn bindgen_test_layout_memoryData() {
    assert_eq!(::std::mem::size_of::<memoryData>() , 56usize , concat ! (
               "Size of: " , stringify ! ( memoryData ) ));
    assert_eq! (::std::mem::align_of::<memoryData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( memoryData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memoryData ) ) . MemoryAmount as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memoryData ) , "::" ,
                stringify ! ( MemoryAmount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memoryData ) ) . MemoryCalls as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( memoryData ) , "::" ,
                stringify ! ( MemoryCalls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memoryData ) ) . ConserveMemory as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( memoryData ) , "::" ,
                stringify ! ( ConserveMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memoryData ) ) . OutOfMemoryCallback as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( memoryData ) , "::" ,
                stringify ! ( OutOfMemoryCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memoryData ) ) . TempMemoryPtr as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( memoryData ) , "::" ,
                stringify ! ( TempMemoryPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memoryData ) ) . MemoryTable as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( memoryData ) , "::" ,
                stringify ! ( MemoryTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memoryData ) ) . TempSize as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( memoryData ) , "::" ,
                stringify ! ( TempSize ) ));
}
impl Clone for memoryData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeMemory(arg1: *mut Environment);
}
extern "C" {
    pub fn genalloc(arg1: *mut Environment, arg2: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DefaultOutOfMemoryFunction(arg1: *mut Environment, arg2: usize)
     -> bool;
}
extern "C" {
    pub fn SetOutOfMemoryFunction(arg1: *mut Environment,
                                  arg2: OutOfMemoryFunction)
     -> OutOfMemoryFunction;
}
extern "C" {
    pub fn genfree(arg1: *mut Environment, arg2: *mut ::std::os::raw::c_void,
                   arg3: usize);
}
extern "C" {
    pub fn genrealloc(arg1: *mut Environment,
                      arg2: *mut ::std::os::raw::c_void, arg3: usize,
                      arg4: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemUsed(arg1: *mut Environment) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn MemRequests(arg1: *mut Environment) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn UpdateMemoryUsed(arg1: *mut Environment,
                            arg2: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn UpdateMemoryRequests(arg1: *mut Environment,
                                arg2: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn ReleaseMem(arg1: *mut Environment,
                      arg2: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn gm1(arg1: *mut Environment, arg2: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gm2(arg1: *mut Environment, arg2: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rm(arg1: *mut Environment, arg2: *mut ::std::os::raw::c_void,
              arg3: usize);
}
extern "C" {
    pub fn PoolSize(arg1: *mut Environment) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ActualPoolSize(arg1: *mut Environment) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SetConserveMemory(arg1: *mut Environment, arg2: bool) -> bool;
}
extern "C" {
    pub fn GetConserveMemory(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn genmemcpy(arg1: *mut ::std::os::raw::c_char,
                     arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_ulong);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EvalError {
    EE_NO_ERROR = 0,
    EE_PARSING_ERROR = 1,
    EE_PROCESSING_ERROR = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BuildError {
    BE_NO_ERROR = 0,
    BE_COULD_NOT_BUILD_ERROR = 1,
    BE_CONSTRUCT_NOT_FOUND_ERROR = 2,
    BE_PARSING_ERROR = 3,
}
extern "C" {
    pub fn Build(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char)
     -> BuildError;
}
extern "C" {
    pub fn Eval(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char,
                arg3: *mut CLIPSValue) -> EvalError;
}
extern "C" {
    pub fn StringFunctionDefinitions(arg1: *mut Environment);
}
extern "C" {
    pub fn StrCatFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn SymCatFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn StrLengthFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn UpcaseFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn LowcaseFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn StrCompareFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn SubStringFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn StrIndexFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn EvalFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn BuildFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn StringToFieldFunction(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn StringToField(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: *mut UDFValue);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LoadError {
    LE_NO_ERROR = 0,
    LE_OPEN_FILE_ERROR = 1,
    LE_PARSING_ERROR = 2,
}
extern "C" {
    pub fn Load(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char)
     -> LoadError;
}
extern "C" {
    pub fn LoadConstructsFromLogicalName(arg1: *mut Environment,
                                         arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn LoadFromString(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> bool;
}
extern "C" {
    pub fn ParseConstruct(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *const ::std::os::raw::c_char) -> BuildError;
}
extern "C" {
    pub fn ImportExportConflictMessage(arg1: *mut Environment,
                                       arg2: *const ::std::os::raw::c_char,
                                       arg3: *const ::std::os::raw::c_char,
                                       arg4: *const ::std::os::raw::c_char,
                                       arg5: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn FlushParsingMessages(arg1: *mut Environment);
}
extern "C" {
    pub fn GetParsingFileName(arg1: *mut Environment)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SetParsingFileName(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn GetErrorFileName(arg1: *mut Environment)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SetErrorFileName(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn GetWarningFileName(arg1: *mut Environment)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SetWarningFileName(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn CreateErrorCaptureRouter(arg1: *mut Environment);
}
extern "C" {
    pub fn DeleteErrorCaptureRouter(arg1: *mut Environment);
}
extern "C" {
    pub fn DribbleOn(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn DribbleActive(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn DribbleOff(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn AppendDribble(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn LLGetcBatch(arg1: *mut Environment,
                       arg2: *const ::std::os::raw::c_char, arg3: bool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Batch(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn OpenBatch(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char, arg3: bool) -> bool;
}
extern "C" {
    pub fn OpenStringBatch(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char, arg4: bool)
     -> bool;
}
extern "C" {
    pub fn RemoveBatch(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn BatchActive(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn CloseAllBatchSources(arg1: *mut Environment);
}
extern "C" {
    pub fn BatchStar(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char) -> bool;
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct genericHashNode {
    pub header: TypeHeader,
    pub next: *mut genericHashNode,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_genericHashNode() {
    assert_eq!(::std::mem::size_of::<genericHashNode>() , 32usize , concat ! (
               "Size of: " , stringify ! ( genericHashNode ) ));
    assert_eq! (::std::mem::align_of::<genericHashNode>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( genericHashNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const genericHashNode ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( genericHashNode ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const genericHashNode ) ) . next as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( genericHashNode ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const genericHashNode ) ) . count as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( genericHashNode ) ,
                "::" , stringify ! ( count ) ));
}
impl Clone for genericHashNode {
    fn clone(&self) -> Self { *self }
}
impl genericHashNode {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn needed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_needed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967288u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(permanent: ::std::os::raw::c_uint,
                          markedEphemeral: ::std::os::raw::c_uint,
                          needed: ::std::os::raw::c_uint,
                          bucket: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((permanent as u32 as u32) << 0usize) &
                                (1u64 as u32))
                   } |
                       ((markedEphemeral as u32 as u32) << 1usize) &
                           (2u64 as u32))
              } | ((needed as u32 as u32) << 2usize) & (4u64 as u32))
         } | ((bucket as u32 as u32) << 3usize) & (4294967288u64 as u32))
    }
}
pub type GENERIC_HN = genericHashNode;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct ephemeron {
    pub associatedValue: *mut GENERIC_HN,
    pub next: *mut ephemeron,
}
#[test]
fn bindgen_test_layout_ephemeron() {
    assert_eq!(::std::mem::size_of::<ephemeron>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ephemeron ) ));
    assert_eq! (::std::mem::align_of::<ephemeron>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ephemeron ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ephemeron ) ) . associatedValue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ephemeron ) , "::" ,
                stringify ! ( associatedValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ephemeron ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ephemeron ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for ephemeron {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct symbolMatch {
    pub match_: *mut CLIPSLexeme,
    pub next: *mut symbolMatch,
}
#[test]
fn bindgen_test_layout_symbolMatch() {
    assert_eq!(::std::mem::size_of::<symbolMatch>() , 16usize , concat ! (
               "Size of: " , stringify ! ( symbolMatch ) ));
    assert_eq! (::std::mem::align_of::<symbolMatch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symbolMatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolMatch ) ) . match_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolMatch ) , "::" ,
                stringify ! ( match_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolMatch ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolMatch ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for symbolMatch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct symbolData {
    pub PositiveInfinity: *mut CLIPSLexeme,
    pub NegativeInfinity: *mut CLIPSLexeme,
    pub Zero: *mut CLIPSInteger,
    pub SymbolTable: *mut *mut CLIPSLexeme,
    pub FloatTable: *mut *mut CLIPSFloat,
    pub IntegerTable: *mut *mut CLIPSInteger,
    pub BitMapTable: *mut *mut CLIPSBitMap,
    pub ExternalAddressTable: *mut *mut CLIPSExternalAddress,
    pub NumberOfSymbols: ::std::os::raw::c_ulong,
    pub NumberOfFloats: ::std::os::raw::c_ulong,
    pub NumberOfIntegers: ::std::os::raw::c_ulong,
    pub NumberOfBitMaps: ::std::os::raw::c_ulong,
    pub NumberOfExternalAddresses: ::std::os::raw::c_ulong,
    pub SymbolArray: *mut *mut CLIPSLexeme,
    pub FloatArray: *mut *mut CLIPSFloat,
    pub IntegerArray: *mut *mut CLIPSInteger,
    pub BitMapArray: *mut *mut CLIPSBitMap,
    pub ExternalAddressArray: *mut *mut CLIPSExternalAddress,
}
#[test]
fn bindgen_test_layout_symbolData() {
    assert_eq!(::std::mem::size_of::<symbolData>() , 144usize , concat ! (
               "Size of: " , stringify ! ( symbolData ) ));
    assert_eq! (::std::mem::align_of::<symbolData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( symbolData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . PositiveInfinity as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( PositiveInfinity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . NegativeInfinity as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( NegativeInfinity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . Zero as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( Zero ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . SymbolTable as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( SymbolTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . FloatTable as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( FloatTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . IntegerTable as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( IntegerTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . BitMapTable as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( BitMapTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . ExternalAddressTable as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( ExternalAddressTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . NumberOfSymbols as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( NumberOfSymbols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . NumberOfFloats as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( NumberOfFloats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . NumberOfIntegers as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( NumberOfIntegers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . NumberOfBitMaps as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( NumberOfBitMaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) .
                NumberOfExternalAddresses as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( NumberOfExternalAddresses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . SymbolArray as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( SymbolArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . FloatArray as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( FloatArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . IntegerArray as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( IntegerArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . BitMapArray as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( BitMapArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const symbolData ) ) . ExternalAddressArray as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( symbolData ) , "::" ,
                stringify ! ( ExternalAddressArray ) ));
}
impl Clone for symbolData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeAtomTables(arg1: *mut Environment,
                                arg2: *mut *mut CLIPSLexeme,
                                arg3: *mut *mut CLIPSFloat,
                                arg4: *mut *mut CLIPSInteger,
                                arg5: *mut *mut CLIPSBitMap,
                                arg6: *mut *mut CLIPSExternalAddress);
}
extern "C" {
    pub fn AddSymbol(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_ushort) -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn FindSymbolHN(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_ushort) -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn CreateFloat(arg1: *mut Environment, arg2: f64) -> *mut CLIPSFloat;
}
extern "C" {
    pub fn CreateInteger(arg1: *mut Environment,
                         arg2: ::std::os::raw::c_longlong)
     -> *mut CLIPSInteger;
}
extern "C" {
    pub fn AddBitMap(arg1: *mut Environment,
                     arg2: *mut ::std::os::raw::c_void,
                     arg3: ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CreateExternalAddress(arg1: *mut Environment,
                                 arg2: *mut ::std::os::raw::c_void,
                                 arg3: ::std::os::raw::c_ushort)
     -> *mut CLIPSExternalAddress;
}
extern "C" {
    pub fn CreateCExternalAddress(arg1: *mut Environment,
                                  arg2: *mut ::std::os::raw::c_void)
     -> *mut CLIPSExternalAddress;
}
extern "C" {
    pub fn FindLongHN(arg1: *mut Environment,
                      arg2: ::std::os::raw::c_longlong) -> *mut CLIPSInteger;
}
extern "C" {
    pub fn HashSymbol(arg1: *const ::std::os::raw::c_char, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn HashFloat(arg1: f64, arg2: usize) -> usize;
}
extern "C" {
    pub fn HashInteger(arg1: ::std::os::raw::c_longlong, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn HashBitMap(arg1: *const ::std::os::raw::c_char, arg2: usize,
                      arg3: ::std::os::raw::c_uint) -> usize;
}
extern "C" {
    pub fn HashExternalAddress(arg1: *mut ::std::os::raw::c_void, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn RetainLexeme(arg1: *mut Environment, arg2: *mut CLIPSLexeme);
}
extern "C" {
    pub fn RetainFloat(arg1: *mut Environment, arg2: *mut CLIPSFloat);
}
extern "C" {
    pub fn RetainInteger(arg1: *mut Environment, arg2: *mut CLIPSInteger);
}
extern "C" {
    pub fn IncrementBitMapReferenceCount(arg1: *mut Environment,
                                         arg2: *mut CLIPSBitMap);
}
extern "C" {
    pub fn RetainExternalAddress(arg1: *mut Environment,
                                 arg2: *mut CLIPSExternalAddress);
}
extern "C" {
    pub fn ReleaseLexeme(arg1: *mut Environment, arg2: *mut CLIPSLexeme);
}
extern "C" {
    pub fn ReleaseFloat(arg1: *mut Environment, arg2: *mut CLIPSFloat);
}
extern "C" {
    pub fn ReleaseInteger(arg1: *mut Environment, arg2: *mut CLIPSInteger);
}
extern "C" {
    pub fn DecrementBitMapReferenceCount(arg1: *mut Environment,
                                         arg2: *mut CLIPSBitMap);
}
extern "C" {
    pub fn ReleaseExternalAddress(arg1: *mut Environment,
                                  arg2: *mut CLIPSExternalAddress);
}
extern "C" {
    pub fn RemoveEphemeralAtoms(arg1: *mut Environment);
}
extern "C" {
    pub fn GetSymbolTable(arg1: *mut Environment) -> *mut *mut CLIPSLexeme;
}
extern "C" {
    pub fn SetSymbolTable(arg1: *mut Environment,
                          arg2: *mut *mut CLIPSLexeme);
}
extern "C" {
    pub fn GetFloatTable(arg1: *mut Environment) -> *mut *mut CLIPSFloat;
}
extern "C" {
    pub fn SetFloatTable(arg1: *mut Environment, arg2: *mut *mut CLIPSFloat);
}
extern "C" {
    pub fn GetIntegerTable(arg1: *mut Environment) -> *mut *mut CLIPSInteger;
}
extern "C" {
    pub fn SetIntegerTable(arg1: *mut Environment,
                           arg2: *mut *mut CLIPSInteger);
}
extern "C" {
    pub fn GetBitMapTable(arg1: *mut Environment) -> *mut *mut CLIPSBitMap;
}
extern "C" {
    pub fn SetBitMapTable(arg1: *mut Environment,
                          arg2: *mut *mut CLIPSBitMap);
}
extern "C" {
    pub fn GetExternalAddressTable(arg1: *mut Environment)
     -> *mut *mut CLIPSExternalAddress;
}
extern "C" {
    pub fn SetExternalAddressTable(arg1: *mut Environment,
                                   arg2: *mut *mut CLIPSExternalAddress);
}
extern "C" {
    pub fn RefreshSpecialSymbols(arg1: *mut Environment);
}
extern "C" {
    pub fn FindSymbolMatches(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut ::std::os::raw::c_uint,
                             arg4: *mut usize) -> *mut symbolMatch;
}
extern "C" {
    pub fn ReturnSymbolMatches(arg1: *mut Environment,
                               arg2: *mut symbolMatch);
}
extern "C" {
    pub fn GetNextSymbolMatch(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: usize, arg4: *mut CLIPSLexeme, arg5: bool,
                              arg6: *mut usize) -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn ClearBitString(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn SetAtomicValueIndices(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn RestoreAtomicValueBuckets(arg1: *mut Environment);
}
extern "C" {
    pub fn EphemerateValue(arg1: *mut Environment,
                           arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn CreateSymbol(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn CreateString(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn CreateInstanceName(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn CreateBoolean(arg1: *mut Environment, arg2: bool)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn BitStringHasBitsSet(arg1: *mut ::std::os::raw::c_void,
                               arg2: ::std::os::raw::c_uint) -> bool;
}
pub type UserDefinedFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: *mut UDFContext,
                                               arg3: *mut UDFValue)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct externalFunctionData {
    pub ListOfFunctions: *mut functionDefinition,
    pub FunctionHashtable: *mut *mut FunctionHash,
}
#[test]
fn bindgen_test_layout_externalFunctionData() {
    assert_eq!(::std::mem::size_of::<externalFunctionData>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( externalFunctionData )
               ));
    assert_eq! (::std::mem::align_of::<externalFunctionData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( externalFunctionData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const externalFunctionData ) ) .
                ListOfFunctions as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( externalFunctionData )
                , "::" , stringify ! ( ListOfFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const externalFunctionData ) ) .
                FunctionHashtable as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( externalFunctionData )
                , "::" , stringify ! ( FunctionHashtable ) ));
}
impl Clone for externalFunctionData {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AddUDFError {
    AUE_NO_ERROR = 0,
    AUE_MIN_EXCEEDS_MAX_ERROR = 1,
    AUE_FUNCTION_NAME_IN_USE_ERROR = 2,
    AUE_INVALID_ARGUMENT_TYPE_ERROR = 3,
    AUE_INVALID_RETURN_TYPE_ERROR = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FunctionHash {
    pub fdPtr: *mut functionDefinition,
    pub next: *mut FunctionHash,
}
#[test]
fn bindgen_test_layout_FunctionHash() {
    assert_eq!(::std::mem::size_of::<FunctionHash>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FunctionHash ) ));
    assert_eq! (::std::mem::align_of::<FunctionHash>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FunctionHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionHash ) ) . fdPtr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionHash ) , "::" ,
                stringify ! ( fdPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FunctionHash ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FunctionHash ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for FunctionHash {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeExternalFunctionData(arg1: *mut Environment);
}
extern "C" {
    pub fn AddUDF(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char,
                  arg3: *const ::std::os::raw::c_char,
                  arg4: ::std::os::raw::c_ushort,
                  arg5: ::std::os::raw::c_ushort,
                  arg6: *const ::std::os::raw::c_char,
                  arg7: UserDefinedFunction,
                  arg8: *const ::std::os::raw::c_char,
                  arg9: *mut ::std::os::raw::c_void) -> AddUDFError;
}
extern "C" {
    pub fn AddFunctionParser(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut Environment,
                                                                            arg2:
                                                                                *mut expr,
                                                                            arg3:
                                                                                *const ::std::os::raw::c_char)
                                                           -> *mut expr>)
     -> bool;
}
extern "C" {
    pub fn RemoveFunctionParser(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn FuncSeqOvlFlags(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char, arg3: bool,
                           arg4: bool) -> bool;
}
extern "C" {
    pub fn GetFunctionList(arg1: *mut Environment) -> *mut functionDefinition;
}
extern "C" {
    pub fn InstallFunctionList(arg1: *mut Environment,
                               arg2: *mut functionDefinition);
}
extern "C" {
    pub fn FindFunction(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char)
     -> *mut functionDefinition;
}
extern "C" {
    pub fn GetNthRestriction(arg1: *mut Environment,
                             arg2: *mut functionDefinition,
                             arg3: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn RemoveUDF(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn GetMinimumArgs(arg1: *mut functionDefinition)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetMaximumArgs(arg1: *mut functionDefinition)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UDFArgumentCount(arg1: *mut UDFContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn UDFNthArgument(arg1: *mut UDFContext, arg2: ::std::os::raw::c_uint,
                          arg3: ::std::os::raw::c_uint, arg4: *mut UDFValue)
     -> bool;
}
extern "C" {
    pub fn UDFInvalidArgumentMessage(arg1: *mut UDFContext,
                                     arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn UDFContextFunctionName(arg1: *mut UDFContext)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PrintTypesString(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: ::std::os::raw::c_uint, arg4: bool);
}
extern "C" {
    pub fn UDFFirstArgument(arg1: *mut UDFContext,
                            arg2: ::std::os::raw::c_uint, arg3: *mut UDFValue)
     -> bool;
}
extern "C" {
    pub fn UDFNextArgument(arg1: *mut UDFContext,
                           arg2: ::std::os::raw::c_uint, arg3: *mut UDFValue)
     -> bool;
}
extern "C" {
    pub fn UDFThrowError(arg1: *mut UDFContext);
}
extern "C" {
    pub fn GetUDFContext(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CreateEnvironment() -> *mut Environment;
}
extern "C" {
    pub fn CreateRuntimeEnvironment(arg1: *mut *mut CLIPSLexeme,
                                    arg2: *mut *mut CLIPSFloat,
                                    arg3: *mut *mut CLIPSInteger,
                                    arg4: *mut *mut CLIPSBitMap,
                                    arg5: *mut functionDefinition)
     -> *mut Environment;
}
extern "C" {
    pub fn DestroyEnvironment(arg1: *mut Environment) -> bool;
}
pub type AfterPromptFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment)>;
pub type BeforeCommandExecutionFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment)
                              -> bool>;
pub type EventFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct commandLineData {
    pub EvaluatingTopLevelCommand: bool,
    pub HaltCommandLoopBatch: bool,
    pub CurrentCommand: *mut expr,
    pub CommandString: *mut ::std::os::raw::c_char,
    pub MaximumCharacters: usize,
    pub ParsingTopLevelCommand: bool,
    pub BannerString: *const ::std::os::raw::c_char,
    pub EventCallback: EventFunction,
    pub AfterPromptCallback: AfterPromptFunction,
    pub BeforeCommandExecutionCallback: BeforeCommandExecutionFunction,
}
#[test]
fn bindgen_test_layout_commandLineData() {
    assert_eq!(::std::mem::size_of::<commandLineData>() , 72usize , concat ! (
               "Size of: " , stringify ! ( commandLineData ) ));
    assert_eq! (::std::mem::align_of::<commandLineData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( commandLineData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) .
                EvaluatingTopLevelCommand as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( EvaluatingTopLevelCommand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) .
                HaltCommandLoopBatch as * const _ as usize } , 1usize , concat
                ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( HaltCommandLoopBatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) . CurrentCommand as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( CurrentCommand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) . CommandString as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( CommandString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) . MaximumCharacters
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( MaximumCharacters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) .
                ParsingTopLevelCommand as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( ParsingTopLevelCommand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) . BannerString as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( BannerString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) . EventCallback as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( EventCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) . AfterPromptCallback
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( AfterPromptCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const commandLineData ) ) .
                BeforeCommandExecutionCallback as * const _ as usize } ,
                64usize , concat ! (
                "Alignment of field: " , stringify ! ( commandLineData ) ,
                "::" , stringify ! ( BeforeCommandExecutionCallback ) ));
}
impl Clone for commandLineData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeCommandLineData(arg1: *mut Environment);
}
extern "C" {
    pub fn ExpandCommandString(arg1: *mut Environment,
                               arg2: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn FlushCommandString(arg1: *mut Environment);
}
extern "C" {
    pub fn SetCommandString(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn AppendCommandString(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn InsertCommandString(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn GetCommandString(arg1: *mut Environment)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn CompleteCommand(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CommandLoop(arg1: *mut Environment);
}
extern "C" {
    pub fn CommandLoopBatch(arg1: *mut Environment);
}
extern "C" {
    pub fn CommandLoopBatchDriver(arg1: *mut Environment);
}
extern "C" {
    pub fn PrintPrompt(arg1: *mut Environment);
}
extern "C" {
    pub fn PrintBanner(arg1: *mut Environment);
}
extern "C" {
    pub fn SetAfterPromptFunction(arg1: *mut Environment,
                                  arg2: AfterPromptFunction);
}
extern "C" {
    pub fn SetBeforeCommandExecutionFunction(arg1: *mut Environment,
                                             arg2:
                                                 BeforeCommandExecutionFunction);
}
extern "C" {
    pub fn RouteCommand(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char, arg3: bool)
     -> bool;
}
extern "C" {
    pub fn SetEventFunction(arg1: *mut Environment, arg2: EventFunction)
     -> EventFunction;
}
extern "C" {
    pub fn TopLevelCommand(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn AppendNCommandString(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn SetNCommandString(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn GetCommandCompletionString(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3: usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ExecuteIfCommandComplete(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn CommandLoopOnceThenBatch(arg1: *mut Environment);
}
extern "C" {
    pub fn CommandCompleteAndNotEmpty(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetHaltCommandLoopBatch(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn GetHaltCommandLoopBatch(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn RerouteStdin(arg1: *mut Environment, arg2: ::std::os::raw::c_int,
                        arg3: *mut *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct printUtilityData {
    pub PreserveEscapedCharacters: bool,
    pub AddressesToStrings: bool,
    pub InstanceAddressesToNames: bool,
}
#[test]
fn bindgen_test_layout_printUtilityData() {
    assert_eq!(::std::mem::size_of::<printUtilityData>() , 3usize , concat ! (
               "Size of: " , stringify ! ( printUtilityData ) ));
    assert_eq! (::std::mem::align_of::<printUtilityData>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( printUtilityData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const printUtilityData ) ) .
                PreserveEscapedCharacters as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( printUtilityData ) ,
                "::" , stringify ! ( PreserveEscapedCharacters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const printUtilityData ) ) . AddressesToStrings
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( printUtilityData ) ,
                "::" , stringify ! ( AddressesToStrings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const printUtilityData ) ) .
                InstanceAddressesToNames as * const _ as usize } , 2usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( printUtilityData ) ,
                "::" , stringify ! ( InstanceAddressesToNames ) ));
}
impl Clone for printUtilityData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializePrintUtilityData(arg1: *mut Environment);
}
extern "C" {
    pub fn WriteFloat(arg1: *mut Environment,
                      arg2: *const ::std::os::raw::c_char, arg3: f64);
}
extern "C" {
    pub fn WriteInteger(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_longlong);
}
extern "C" {
    pub fn PrintUnsignedInteger(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: ::std::os::raw::c_ulonglong);
}
extern "C" {
    pub fn PrintAtom(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_ushort,
                     arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn PrintTally(arg1: *mut Environment,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_ulonglong,
                      arg4: *const ::std::os::raw::c_char,
                      arg5: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn FloatToString(arg1: *mut Environment, arg2: f64)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn LongIntegerToString(arg1: *mut Environment,
                               arg2: ::std::os::raw::c_longlong)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DataObjectToString(arg1: *mut Environment, arg2: *mut UDFValue)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SyntaxErrorMessage(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SystemError(arg1: *mut Environment,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PrintErrorID(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int, arg4: bool);
}
extern "C" {
    pub fn PrintWarningID(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_int, arg4: bool);
}
extern "C" {
    pub fn CantFindItemErrorMessage(arg1: *mut Environment,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: *const ::std::os::raw::c_char,
                                    arg4: bool);
}
extern "C" {
    pub fn CantDeleteItemErrorMessage(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn AlreadyParsedErrorMessage(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn LocalVariableErrorMessage(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn DivideByZeroErrorMessage(arg1: *mut Environment,
                                    arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SalienceInformationError(arg1: *mut Environment,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SalienceRangeError(arg1: *mut Environment,
                              arg2: ::std::os::raw::c_int,
                              arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SalienceNonIntegerError(arg1: *mut Environment);
}
extern "C" {
    pub fn CantFindItemInFunctionErrorMessage(arg1: *mut Environment,
                                              arg2:
                                                  *const ::std::os::raw::c_char,
                                              arg3:
                                                  *const ::std::os::raw::c_char,
                                              arg4:
                                                  *const ::std::os::raw::c_char,
                                              arg5: bool);
}
extern "C" {
    pub fn SlotExistError(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn FactRetractedErrorMessage(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn FactVarSlotErrorMessage1(arg1: *mut Environment, arg2: *mut Fact,
                                    arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn FactVarSlotErrorMessage2(arg1: *mut Environment, arg2: *mut Fact,
                                    arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn InvalidVarSlotErrorMessage(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn InstanceVarSlotErrorMessage1(arg1: *mut Environment,
                                        arg2: *mut Instance,
                                        arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn InstanceVarSlotErrorMessage2(arg1: *mut Environment,
                                        arg2: *mut Instance,
                                        arg3: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct router {
    pub name: *const ::std::os::raw::c_char,
    pub active: bool,
    pub priority: ::std::os::raw::c_int,
    pub context: *mut ::std::os::raw::c_void,
    pub queryCallback: RouterQueryFunction,
    pub writeCallback: RouterWriteFunction,
    pub exitCallback: RouterExitFunction,
    pub readCallback: RouterReadFunction,
    pub unreadCallback: RouterUnreadFunction,
    pub next: *mut Router,
}
#[test]
fn bindgen_test_layout_router() {
    assert_eq!(::std::mem::size_of::<router>() , 72usize , concat ! (
               "Size of: " , stringify ! ( router ) ));
    assert_eq! (::std::mem::align_of::<router>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( router ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . name as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . active as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . priority as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . context as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . queryCallback as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( queryCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . writeCallback as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( writeCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . exitCallback as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( exitCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . readCallback as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( readCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . unreadCallback as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( unreadCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const router ) ) . next as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( router ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for router {
    fn clone(&self) -> Self { *self }
}
pub type Router = router;
pub type RouterQueryFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
pub type RouterWriteFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3:
                                                   *const ::std::os::raw::c_char,
                                               arg4:
                                                   *mut ::std::os::raw::c_void)>;
pub type RouterExitFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: ::std::os::raw::c_int,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)>;
pub type RouterReadFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type RouterUnreadFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3: ::std::os::raw::c_int,
                                               arg4:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "STDOUT"]
    pub static mut STDOUT: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "STDIN"]
    pub static mut STDIN: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "STDERR"]
    pub static mut STDERR: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "STDWRN"]
    pub static mut STDWRN: *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct routerData {
    pub CommandBufferInputCount: usize,
    pub InputUngets: usize,
    pub AwaitingInput: bool,
    pub LineCountRouter: *const ::std::os::raw::c_char,
    pub FastCharGetRouter: *const ::std::os::raw::c_char,
    pub FastCharGetString: *mut ::std::os::raw::c_char,
    pub FastCharGetIndex: ::std::os::raw::c_long,
    pub ListOfRouters: *mut router,
    pub FastLoadFilePtr: *mut FILE,
    pub FastSaveFilePtr: *mut FILE,
    pub Abort: bool,
}
#[test]
fn bindgen_test_layout_routerData() {
    assert_eq!(::std::mem::size_of::<routerData>() , 88usize , concat ! (
               "Size of: " , stringify ! ( routerData ) ));
    assert_eq! (::std::mem::align_of::<routerData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( routerData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . CommandBufferInputCount
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( CommandBufferInputCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . InputUngets as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( InputUngets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . AwaitingInput as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( AwaitingInput ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . LineCountRouter as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( LineCountRouter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . FastCharGetRouter as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( FastCharGetRouter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . FastCharGetString as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( FastCharGetString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . FastCharGetIndex as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( FastCharGetIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . ListOfRouters as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( ListOfRouters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . FastLoadFilePtr as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( FastLoadFilePtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . FastSaveFilePtr as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( FastSaveFilePtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const routerData ) ) . Abort as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( routerData ) , "::" ,
                stringify ! ( Abort ) ));
}
impl Clone for routerData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeDefaultRouters(arg1: *mut Environment);
}
extern "C" {
    pub fn WriteString(arg1: *mut Environment,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Write(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Writeln(arg1: *mut Environment,
                   arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ReadRouter(arg1: *mut Environment,
                      arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UnreadRouter(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExitRouter(arg1: *mut Environment, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn AbortExit(arg1: *mut Environment);
}
extern "C" {
    pub fn AddRouter(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int, arg4: RouterQueryFunction,
                     arg5: RouterWriteFunction, arg6: RouterReadFunction,
                     arg7: RouterUnreadFunction, arg8: RouterExitFunction,
                     arg9: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn DeleteRouter(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn QueryRouters(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn DeactivateRouter(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn ActivateRouter(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn SetFastLoad(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn SetFastSave(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn GetFastLoad(arg1: *mut Environment) -> *mut FILE;
}
extern "C" {
    pub fn GetFastSave(arg1: *mut Environment) -> *mut FILE;
}
extern "C" {
    pub fn UnrecognizedRouterMessage(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn PrintNRouter(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *const ::std::os::raw::c_char,
                        arg4: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn InputBufferCount(arg1: *mut Environment) -> usize;
}
extern "C" {
    pub fn FindRouter(arg1: *mut Environment,
                      arg2: *const ::std::os::raw::c_char) -> *mut Router;
}
extern "C" {
    pub fn PrintRouterExists(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fileRouter {
    pub logicalName: *const ::std::os::raw::c_char,
    pub stream: *mut FILE,
    pub next: *mut fileRouter,
}
#[test]
fn bindgen_test_layout_fileRouter() {
    assert_eq!(::std::mem::size_of::<fileRouter>() , 24usize , concat ! (
               "Size of: " , stringify ! ( fileRouter ) ));
    assert_eq! (::std::mem::align_of::<fileRouter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fileRouter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileRouter ) ) . logicalName as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fileRouter ) , "::" ,
                stringify ! ( logicalName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileRouter ) ) . stream as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( fileRouter ) , "::" ,
                stringify ! ( stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileRouter ) ) . next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( fileRouter ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for fileRouter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fileRouterData {
    pub ListOfFileRouters: *mut fileRouter,
}
#[test]
fn bindgen_test_layout_fileRouterData() {
    assert_eq!(::std::mem::size_of::<fileRouterData>() , 8usize , concat ! (
               "Size of: " , stringify ! ( fileRouterData ) ));
    assert_eq! (::std::mem::align_of::<fileRouterData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fileRouterData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fileRouterData ) ) . ListOfFileRouters as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fileRouterData ) , "::"
                , stringify ! ( ListOfFileRouters ) ));
}
impl Clone for fileRouterData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeFileRouter(arg1: *mut Environment);
}
extern "C" {
    pub fn FindFptr(arg1: *mut Environment,
                    arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn OpenAFile(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *const ::std::os::raw::c_char,
                     arg4: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn CloseAllFiles(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn CloseFile(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn FindFile(arg1: *mut Environment,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn FlushAllFiles(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn FlushFile(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn RewindFile(arg1: *mut Environment,
                      arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn TellFile(arg1: *mut Environment,
                    arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn SeekFile(arg1: *mut Environment,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_long, arg4: ::std::os::raw::c_int)
     -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stringRouter {
    pub name: *const ::std::os::raw::c_char,
    pub readString: *const ::std::os::raw::c_char,
    pub writeString: *mut ::std::os::raw::c_char,
    pub currentPosition: usize,
    pub maximumPosition: usize,
    pub readWriteType: ::std::os::raw::c_int,
    pub next: *mut StringRouter,
}
#[test]
fn bindgen_test_layout_stringRouter() {
    assert_eq!(::std::mem::size_of::<stringRouter>() , 56usize , concat ! (
               "Size of: " , stringify ! ( stringRouter ) ));
    assert_eq! (::std::mem::align_of::<stringRouter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stringRouter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouter ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stringRouter ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouter ) ) . readString as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stringRouter ) , "::" ,
                stringify ! ( readString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouter ) ) . writeString as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stringRouter ) , "::" ,
                stringify ! ( writeString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouter ) ) . currentPosition as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( stringRouter ) , "::" ,
                stringify ! ( currentPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouter ) ) . maximumPosition as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( stringRouter ) , "::" ,
                stringify ! ( maximumPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouter ) ) . readWriteType as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( stringRouter ) , "::" ,
                stringify ! ( readWriteType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouter ) ) . next as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( stringRouter ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for stringRouter {
    fn clone(&self) -> Self { *self }
}
pub type StringRouter = stringRouter;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stringBuilderRouter {
    pub name: *const ::std::os::raw::c_char,
    pub SBR: *mut StringBuilder,
    pub next: *mut StringBuilderRouter,
}
#[test]
fn bindgen_test_layout_stringBuilderRouter() {
    assert_eq!(::std::mem::size_of::<stringBuilderRouter>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( stringBuilderRouter ) ));
    assert_eq! (::std::mem::align_of::<stringBuilderRouter>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( stringBuilderRouter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringBuilderRouter ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stringBuilderRouter ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringBuilderRouter ) ) . SBR as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stringBuilderRouter ) ,
                "::" , stringify ! ( SBR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringBuilderRouter ) ) . next as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stringBuilderRouter ) ,
                "::" , stringify ! ( next ) ));
}
impl Clone for stringBuilderRouter {
    fn clone(&self) -> Self { *self }
}
pub type StringBuilderRouter = stringBuilderRouter;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stringRouterData {
    pub ListOfStringRouters: *mut StringRouter,
    pub ListOfStringBuilderRouters: *mut StringBuilderRouter,
}
#[test]
fn bindgen_test_layout_stringRouterData() {
    assert_eq!(::std::mem::size_of::<stringRouterData>() , 16usize , concat !
               ( "Size of: " , stringify ! ( stringRouterData ) ));
    assert_eq! (::std::mem::align_of::<stringRouterData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( stringRouterData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouterData ) ) .
                ListOfStringRouters as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( stringRouterData ) ,
                "::" , stringify ! ( ListOfStringRouters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stringRouterData ) ) .
                ListOfStringBuilderRouters as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( stringRouterData ) ,
                "::" , stringify ! ( ListOfStringBuilderRouters ) ));
}
impl Clone for stringRouterData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    
    pub fn InitializeStringRouter(arg1: *mut Environment);
}
extern "C" {
    pub fn OpenStringSource(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *const ::std::os::raw::c_char, arg4: usize)
     -> bool;
}
extern "C" {
    pub fn OpenTextSource(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *const ::std::os::raw::c_char, arg4: usize,
                          arg5: usize) -> bool;
}
extern "C" {
    pub fn CloseStringSource(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn OpenStringDestination(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut ::std::os::raw::c_char,
                                 arg4: usize) -> bool;
}
extern "C" {
    pub fn CloseStringDestination(arg1: *mut Environment,
                                  arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn OpenStringBuilderDestination(arg1: *mut Environment,
                                        arg2: *const ::std::os::raw::c_char,
                                        arg3: *mut StringBuilder) -> bool;
}
extern "C" {
    pub fn CloseStringBuilderDestination(arg1: *mut Environment,
                                         arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn IOFunctionDefinitions(arg1: *mut Environment);
}
extern "C" {
    pub fn SetFullCRLF(arg1: *mut Environment, arg2: bool) -> bool;
}
extern "C" {
    pub fn PrintoutFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn PrintFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn PrintlnFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn ReadFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn OpenFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn CloseFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn FlushFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn RewindFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn TellFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn SeekFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetCharFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn UngetCharFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn PutCharFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn ReadlineFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn FormatFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn RemoveFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn RenameFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetLocaleFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn ReadNumberFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(::std::mem::size_of::<__jmp_buf_tag>() , 200usize , concat ! (
               "Size of: " , stringify ! ( __jmp_buf_tag ) ));
    assert_eq! (::std::mem::align_of::<__jmp_buf_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __jmp_buf_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __jmp_buf_tag ) ) . __jmpbuf as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __jmp_buf_tag ) , "::"
                , stringify ! ( __jmpbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __jmp_buf_tag ) ) . __mask_was_saved as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __jmp_buf_tag ) , "::"
                , stringify ! ( __mask_was_saved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __jmp_buf_tag ) ) . __saved_mask as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __jmp_buf_tag ) , "::"
                , stringify ! ( __saved_mask ) ));
}
impl Clone for __jmp_buf_tag {
    fn clone(&self) -> Self { *self }
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag,
                      __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gentime() -> f64;
}
extern "C" {
    pub fn gensystem(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GenOpenReadBinary(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetSeekCurBinary(arg1: *mut Environment,
                            arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn GetSeekSetBinary(arg1: *mut Environment,
                            arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn GenTellBinary(arg1: *mut Environment,
                         arg2: *mut ::std::os::raw::c_long);
}
extern "C" {
    pub fn GenCloseBinary(arg1: *mut Environment);
}
extern "C" {
    pub fn GenReadBinary(arg1: *mut Environment,
                         arg2: *mut ::std::os::raw::c_void, arg3: usize);
}
extern "C" {
    pub fn GenOpen(arg1: *mut Environment,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn GenClose(arg1: *mut Environment, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GenFlush(arg1: *mut Environment, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GenRewind(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn GenTell(arg1: *mut Environment, arg2: *mut FILE)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn GenSeek(arg1: *mut Environment, arg2: *mut FILE,
                   arg3: ::std::os::raw::c_long, arg4: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genexit(arg1: *mut Environment, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn genrand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genseed(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn genremove(arg1: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn genrename(arg1: *const ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn gengetcwd(arg1: *mut ::std::os::raw::c_char,
                     arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GenWrite(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                    arg3: *mut FILE);
}
extern "C" {
    pub fn SetBeforeOpenFunction(arg1: *mut Environment,
                                 arg2:
                                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut Environment)
                                                               ->
                                                                   ::std::os::raw::c_int>)
     ->
         ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                                    arg2:
                                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                       *mut Environment)
                                                                                  ->
                                                                                      ::std::os::raw::c_int>)
                                   -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn SetAfterOpenFunction(arg1: *mut Environment,
                                arg2:
                                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut Environment)
                                                              ->
                                                                  ::std::os::raw::c_int>)
     ->
         ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                                    arg2:
                                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                       *mut Environment)
                                                                                  ->
                                                                                      ::std::os::raw::c_int>)
                                   -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn gensprintf(arg1: *mut ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genstrcpy(arg1: *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn genstrncpy(arg1: *mut ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn genstrcat(arg1: *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn genstrncat(arg1: *mut ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn genchdir(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetJmpBuffer(arg1: *mut Environment, arg2: *mut jmp_buf);
}
extern "C" {
    pub fn genprintfile(arg1: *mut Environment, arg2: *mut FILE,
                        arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gengetchar(arg1: *mut Environment) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genungetchar(arg1: *mut Environment, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn InitializeSystemDependentData(arg1: *mut Environment);
}
extern "C" {
    pub fn InitializeNonportableFeatures(arg1: *mut Environment);
}
extern "C" {
    pub fn BasicMathFunctionDefinitions(arg1: *mut Environment);
}
extern "C" {
    pub fn AdditionFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn MultiplicationFunction(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn SubtractionFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn DivisionFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn DivFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn IntegerFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn FloatFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn AbsFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn MinFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn MaxFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                       arg3: *mut UDFValue);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FunctionArgumentsError {
    FAE_NO_ERROR = 0,
    FAE_COUNT_ERROR = 1,
    FAE_TYPE_ERROR = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct token {
    pub tknType: TokenType,
    pub __bindgen_anon_1: token__bindgen_ty_1,
    pub printForm: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy)]
pub union token__bindgen_ty_1 {
    pub value: *mut ::std::os::raw::c_void,
    pub lexemeValue: *mut CLIPSLexeme,
    pub floatValue: *mut CLIPSFloat,
    pub integerValue: *mut CLIPSInteger,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_token__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<token__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( token__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<token__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( token__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const token__bindgen_ty_1 ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( token__bindgen_ty_1 ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const token__bindgen_ty_1 ) ) . lexemeValue as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( token__bindgen_ty_1 ) ,
                "::" , stringify ! ( lexemeValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const token__bindgen_ty_1 ) ) . floatValue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( token__bindgen_ty_1 ) ,
                "::" , stringify ! ( floatValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const token__bindgen_ty_1 ) ) . integerValue as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( token__bindgen_ty_1 ) ,
                "::" , stringify ! ( integerValue ) ));
}
impl Clone for token__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_token() {
    assert_eq!(::std::mem::size_of::<token>() , 24usize , concat ! (
               "Size of: " , stringify ! ( token ) ));
    assert_eq! (::std::mem::align_of::<token>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const token ) ) . tknType as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( token ) , "::" ,
                stringify ! ( tknType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const token ) ) . printForm as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( token ) , "::" ,
                stringify ! ( printForm ) ));
}
impl Clone for token {
    fn clone(&self) -> Self { *self }
}
pub type Token = token;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TokenType {
    SYMBOL_TOKEN = 1025,
    STRING_TOKEN = 1026,
    INSTANCE_NAME_TOKEN = 1027,
    FLOAT_TOKEN = 1028,
    INTEGER_TOKEN = 1029,
    LEFT_PARENTHESIS_TOKEN = 1030,
    RIGHT_PARENTHESIS_TOKEN = 1031,
    SF_VARIABLE_TOKEN = 1032,
    MF_VARIABLE_TOKEN = 1033,
    GBL_VARIABLE_TOKEN = 1034,
    SF_WILDCARD_TOKEN = 1035,
    MF_WILDCARD_TOKEN = 1036,
    MF_GBL_VARIABLE_TOKEN = 1037,
    NOT_CONSTRAINT_TOKEN = 1038,
    AND_CONSTRAINT_TOKEN = 1039,
    OR_CONSTRAINT_TOKEN = 1040,
    STOP_TOKEN = 1041,
    UNKNOWN_VALUE_TOKEN = 1042,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scannerData {
    pub GlobalString: *mut ::std::os::raw::c_char,
    pub GlobalMax: usize,
    pub GlobalPos: usize,
    pub LineCount: ::std::os::raw::c_long,
    pub IgnoreCompletionErrors: bool,
}
#[test]
fn bindgen_test_layout_scannerData() {
    assert_eq!(::std::mem::size_of::<scannerData>() , 40usize , concat ! (
               "Size of: " , stringify ! ( scannerData ) ));
    assert_eq! (::std::mem::align_of::<scannerData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scannerData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scannerData ) ) . GlobalString as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scannerData ) , "::" ,
                stringify ! ( GlobalString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scannerData ) ) . GlobalMax as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scannerData ) , "::" ,
                stringify ! ( GlobalMax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scannerData ) ) . GlobalPos as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scannerData ) , "::" ,
                stringify ! ( GlobalPos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scannerData ) ) . LineCount as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scannerData ) , "::" ,
                stringify ! ( LineCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scannerData ) ) . IgnoreCompletionErrors
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( scannerData ) , "::" ,
                stringify ! ( IgnoreCompletionErrors ) ));
}
impl Clone for scannerData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeScannerData(arg1: *mut Environment);
}
extern "C" {
    pub fn GetToken(arg1: *mut Environment,
                    arg2: *const ::std::os::raw::c_char, arg3: *mut token);
}
extern "C" {
    pub fn CopyToken(arg1: *mut token, arg2: *mut token);
}
extern "C" {
    pub fn ResetLineCount(arg1: *mut Environment);
}
extern "C" {
    pub fn GetLineCount(arg1: *mut Environment) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SetLineCount(arg1: *mut Environment, arg2: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn IncrementLineCount(arg1: *mut Environment);
}
extern "C" {
    pub fn DecrementLineCount(arg1: *mut Environment);
}
extern "C" {
    pub fn TokenTypeToType(arg1: TokenType) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn Function0Parse(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char) -> *mut expr;
}
extern "C" {
    pub fn Function1Parse(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char) -> *mut expr;
}
extern "C" {
    pub fn Function2Parse(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *const ::std::os::raw::c_char) -> *mut expr;
}
extern "C" {
    pub fn PushRtnBrkContexts(arg1: *mut Environment);
}
extern "C" {
    pub fn PopRtnBrkContexts(arg1: *mut Environment);
}
extern "C" {
    pub fn ReplaceSequenceExpansionOps(arg1: *mut Environment,
                                       arg2: *mut expr, arg3: *mut expr,
                                       arg4: *mut ::std::os::raw::c_void,
                                       arg5: *mut ::std::os::raw::c_void)
     -> bool;
}
extern "C" {
    pub fn CollectArguments(arg1: *mut Environment, arg2: *mut expr,
                            arg3: *const ::std::os::raw::c_char) -> *mut expr;
}
extern "C" {
    pub fn ArgumentParse(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char, arg3: *mut bool)
     -> *mut expr;
}
extern "C" {
    pub fn ParseAtomOrExpression(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut token) -> *mut expr;
}
extern "C" {
    pub fn ParseConstantArguments(arg1: *mut Environment,
                                  arg2: *const ::std::os::raw::c_char,
                                  arg3: *mut bool) -> *mut Expression;
}
extern "C" {
    pub fn GroupActions(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char, arg3: *mut token,
                        arg4: bool, arg5: *const ::std::os::raw::c_char,
                        arg6: bool) -> *mut expr;
}
extern "C" {
    pub fn RemoveUnneededProgn(arg1: *mut Environment, arg2: *mut expr)
     -> *mut expr;
}
extern "C" {
    pub fn PopulateRestriction(arg1: *mut Environment,
                               arg2: *mut ::std::os::raw::c_uint,
                               arg3: ::std::os::raw::c_uint,
                               arg4: *const ::std::os::raw::c_char,
                               arg5: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn CheckExpressionAgainstRestrictions(arg1: *mut Environment,
                                              arg2: *mut expr,
                                              arg3: *mut functionDefinition,
                                              arg4:
                                                  *const ::std::os::raw::c_char)
     -> FunctionArgumentsError;
}
extern "C" {
    pub fn RestrictionExists(arg1: *const ::std::os::raw::c_char,
                             arg2: ::std::os::raw::c_int) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct watchItemRecord {
    pub name: *const ::std::os::raw::c_char,
    pub flag: *mut bool,
    pub code: ::std::os::raw::c_int,
    pub priority: ::std::os::raw::c_int,
    pub accessFunc: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut Environment,
                                                               arg2:
                                                                   ::std::os::raw::c_int,
                                                               arg3: bool,
                                                               arg4:
                                                                   *mut expr)
                                              -> bool>,
    pub printFunc: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut Environment,
                                                              arg2:
                                                                  *const ::std::os::raw::c_char,
                                                              arg3:
                                                                  ::std::os::raw::c_int,
                                                              arg4: *mut expr)
                                             -> bool>,
    pub next: *mut WatchItemRecord,
}
#[test]
fn bindgen_test_layout_watchItemRecord() {
    assert_eq!(::std::mem::size_of::<watchItemRecord>() , 48usize , concat ! (
               "Size of: " , stringify ! ( watchItemRecord ) ));
    assert_eq! (::std::mem::align_of::<watchItemRecord>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( watchItemRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const watchItemRecord ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( watchItemRecord ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const watchItemRecord ) ) . flag as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( watchItemRecord ) ,
                "::" , stringify ! ( flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const watchItemRecord ) ) . code as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( watchItemRecord ) ,
                "::" , stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const watchItemRecord ) ) . priority as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( watchItemRecord ) ,
                "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const watchItemRecord ) ) . accessFunc as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( watchItemRecord ) ,
                "::" , stringify ! ( accessFunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const watchItemRecord ) ) . printFunc as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( watchItemRecord ) ,
                "::" , stringify ! ( printFunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const watchItemRecord ) ) . next as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( watchItemRecord ) ,
                "::" , stringify ! ( next ) ));
}
impl Clone for watchItemRecord {
    fn clone(&self) -> Self { *self }
}
pub type WatchItemRecord = watchItemRecord;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WatchItem {
    ALL = 0,
    FACTS = 1,
    INSTANCES = 2,
    SLOTS = 3,
    RULES = 4,
    ACTIVATIONS = 5,
    MESSAGES = 6,
    MESSAGE_HANDLERS = 7,
    GENERIC_FUNCTIONS = 8,
    METHODS = 9,
    DEFFUNCTIONS = 10,
    COMPILATIONS = 11,
    STATISTICS = 12,
    GLOBALS = 13,
    FOCUS = 14,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct watchData {
    pub ListOfWatchItems: *mut WatchItemRecord,
}
#[test]
fn bindgen_test_layout_watchData() {
    assert_eq!(::std::mem::size_of::<watchData>() , 8usize , concat ! (
               "Size of: " , stringify ! ( watchData ) ));
    assert_eq! (::std::mem::align_of::<watchData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( watchData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const watchData ) ) . ListOfWatchItems as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( watchData ) , "::" ,
                stringify ! ( ListOfWatchItems ) ));
}
impl Clone for watchData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn Watch(arg1: *mut Environment, arg2: WatchItem);
}
extern "C" {
    pub fn Unwatch(arg1: *mut Environment, arg2: WatchItem);
}
extern "C" {
    pub fn WatchString(arg1: *mut Environment,
                       arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn UnwatchString(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn InitializeWatchData(arg1: *mut Environment);
}
extern "C" {
    pub fn SetWatchItem(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char, arg3: bool,
                        arg4: *mut expr) -> bool;
}
extern "C" {
    pub fn GetWatchItem(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AddWatchItem(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int, arg4: *mut bool,
                        arg5: ::std::os::raw::c_int,
                        arg6:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut Environment,
                                                                       arg2:
                                                                           ::std::os::raw::c_int,
                                                                       arg3:
                                                                           bool,
                                                                       arg4:
                                                                           *mut expr)
                                                      -> bool>,
                        arg7:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut Environment,
                                                                       arg2:
                                                                           *const ::std::os::raw::c_char,
                                                                       arg3:
                                                                           ::std::os::raw::c_int,
                                                                       arg4:
                                                                           *mut expr)
                                                      -> bool>) -> bool;
}
extern "C" {
    pub fn GetNthWatchName(arg1: *mut Environment,
                           arg2: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetNthWatchValue(arg1: *mut Environment,
                            arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WatchCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn UnwatchCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListWatchItemsCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn WatchFunctionDefinitions(arg1: *mut Environment);
}
extern "C" {
    pub fn GetWatchItemCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetWatchState(arg1: *mut Environment, arg2: WatchItem) -> bool;
}
extern "C" {
    pub fn SetWatchState(arg1: *mut Environment, arg2: WatchItem, arg3: bool);
}
extern "C" {
    pub fn DefmoduleBasicCommands(arg1: *mut Environment);
}
extern "C" {
    pub fn GetDefmoduleListFunction(arg1: *mut Environment,
                                    arg2: *mut UDFContext,
                                    arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefmoduleList(arg1: *mut Environment, arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn PPDefmoduleCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDefmodule(arg1: *mut Environment,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn ListDefmodulesCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefmodules(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn AllocateExpressions(arg1: *mut Environment);
}
extern "C" {
    pub fn RefreshExpressions(arg1: *mut Environment);
}
extern "C" {
    pub fn ClearBloadedExpressions(arg1: *mut Environment);
}
extern "C" {
    pub fn FindHashedExpressions(arg1: *mut Environment);
}
extern "C" {
    pub fn BsaveHashedExpressions(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn BsaveConstructExpressions(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn BsaveExpression(arg1: *mut Environment, arg2: *mut expr,
                           arg3: *mut FILE);
}
extern "C" {
    pub fn MarkNeededAtomicValues(arg1: Environment);
}
extern "C" {
    pub fn WriteNeededAtomicValues(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn ReadNeededAtomicValues(arg1: *mut Environment);
}
extern "C" {
    pub fn InitAtomicValueNeededFlags(arg1: *mut Environment);
}
extern "C" {
    pub fn FreeAtomicValueStorage(arg1: *mut Environment);
}
extern "C" {
    pub fn WriteNeededSymbols(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn WriteNeededFloats(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn WriteNeededIntegers(arg1: *mut Environment, arg2: *mut FILE);
}
extern "C" {
    pub fn ReadNeededSymbols(arg1: *mut Environment);
}
extern "C" {
    pub fn ReadNeededFloats(arg1: *mut Environment);
}
extern "C" {
    pub fn ReadNeededIntegers(arg1: *mut Environment);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bloadData {
    pub BinaryPrefixID: *const ::std::os::raw::c_char,
    pub BinaryVersionID: *const ::std::os::raw::c_char,
    pub BinarySizes: *mut ::std::os::raw::c_char,
    pub FunctionArray: *mut *mut functionDefinition,
    pub BloadActive: bool,
    pub BeforeBloadFunctions: *mut voidCallFunctionItem,
    pub AfterBloadFunctions: *mut voidCallFunctionItem,
    pub ClearBloadReadyFunctions: *mut boolCallFunctionItem,
    pub AbortBloadFunctions: *mut voidCallFunctionItem,
}
#[test]
fn bindgen_test_layout_bloadData() {
    assert_eq!(::std::mem::size_of::<bloadData>() , 72usize , concat ! (
               "Size of: " , stringify ! ( bloadData ) ));
    assert_eq! (::std::mem::align_of::<bloadData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bloadData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . BinaryPrefixID as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( BinaryPrefixID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . BinaryVersionID as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( BinaryVersionID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . BinarySizes as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( BinarySizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . FunctionArray as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( FunctionArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . BloadActive as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( BloadActive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . BeforeBloadFunctions as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( BeforeBloadFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . AfterBloadFunctions as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( AfterBloadFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . ClearBloadReadyFunctions
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( ClearBloadReadyFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadData ) ) . AbortBloadFunctions as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadData ) , "::" ,
                stringify ! ( AbortBloadFunctions ) ));
}
impl Clone for bloadData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeBloadData(arg1: *mut Environment);
}
extern "C" {
    pub fn BloadCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn Bload(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn BloadandRefresh(arg1: *mut Environment,
                           arg2: ::std::os::raw::c_ulong, arg3: usize,
                           arg4:
                               ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut Environment,
                                                                          arg2:
                                                                              *mut ::std::os::raw::c_void,
                                                                          arg3:
                                                                              ::std::os::raw::c_ulong)>);
}
extern "C" {
    pub fn Bloaded(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn AddBeforeBloadFunction(arg1: *mut Environment,
                                  arg2: *const ::std::os::raw::c_char,
                                  arg3: VoidCallFunction,
                                  arg4: ::std::os::raw::c_int,
                                  arg5: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn AddAfterBloadFunction(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: VoidCallFunction,
                                 arg4: ::std::os::raw::c_int,
                                 arg5: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn AddClearBloadReadyFunction(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3: BoolCallFunction,
                                      arg4: ::std::os::raw::c_int,
                                      arg5: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn AddAbortBloadFunction(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: VoidCallFunction,
                                 arg4: ::std::os::raw::c_int,
                                 arg5: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn CannotLoadWithBloadMessage(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BinaryItem {
    pub name: *const ::std::os::raw::c_char,
    pub findFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut Environment)>,
    pub bloadStorageFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut Environment)>,
    pub bloadFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut Environment)>,
    pub clearFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut Environment)>,
    pub expressionFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut Environment,
                                                                       arg2:
                                                                           *mut FILE)>,
    pub bsaveStorageFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut Environment,
                                                                         arg2:
                                                                             *mut FILE)>,
    pub bsaveFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut Environment,
                                                                  arg2:
                                                                      *mut FILE)>,
    pub priority: ::std::os::raw::c_int,
    pub next: *mut BinaryItem,
}
#[test]
fn bindgen_test_layout_BinaryItem() {
    assert_eq!(::std::mem::size_of::<BinaryItem>() , 80usize , concat ! (
               "Size of: " , stringify ! ( BinaryItem ) ));
    assert_eq! (::std::mem::align_of::<BinaryItem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( BinaryItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . findFunction as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( findFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . bloadStorageFunction as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( bloadStorageFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . bloadFunction as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( bloadFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . clearFunction as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( clearFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . expressionFunction as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( expressionFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . bsaveStorageFunction as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( bsaveStorageFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . bsaveFunction as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( bsaveFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . priority as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BinaryItem ) ) . next as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( BinaryItem ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for BinaryItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bloadcntsv {
    pub val: ::std::os::raw::c_ulong,
    pub nxt: *mut bloadcntsv,
}
#[test]
fn bindgen_test_layout_bloadcntsv() {
    assert_eq!(::std::mem::size_of::<bloadcntsv>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bloadcntsv ) ));
    assert_eq! (::std::mem::align_of::<bloadcntsv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bloadcntsv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadcntsv ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadcntsv ) , "::" ,
                stringify ! ( val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bloadcntsv ) ) . nxt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bloadcntsv ) , "::" ,
                stringify ! ( nxt ) ));
}
impl Clone for bloadcntsv {
    fn clone(&self) -> Self { *self }
}
pub type BLOADCNTSV = bloadcntsv;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bsave_expr {
    pub type_: ::std::os::raw::c_ushort,
    pub value: ::std::os::raw::c_ulong,
    pub argList: ::std::os::raw::c_ulong,
    pub nextArg: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_bsave_expr() {
    assert_eq!(::std::mem::size_of::<bsave_expr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( bsave_expr ) ));
    assert_eq! (::std::mem::align_of::<bsave_expr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bsave_expr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bsave_expr ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bsave_expr ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bsave_expr ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bsave_expr ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bsave_expr ) ) . argList as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bsave_expr ) , "::" ,
                stringify ! ( argList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bsave_expr ) ) . nextArg as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bsave_expr ) , "::" ,
                stringify ! ( nextArg ) ));
}
impl Clone for bsave_expr {
    fn clone(&self) -> Self { *self }
}
pub type BSAVE_EXPRESSION = bsave_expr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bsaveData {
    pub ListOfBinaryItems: *mut BinaryItem,
    pub BloadCountSaveTop: *mut BLOADCNTSV,
}
#[test]
fn bindgen_test_layout_bsaveData() {
    assert_eq!(::std::mem::size_of::<bsaveData>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bsaveData ) ));
    assert_eq! (::std::mem::align_of::<bsaveData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bsaveData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bsaveData ) ) . ListOfBinaryItems as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bsaveData ) , "::" ,
                stringify ! ( ListOfBinaryItems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bsaveData ) ) . BloadCountSaveTop as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bsaveData ) , "::" ,
                stringify ! ( BloadCountSaveTop ) ));
}
impl Clone for bsaveData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeBsaveData(arg1: *mut Environment);
}
extern "C" {
    pub fn BsaveCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn Bsave(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn MarkNeededItems(arg1: *mut Environment, arg2: *mut expr);
}
extern "C" {
    pub fn SaveBloadCount(arg1: *mut Environment,
                          arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn RestoreBloadCount(arg1: *mut Environment,
                             arg2: *mut ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn AddBinaryItem(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: ::std::os::raw::c_int,
                         arg4:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment)>,
                         arg5:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment,
                                                                        arg2:
                                                                            *mut FILE)>,
                         arg6:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment,
                                                                        arg2:
                                                                            *mut FILE)>,
                         arg7:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment,
                                                                        arg2:
                                                                            *mut FILE)>,
                         arg8:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment)>,
                         arg9:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment)>,
                         arg10:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut Environment)>)
     -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defrule {
    pub header: ConstructHeader,
    pub salience: ::std::os::raw::c_int,
    pub localVarCnt: ::std::os::raw::c_ushort,
    pub _bitfield_1: u16,
    pub dynamicSalience: *mut expr,
    pub actions: *mut expr,
    pub logicalJoin: *mut joinNode,
    pub lastJoin: *mut joinNode,
    pub disjunct: *mut Defrule,
}
#[test]
fn bindgen_test_layout_defrule() {
    assert_eq!(::std::mem::size_of::<defrule>() , 112usize , concat ! (
               "Size of: " , stringify ! ( defrule ) ));
    assert_eq! (::std::mem::align_of::<defrule>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defrule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defrule ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defrule ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defrule ) ) . salience as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( defrule ) , "::" ,
                stringify ! ( salience ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defrule ) ) . localVarCnt as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( defrule ) , "::" ,
                stringify ! ( localVarCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defrule ) ) . dynamicSalience as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( defrule ) , "::" ,
                stringify ! ( dynamicSalience ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defrule ) ) . actions as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( defrule ) , "::" ,
                stringify ! ( actions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defrule ) ) . logicalJoin as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( defrule ) , "::" ,
                stringify ! ( logicalJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defrule ) ) . lastJoin as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( defrule ) , "::" ,
                stringify ! ( lastJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defrule ) ) . disjunct as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( defrule ) , "::" ,
                stringify ! ( disjunct ) ));
}
impl Clone for defrule {
    fn clone(&self) -> Self { *self }
}
impl defrule {
    #[inline]
    pub fn complexity(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2047u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_complexity(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2047u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn afterBreakpoint(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2048u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_afterBreakpoint(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn watchActivation(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4096u64 as u16;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_watchActivation(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn watchFiring(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8192u64 as u16;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_watchFiring(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8192u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn autoFocus(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16384u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_autoFocus(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16384u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn executing(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_executing(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(complexity: ::std::os::raw::c_uint,
                          afterBreakpoint: ::std::os::raw::c_uint,
                          watchActivation: ::std::os::raw::c_uint,
                          watchFiring: ::std::os::raw::c_uint,
                          autoFocus: ::std::os::raw::c_uint,
                          executing: ::std::os::raw::c_uint) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((complexity as u32 as u16) << 0usize) &
                                          (2047u64 as u16))
                             } |
                                 ((afterBreakpoint as u32 as u16) << 11usize)
                                     & (2048u64 as u16))
                        } |
                            ((watchActivation as u32 as u16) << 12usize) &
                                (4096u64 as u16))
                   } |
                       ((watchFiring as u32 as u16) << 13usize) &
                           (8192u64 as u16))
              } | ((autoFocus as u32 as u16) << 14usize) & (16384u64 as u16))
         } | ((executing as u32 as u16) << 15usize) & (32768u64 as u16))
    }
}
pub type Defrule = defrule;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defruleModule {
    pub header: defmoduleItemHeader,
    pub groupings: *mut salienceGroup,
    pub agenda: *mut activation,
}
#[test]
fn bindgen_test_layout_defruleModule() {
    assert_eq!(::std::mem::size_of::<defruleModule>() , 40usize , concat ! (
               "Size of: " , stringify ! ( defruleModule ) ));
    assert_eq! (::std::mem::align_of::<defruleModule>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defruleModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleModule ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleModule ) , "::"
                , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleModule ) ) . groupings as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleModule ) , "::"
                , stringify ! ( groupings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleModule ) ) . agenda as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleModule ) , "::"
                , stringify ! ( agenda ) ));
}
impl Clone for defruleModule {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct alphaMemoryHash {
    pub bucket: ::std::os::raw::c_ulong,
    pub owner: *mut patternNodeHeader,
    pub alphaMemory: *mut PartialMatch,
    pub endOfQueue: *mut PartialMatch,
    pub nextHash: *mut alphaMemoryHash,
    pub prevHash: *mut alphaMemoryHash,
    pub next: *mut alphaMemoryHash,
    pub prev: *mut alphaMemoryHash,
}
#[test]
fn bindgen_test_layout_alphaMemoryHash() {
    assert_eq!(::std::mem::size_of::<alphaMemoryHash>() , 64usize , concat ! (
               "Size of: " , stringify ! ( alphaMemoryHash ) ));
    assert_eq! (::std::mem::align_of::<alphaMemoryHash>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( alphaMemoryHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMemoryHash ) ) . bucket as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMemoryHash ) ,
                "::" , stringify ! ( bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMemoryHash ) ) . owner as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMemoryHash ) ,
                "::" , stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMemoryHash ) ) . alphaMemory as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMemoryHash ) ,
                "::" , stringify ! ( alphaMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMemoryHash ) ) . endOfQueue as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMemoryHash ) ,
                "::" , stringify ! ( endOfQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMemoryHash ) ) . nextHash as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMemoryHash ) ,
                "::" , stringify ! ( nextHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMemoryHash ) ) . prevHash as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMemoryHash ) ,
                "::" , stringify ! ( prevHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMemoryHash ) ) . next as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMemoryHash ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMemoryHash ) ) . prev as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMemoryHash ) ,
                "::" , stringify ! ( prev ) ));
}
impl Clone for alphaMemoryHash {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct betaMemory {
    pub size: ::std::os::raw::c_ulong,
    pub count: ::std::os::raw::c_ulong,
    pub beta: *mut *mut partialMatch,
    pub last: *mut *mut partialMatch,
}
#[test]
fn bindgen_test_layout_betaMemory() {
    assert_eq!(::std::mem::size_of::<betaMemory>() , 32usize , concat ! (
               "Size of: " , stringify ! ( betaMemory ) ));
    assert_eq! (::std::mem::align_of::<betaMemory>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( betaMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const betaMemory ) ) . size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( betaMemory ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const betaMemory ) ) . count as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( betaMemory ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const betaMemory ) ) . beta as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( betaMemory ) , "::" ,
                stringify ! ( beta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const betaMemory ) ) . last as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( betaMemory ) , "::" ,
                stringify ! ( last ) ));
}
impl Clone for betaMemory {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct joinLink {
    pub enterDirection: ::std::os::raw::c_char,
    pub join: *mut joinNode,
    pub next: *mut joinLink,
    pub bsaveID: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_joinLink() {
    assert_eq!(::std::mem::size_of::<joinLink>() , 32usize , concat ! (
               "Size of: " , stringify ! ( joinLink ) ));
    assert_eq! (::std::mem::align_of::<joinLink>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( joinLink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinLink ) ) . enterDirection as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( joinLink ) , "::" ,
                stringify ! ( enterDirection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinLink ) ) . join as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( joinLink ) , "::" ,
                stringify ! ( join ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinLink ) ) . next as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( joinLink ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinLink ) ) . bsaveID as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( joinLink ) , "::" ,
                stringify ! ( bsaveID ) ));
}
impl Clone for joinLink {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct joinNode {
    pub _bitfield_1: [u16; 2usize],
    pub bsaveID: ::std::os::raw::c_ulong,
    pub memoryLeftAdds: ::std::os::raw::c_longlong,
    pub memoryRightAdds: ::std::os::raw::c_longlong,
    pub memoryLeftDeletes: ::std::os::raw::c_longlong,
    pub memoryRightDeletes: ::std::os::raw::c_longlong,
    pub memoryCompares: ::std::os::raw::c_longlong,
    pub leftMemory: *mut betaMemory,
    pub rightMemory: *mut betaMemory,
    pub networkTest: *mut Expression,
    pub secondaryNetworkTest: *mut Expression,
    pub leftHash: *mut Expression,
    pub rightHash: *mut Expression,
    pub rightSideEntryStructure: *mut ::std::os::raw::c_void,
    pub nextLinks: *mut joinLink,
    pub lastLevel: *mut joinNode,
    pub rightMatchNode: *mut joinNode,
    pub ruleToActivate: *mut Defrule,
}
#[test]
fn bindgen_test_layout_joinNode() {
    assert_eq!(::std::mem::size_of::<joinNode>() , 144usize , concat ! (
               "Size of: " , stringify ! ( joinNode ) ));
    assert_eq! (::std::mem::align_of::<joinNode>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( joinNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . bsaveID as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( bsaveID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . memoryLeftAdds as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( memoryLeftAdds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . memoryRightAdds as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( memoryRightAdds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . memoryLeftDeletes as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( memoryLeftDeletes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . memoryRightDeletes as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( memoryRightDeletes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . memoryCompares as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( memoryCompares ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . leftMemory as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( leftMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . rightMemory as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( rightMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . networkTest as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( networkTest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . secondaryNetworkTest as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( secondaryNetworkTest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . leftHash as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( leftHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . rightHash as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( rightHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . rightSideEntryStructure as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( rightSideEntryStructure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . nextLinks as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( nextLinks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . lastLevel as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( lastLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . rightMatchNode as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( rightMatchNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinNode ) ) . ruleToActivate as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( joinNode ) , "::" ,
                stringify ! ( ruleToActivate ) ));
}
impl Clone for joinNode {
    fn clone(&self) -> Self { *self }
}
impl joinNode {
    #[inline]
    pub fn firstJoin(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_firstJoin(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn logicalJoin(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_logicalJoin(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn joinFromTheRight(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_joinFromTheRight(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn patternIsNegated(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_patternIsNegated(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn patternIsExists(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_patternIsExists(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn initialize(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32u64 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_initialize(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn marked(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 64u64 as u32;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_marked(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 64u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn rhsType(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 896u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rhsType(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 896u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn depth(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 67107840u64 as u32;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_depth(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 67107840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(firstJoin: ::std::os::raw::c_uint,
                          logicalJoin: ::std::os::raw::c_uint,
                          joinFromTheRight: ::std::os::raw::c_uint,
                          patternIsNegated: ::std::os::raw::c_uint,
                          patternIsExists: ::std::os::raw::c_uint,
                          initialize: ::std::os::raw::c_uint,
                          marked: ::std::os::raw::c_uint,
                          rhsType: ::std::os::raw::c_uint,
                          depth: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((firstJoin as u32 as
                                                           u32) << 0usize) &
                                                         (1u64 as u32))
                                            } |
                                                ((logicalJoin as u32 as u32)
                                                     << 1usize) &
                                                    (2u64 as u32))
                                       } |
                                           ((joinFromTheRight as u32 as u32)
                                                << 2usize) & (4u64 as u32))
                                  } |
                                      ((patternIsNegated as u32 as u32) <<
                                           3usize) & (8u64 as u32))
                             } |
                                 ((patternIsExists as u32 as u32) << 4usize) &
                                     (16u64 as u32))
                        } |
                            ((initialize as u32 as u32) << 5usize) &
                                (32u64 as u32))
                   } | ((marked as u32 as u32) << 6usize) & (64u64 as u32))
              } | ((rhsType as u32 as u32) << 7usize) & (896u64 as u32))
         } | ((depth as u32 as u32) << 10usize) & (67107840u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct patternNodeHashEntry {
    pub parent: *mut ::std::os::raw::c_void,
    pub child: *mut ::std::os::raw::c_void,
    pub type_: ::std::os::raw::c_int,
    pub value: *mut ::std::os::raw::c_void,
    pub next: *mut patternNodeHashEntry,
}
#[test]
fn bindgen_test_layout_patternNodeHashEntry() {
    assert_eq!(::std::mem::size_of::<patternNodeHashEntry>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( patternNodeHashEntry )
               ));
    assert_eq! (::std::mem::align_of::<patternNodeHashEntry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( patternNodeHashEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHashEntry ) ) . parent as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHashEntry )
                , "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHashEntry ) ) . child as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHashEntry )
                , "::" , stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHashEntry ) ) . type_ as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHashEntry )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHashEntry ) ) . value as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHashEntry )
                , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHashEntry ) ) . next as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHashEntry )
                , "::" , stringify ! ( next ) ));
}
impl Clone for patternNodeHashEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct patternNodeHeader {
    pub firstHash: *mut alphaMemoryHash,
    pub lastHash: *mut alphaMemoryHash,
    pub entryJoin: *mut joinNode,
    pub rightHash: *mut Expression,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_patternNodeHeader() {
    assert_eq!(::std::mem::size_of::<patternNodeHeader>() , 40usize , concat !
               ( "Size of: " , stringify ! ( patternNodeHeader ) ));
    assert_eq! (::std::mem::align_of::<patternNodeHeader>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( patternNodeHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHeader ) ) . firstHash as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHeader ) ,
                "::" , stringify ! ( firstHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHeader ) ) . lastHash as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHeader ) ,
                "::" , stringify ! ( lastHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHeader ) ) . entryJoin as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHeader ) ,
                "::" , stringify ! ( entryJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternNodeHeader ) ) . rightHash as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( patternNodeHeader ) ,
                "::" , stringify ! ( rightHash ) ));
}
impl Clone for patternNodeHeader {
    fn clone(&self) -> Self { *self }
}
impl patternNodeHeader {
    #[inline]
    pub fn singlefieldNode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_singlefieldNode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn multifieldNode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_multifieldNode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn stopNode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_stopNode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn initialize(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_initialize(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn marked(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_marked(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn beginSlot(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_beginSlot(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn endSlot(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 64u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_endSlot(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 64u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn selector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 128u64 as u8;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_selector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(singlefieldNode: ::std::os::raw::c_uint,
                          multifieldNode: ::std::os::raw::c_uint,
                          stopNode: ::std::os::raw::c_uint,
                          initialize: ::std::os::raw::c_uint,
                          marked: ::std::os::raw::c_uint,
                          beginSlot: ::std::os::raw::c_uint,
                          endSlot: ::std::os::raw::c_uint,
                          selector: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((singlefieldNode as u32 as
                                                      u8) << 0usize) &
                                                    (1u64 as u8))
                                       } |
                                           ((multifieldNode as u32 as u8) <<
                                                1usize) & (2u64 as u8))
                                  } |
                                      ((stopNode as u32 as u8) << 2usize) &
                                          (4u64 as u8))
                             } |
                                 ((initialize as u32 as u8) << 3usize) &
                                     (8u64 as u8))
                        } | ((marked as u32 as u8) << 4usize) & (16u64 as u8))
                   } | ((beginSlot as u32 as u8) << 5usize) & (32u64 as u8))
              } | ((endSlot as u32 as u8) << 6usize) & (64u64 as u8))
         } | ((selector as u32 as u8) << 7usize) & (128u64 as u8))
    }
}
pub type PatternNodeHeader = patternNodeHeader;

#[repr(C)]
#[derive(Copy)]
pub struct genericMatch {
    pub gm: genericMatch__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union genericMatch__bindgen_ty_1 {
    pub theValue: *mut ::std::os::raw::c_void,
    pub theMatch: *mut AlphaMatch,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_genericMatch__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<genericMatch__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( genericMatch__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<genericMatch__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( genericMatch__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const genericMatch__bindgen_ty_1 ) ) . theValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                genericMatch__bindgen_ty_1 ) , "::" , stringify ! ( theValue )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const genericMatch__bindgen_ty_1 ) ) . theMatch
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                genericMatch__bindgen_ty_1 ) , "::" , stringify ! ( theMatch )
                ));
}
impl Clone for genericMatch__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_genericMatch() {
    assert_eq!(::std::mem::size_of::<genericMatch>() , 8usize , concat ! (
               "Size of: " , stringify ! ( genericMatch ) ));
    assert_eq! (::std::mem::align_of::<genericMatch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( genericMatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const genericMatch ) ) . gm as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( genericMatch ) , "::" ,
                stringify ! ( gm ) ));
}
impl Clone for genericMatch {
    fn clone(&self) -> Self { *self }
}
pub type GenericMatch = genericMatch;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct patternMatch {
    pub next: *mut PatternMatch,
    pub theMatch: *mut PartialMatch,
    pub matchingPattern: *mut PatternNodeHeader,
}
#[test]
fn bindgen_test_layout_patternMatch() {
    assert_eq!(::std::mem::size_of::<patternMatch>() , 24usize , concat ! (
               "Size of: " , stringify ! ( patternMatch ) ));
    assert_eq! (::std::mem::align_of::<patternMatch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( patternMatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternMatch ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( patternMatch ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternMatch ) ) . theMatch as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( patternMatch ) , "::" ,
                stringify ! ( theMatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const patternMatch ) ) . matchingPattern as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( patternMatch ) , "::" ,
                stringify ! ( matchingPattern ) ));
}
impl Clone for patternMatch {
    fn clone(&self) -> Self { *self }
}
pub type PatternMatch = patternMatch;

#[repr(C)]
#[derive(Copy)]
pub struct partialMatch {
    pub _bitfield_1: u8,
    pub bcount: ::std::os::raw::c_ushort,
    pub hashValue: ::std::os::raw::c_ulong,
    pub owner: *mut ::std::os::raw::c_void,
    pub marker: *mut ::std::os::raw::c_void,
    pub dependents: *mut ::std::os::raw::c_void,
    pub nextInMemory: *mut PartialMatch,
    pub prevInMemory: *mut PartialMatch,
    pub children: *mut PartialMatch,
    pub rightParent: *mut PartialMatch,
    pub nextRightChild: *mut PartialMatch,
    pub prevRightChild: *mut PartialMatch,
    pub leftParent: *mut PartialMatch,
    pub nextLeftChild: *mut PartialMatch,
    pub prevLeftChild: *mut PartialMatch,
    pub blockList: *mut PartialMatch,
    pub nextBlocked: *mut PartialMatch,
    pub prevBlocked: *mut PartialMatch,
    pub binds: [GenericMatch; 1usize],
}
#[test]
fn bindgen_test_layout_partialMatch() {
    assert_eq!(::std::mem::size_of::<partialMatch>() , 144usize , concat ! (
               "Size of: " , stringify ! ( partialMatch ) ));
    assert_eq! (::std::mem::align_of::<partialMatch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( partialMatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . bcount as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( bcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . hashValue as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( hashValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . owner as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . marker as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . dependents as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( dependents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . nextInMemory as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( nextInMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . prevInMemory as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( prevInMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . children as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . rightParent as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( rightParent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . nextRightChild as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( nextRightChild ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . prevRightChild as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( prevRightChild ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . leftParent as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( leftParent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . nextLeftChild as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( nextLeftChild ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . prevLeftChild as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( prevLeftChild ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . blockList as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( blockList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . nextBlocked as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( nextBlocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . prevBlocked as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( prevBlocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const partialMatch ) ) . binds as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( partialMatch ) , "::" ,
                stringify ! ( binds ) ));
}
impl Clone for partialMatch {
    fn clone(&self) -> Self { *self }
}
impl partialMatch {
    #[inline]
    pub fn betaMemory(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_betaMemory(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn busy(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_busy(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn rhsMemory(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rhsMemory(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn deleting(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_deleting(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(betaMemory: ::std::os::raw::c_uint,
                          busy: ::std::os::raw::c_uint,
                          rhsMemory: ::std::os::raw::c_uint,
                          deleting: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((betaMemory as u32 as u8) << 0usize) &
                                (1u64 as u8))
                   } | ((busy as u32 as u8) << 1usize) & (2u64 as u8))
              } | ((rhsMemory as u32 as u8) << 2usize) & (4u64 as u8))
         } | ((deleting as u32 as u8) << 3usize) & (8u64 as u8))
    }
}
pub type PartialMatch = partialMatch;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct alphaMatch {
    pub matchingItem: *mut PatternEntity,
    pub markers: *mut MultifieldMarker,
    pub next: *mut AlphaMatch,
    pub bucket: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_alphaMatch() {
    assert_eq!(::std::mem::size_of::<alphaMatch>() , 32usize , concat ! (
               "Size of: " , stringify ! ( alphaMatch ) ));
    assert_eq! (::std::mem::align_of::<alphaMatch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( alphaMatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMatch ) ) . matchingItem as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMatch ) , "::" ,
                stringify ! ( matchingItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMatch ) ) . markers as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMatch ) , "::" ,
                stringify ! ( markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMatch ) ) . next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMatch ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alphaMatch ) ) . bucket as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( alphaMatch ) , "::" ,
                stringify ! ( bucket ) ));
}
impl Clone for alphaMatch {
    fn clone(&self) -> Self { *self }
}
pub type AlphaMatch = alphaMatch;

#[repr(C)]
#[derive(Copy)]
pub struct multifieldMarker {
    pub whichField: ::std::os::raw::c_ushort,
    pub where_: multifieldMarker__bindgen_ty_1,
    pub startPosition: usize,
    pub range: usize,
    pub next: *mut MultifieldMarker,
}
#[repr(C)]
#[derive(Copy)]
pub union multifieldMarker__bindgen_ty_1 {
    pub whichSlot: *mut ::std::os::raw::c_void,
    pub whichSlotNumber: ::std::os::raw::c_ushort,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_multifieldMarker__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<multifieldMarker__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( multifieldMarker__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<multifieldMarker__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( multifieldMarker__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldMarker__bindgen_ty_1 ) ) .
                whichSlot as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                multifieldMarker__bindgen_ty_1 ) , "::" , stringify ! (
                whichSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldMarker__bindgen_ty_1 ) ) .
                whichSlotNumber as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                multifieldMarker__bindgen_ty_1 ) , "::" , stringify ! (
                whichSlotNumber ) ));
}
impl Clone for multifieldMarker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_multifieldMarker() {
    assert_eq!(::std::mem::size_of::<multifieldMarker>() , 40usize , concat !
               ( "Size of: " , stringify ! ( multifieldMarker ) ));
    assert_eq! (::std::mem::align_of::<multifieldMarker>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( multifieldMarker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldMarker ) ) . whichField as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldMarker ) ,
                "::" , stringify ! ( whichField ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldMarker ) ) . where_ as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldMarker ) ,
                "::" , stringify ! ( where_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldMarker ) ) . startPosition as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldMarker ) ,
                "::" , stringify ! ( startPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldMarker ) ) . range as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldMarker ) ,
                "::" , stringify ! ( range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldMarker ) ) . next as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldMarker ) ,
                "::" , stringify ! ( next ) ));
}
impl Clone for multifieldMarker {
    fn clone(&self) -> Self { *self }
}
pub type MultifieldMarker = multifieldMarker;
pub type ALPHA_MEMORY_HASH = alphaMemoryHash;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct activation {
    pub theRule: *mut Defrule,
    pub basis: *mut partialMatch,
    pub salience: ::std::os::raw::c_int,
    pub timetag: ::std::os::raw::c_ulonglong,
    pub randomID: ::std::os::raw::c_int,
    pub prev: *mut activation,
    pub next: *mut activation,
}
#[test]
fn bindgen_test_layout_activation() {
    assert_eq!(::std::mem::size_of::<activation>() , 56usize , concat ! (
               "Size of: " , stringify ! ( activation ) ));
    assert_eq! (::std::mem::align_of::<activation>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( activation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const activation ) ) . theRule as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( activation ) , "::" ,
                stringify ! ( theRule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const activation ) ) . basis as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( activation ) , "::" ,
                stringify ! ( basis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const activation ) ) . salience as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( activation ) , "::" ,
                stringify ! ( salience ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const activation ) ) . timetag as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( activation ) , "::" ,
                stringify ! ( timetag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const activation ) ) . randomID as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( activation ) , "::" ,
                stringify ! ( randomID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const activation ) ) . prev as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( activation ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const activation ) ) . next as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( activation ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for activation {
    fn clone(&self) -> Self { *self }
}
pub type Activation = activation;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SalienceEvaluationType {
    WHEN_DEFINED = 0,
    WHEN_ACTIVATED = 1,
    EVERY_CYCLE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct salienceGroup {
    pub salience: ::std::os::raw::c_int,
    pub first: *mut activation,
    pub last: *mut activation,
    pub next: *mut salienceGroup,
    pub prev: *mut salienceGroup,
}
#[test]
fn bindgen_test_layout_salienceGroup() {
    assert_eq!(::std::mem::size_of::<salienceGroup>() , 40usize , concat ! (
               "Size of: " , stringify ! ( salienceGroup ) ));
    assert_eq! (::std::mem::align_of::<salienceGroup>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( salienceGroup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const salienceGroup ) ) . salience as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( salienceGroup ) , "::"
                , stringify ! ( salience ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const salienceGroup ) ) . first as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( salienceGroup ) , "::"
                , stringify ! ( first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const salienceGroup ) ) . last as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( salienceGroup ) , "::"
                , stringify ! ( last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const salienceGroup ) ) . next as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( salienceGroup ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const salienceGroup ) ) . prev as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( salienceGroup ) , "::"
                , stringify ! ( prev ) ));
}
impl Clone for salienceGroup {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StrategyType {
    DEPTH_STRATEGY = 0,
    BREADTH_STRATEGY = 1,
    LEX_STRATEGY = 2,
    MEA_STRATEGY = 3,
    COMPLEXITY_STRATEGY = 4,
    SIMPLICITY_STRATEGY = 5,
    RANDOM_STRATEGY = 6,
}
extern "C" {
    pub fn PlaceActivation(arg1: *mut Environment, arg2: *mut *mut Activation,
                           arg3: *mut Activation, arg4: *mut salienceGroup);
}
extern "C" {
    pub fn SetStrategy(arg1: *mut Environment, arg2: StrategyType)
     -> StrategyType;
}
extern "C" {
    pub fn GetStrategy(arg1: *mut Environment) -> StrategyType;
}
extern "C" {
    pub fn SetStrategyCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetStrategyCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct agendaData {
    pub WatchActivations: bool,
    pub NumberOfActivations: ::std::os::raw::c_ulong,
    pub CurrentTimetag: ::std::os::raw::c_ulonglong,
    pub AgendaChanged: bool,
    pub SalienceEvaluation: SalienceEvaluationType,
    pub Strategy: StrategyType,
}
#[test]
fn bindgen_test_layout_agendaData() {
    assert_eq!(::std::mem::size_of::<agendaData>() , 40usize , concat ! (
               "Size of: " , stringify ! ( agendaData ) ));
    assert_eq! (::std::mem::align_of::<agendaData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( agendaData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const agendaData ) ) . WatchActivations as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( agendaData ) , "::" ,
                stringify ! ( WatchActivations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const agendaData ) ) . NumberOfActivations as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( agendaData ) , "::" ,
                stringify ! ( NumberOfActivations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const agendaData ) ) . CurrentTimetag as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( agendaData ) , "::" ,
                stringify ! ( CurrentTimetag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const agendaData ) ) . AgendaChanged as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( agendaData ) , "::" ,
                stringify ! ( AgendaChanged ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const agendaData ) ) . SalienceEvaluation as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( agendaData ) , "::" ,
                stringify ! ( SalienceEvaluation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const agendaData ) ) . Strategy as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( agendaData ) , "::" ,
                stringify ! ( Strategy ) ));
}
impl Clone for agendaData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    
    pub fn AddActivation(arg1: *mut Environment, arg2: *mut Defrule,
                         arg3: *mut PartialMatch);
}
extern "C" {
    pub fn ClearRuleFromAgenda(arg1: *mut Environment, arg2: *mut Defrule);
}
extern "C" {
    pub fn GetNextActivation(arg1: *mut Environment, arg2: *mut Activation)
     -> *mut Activation;
}
extern "C" {
    pub fn GetActivationBasis(arg1: *mut Environment, arg2: *mut Activation)
     -> *mut partialMatch;
}
extern "C" {
    pub fn ActivationRuleName(arg1: *mut Activation)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetActivationRule(arg1: *mut Environment, arg2: *mut Activation)
     -> *mut Defrule;
}
extern "C" {
    pub fn ActivationGetSalience(arg1: *mut Activation)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ActivationSetSalience(arg1: *mut Activation,
                                 arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ActivationPPForm(arg1: *mut Activation, arg2: *mut StringBuilder);
}
extern "C" {
    pub fn GetActivationBasisPPForm(arg1: *mut Environment,
                                    arg2: *mut ::std::os::raw::c_char,
                                    arg3: usize, arg4: *mut Activation);
}
extern "C" {
    pub fn MoveActivationToTop(arg1: *mut Environment, arg2: *mut Activation)
     -> bool;
}
extern "C" {
    pub fn DeleteActivation(arg1: *mut Activation);
}
extern "C" {
    pub fn DetachActivation(arg1: *mut Environment, arg2: *mut Activation)
     -> bool;
}
extern "C" {
    pub fn DeleteAllActivations(arg1: *mut Defmodule);
}
extern "C" {
    pub fn Agenda(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char,
                  arg3: *mut Defmodule);
}
extern "C" {
    pub fn RemoveActivation(arg1: *mut Environment, arg2: *mut Activation,
                            arg3: bool, arg4: bool);
}
extern "C" {
    pub fn RemoveAllActivations(arg1: *mut Environment);
}
extern "C" {
    pub fn GetAgendaChanged(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetAgendaChanged(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn GetNumberOfActivations(arg1: *mut Environment)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn GetSalienceEvaluation(arg1: *mut Environment)
     -> SalienceEvaluationType;
}
extern "C" {
    pub fn SetSalienceEvaluation(arg1: *mut Environment,
                                 arg2: SalienceEvaluationType)
     -> SalienceEvaluationType;
}
extern "C" {
    pub fn RefreshAgenda(arg1: *mut Defmodule);
}
extern "C" {
    pub fn RefreshAllAgendas(arg1: *mut Environment);
}
extern "C" {
    pub fn ReorderAgenda(arg1: *mut Defmodule);
}
extern "C" {
    pub fn ReorderAllAgendas(arg1: *mut Environment);
}
extern "C" {
    pub fn InitializeAgenda(arg1: *mut Environment);
}
extern "C" {
    pub fn SetSalienceEvaluationCommand(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetSalienceEvaluationCommand(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn RefreshAgendaCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn RefreshCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn Refresh(arg1: *mut Defrule);
}
extern "C" {
    pub fn AgendaCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn PrintSymbolReference(arg1: *mut Environment, arg2: *mut FILE,
                                arg3: *mut CLIPSLexeme);
}
extern "C" {
    pub fn PrintFloatReference(arg1: *mut Environment, arg2: *mut FILE,
                               arg3: *mut CLIPSFloat);
}
extern "C" {
    pub fn PrintIntegerReference(arg1: *mut Environment, arg2: *mut FILE,
                                 arg3: *mut CLIPSInteger);
}
extern "C" {
    pub fn PrintBitMapReference(arg1: *mut Environment, arg2: *mut FILE,
                                arg3: *mut CLIPSBitMap);
}
extern "C" {
    pub fn AtomicValuesToCode(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: *const ::std::os::raw::c_char,
                              arg4: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CodeGeneratorItem {
    pub name: *const ::std::os::raw::c_char,
    pub beforeFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut Environment)>,
    pub initFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut Environment,
                                                                 arg2:
                                                                     *mut FILE,
                                                                 arg3:
                                                                     ::std::os::raw::c_uint,
                                                                 arg4:
                                                                     ::std::os::raw::c_uint)>,
    pub generateFunction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut Environment,
                                                                     arg2:
                                                                         *const ::std::os::raw::c_char,
                                                                     arg3:
                                                                         *const ::std::os::raw::c_char,
                                                                     arg4:
                                                                         *mut ::std::os::raw::c_char,
                                                                     arg5:
                                                                         ::std::os::raw::c_uint,
                                                                     arg6:
                                                                         *mut FILE,
                                                                     arg7:
                                                                         ::std::os::raw::c_uint,
                                                                     arg8:
                                                                         ::std::os::raw::c_uint)
                                                    -> bool>,
    pub priority: ::std::os::raw::c_int,
    pub arrayNames: *mut *mut ::std::os::raw::c_char,
    pub arrayCount: ::std::os::raw::c_uint,
    pub next: *mut CodeGeneratorItem,
}
#[test]
fn bindgen_test_layout_CodeGeneratorItem() {
    assert_eq!(::std::mem::size_of::<CodeGeneratorItem>() , 64usize , concat !
               ( "Size of: " , stringify ! ( CodeGeneratorItem ) ));
    assert_eq! (::std::mem::align_of::<CodeGeneratorItem>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CodeGeneratorItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorItem ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorItem ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorItem ) ) . beforeFunction as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorItem ) ,
                "::" , stringify ! ( beforeFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorItem ) ) . initFunction as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorItem ) ,
                "::" , stringify ! ( initFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorItem ) ) . generateFunction
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorItem ) ,
                "::" , stringify ! ( generateFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorItem ) ) . priority as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorItem ) ,
                "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorItem ) ) . arrayNames as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorItem ) ,
                "::" , stringify ! ( arrayNames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorItem ) ) . arrayCount as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorItem ) ,
                "::" , stringify ! ( arrayCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorItem ) ) . next as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorItem ) ,
                "::" , stringify ! ( next ) ));
}
impl Clone for CodeGeneratorItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct constructCompilerData {
    pub ImageID: ::std::os::raw::c_uint,
    pub HeaderFP: *mut FILE,
    pub MaxIndices: ::std::os::raw::c_uint,
    pub ExpressionFP: *mut FILE,
    pub FixupFP: *mut FILE,
    pub FilePrefix: *const ::std::os::raw::c_char,
    pub PathName: *const ::std::os::raw::c_char,
    pub FileNameBuffer: *mut ::std::os::raw::c_char,
    pub ExpressionHeader: bool,
    pub ExpressionCount: ::std::os::raw::c_ulong,
    pub ExpressionVersion: ::std::os::raw::c_uint,
    pub CodeGeneratorCount: ::std::os::raw::c_uint,
    pub ListOfCodeGeneratorItems: *mut CodeGeneratorItem,
}
#[test]
fn bindgen_test_layout_constructCompilerData() {
    assert_eq!(::std::mem::size_of::<constructCompilerData>() , 96usize ,
               concat ! ( "Size of: " , stringify ! ( constructCompilerData )
               ));
    assert_eq! (::std::mem::align_of::<constructCompilerData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( constructCompilerData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) . ImageID as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( ImageID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) . HeaderFP as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( HeaderFP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) . MaxIndices as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( MaxIndices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) . ExpressionFP
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( ExpressionFP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) . FixupFP as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( FixupFP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) . FilePrefix as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( FilePrefix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) . PathName as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( PathName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) .
                FileNameBuffer as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( FileNameBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) .
                ExpressionHeader as * const _ as usize } , 64usize , concat !
                (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( ExpressionHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) .
                ExpressionCount as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( ExpressionCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) .
                ExpressionVersion as * const _ as usize } , 80usize , concat !
                (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( ExpressionVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) .
                CodeGeneratorCount as * const _ as usize } , 84usize , concat
                ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( CodeGeneratorCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constructCompilerData ) ) .
                ListOfCodeGeneratorItems as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( constructCompilerData )
                , "::" , stringify ! ( ListOfCodeGeneratorItems ) ));
}
impl Clone for constructCompilerData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CodeGeneratorFile {
    pub filePrefix: *const ::std::os::raw::c_char,
    pub pathName: *const ::std::os::raw::c_char,
    pub fileNameBuffer: *mut ::std::os::raw::c_char,
    pub id: ::std::os::raw::c_uint,
    pub version: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CodeGeneratorFile() {
    assert_eq!(::std::mem::size_of::<CodeGeneratorFile>() , 32usize , concat !
               ( "Size of: " , stringify ! ( CodeGeneratorFile ) ));
    assert_eq! (::std::mem::align_of::<CodeGeneratorFile>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CodeGeneratorFile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorFile ) ) . filePrefix as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorFile ) ,
                "::" , stringify ! ( filePrefix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorFile ) ) . pathName as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorFile ) ,
                "::" , stringify ! ( pathName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorFile ) ) . fileNameBuffer as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorFile ) ,
                "::" , stringify ! ( fileNameBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorFile ) ) . id as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorFile ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CodeGeneratorFile ) ) . version as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CodeGeneratorFile ) ,
                "::" , stringify ! ( version ) ));
}
impl Clone for CodeGeneratorFile {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeConstructCompilerData(arg1: *mut Environment);
}
extern "C" {
    pub fn ConstructsToCCommandDefinition(arg1: *mut Environment);
}
extern "C" {
    pub fn NewCFile(arg1: *mut Environment,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: *mut ::std::os::raw::c_char,
                    arg5: ::std::os::raw::c_uint,
                    arg6: ::std::os::raw::c_uint, arg7: bool) -> *mut FILE;
}
extern "C" {
    pub fn ExpressionToCode(arg1: *mut Environment, arg2: *mut FILE,
                            arg3: *mut expr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PrintFunctionReference(arg1: *mut Environment, arg2: *mut FILE,
                                  arg3: *mut functionDefinition);
}
extern "C" {
    pub fn AddCodeGeneratorItem(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: ::std::os::raw::c_int,
                                arg4:
                                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut Environment)>,
                                arg5:
                                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut Environment,
                                                                               arg2:
                                                                                   *mut FILE,
                                                                               arg3:
                                                                                   ::std::os::raw::c_uint,
                                                                               arg4:
                                                                                   ::std::os::raw::c_uint)>,
                                arg6:
                                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut Environment,
                                                                               arg2:
                                                                                   *const ::std::os::raw::c_char,
                                                                               arg3:
                                                                                   *const ::std::os::raw::c_char,
                                                                               arg4:
                                                                                   *mut ::std::os::raw::c_char,
                                                                               arg5:
                                                                                   ::std::os::raw::c_uint,
                                                                               arg6:
                                                                                   *mut FILE,
                                                                               arg7:
                                                                                   ::std::os::raw::c_uint,
                                                                               arg8:
                                                                                   ::std::os::raw::c_uint)
                                                              -> bool>,
                                arg7: ::std::os::raw::c_uint)
     -> *mut CodeGeneratorItem;
}
extern "C" {
    pub fn CloseFileIfNeeded(arg1: *mut Environment, arg2: *mut FILE,
                             arg3: *mut ::std::os::raw::c_uint,
                             arg4: *mut ::std::os::raw::c_uint,
                             arg5: ::std::os::raw::c_uint, arg6: *mut bool,
                             arg7: *mut CodeGeneratorFile) -> *mut FILE;
}
extern "C" {
    pub fn OpenFileIfNeeded(arg1: *mut Environment, arg2: *mut FILE,
                            arg3: *const ::std::os::raw::c_char,
                            arg4: *const ::std::os::raw::c_char,
                            arg5: *mut ::std::os::raw::c_char,
                            arg6: ::std::os::raw::c_uint,
                            arg7: ::std::os::raw::c_uint,
                            arg8: *mut ::std::os::raw::c_uint,
                            arg9: ::std::os::raw::c_uint, arg10: *mut FILE,
                            arg11: *const ::std::os::raw::c_char,
                            arg12: *mut ::std::os::raw::c_char, arg13: bool,
                            arg14: *mut CodeGeneratorFile) -> *mut FILE;
}
extern "C" {
    pub fn MarkConstructBsaveIDs(arg1: *mut Environment,
                                 arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn ConstructHeaderToCode(arg1: *mut Environment, arg2: *mut FILE,
                                 arg3: *mut ConstructHeader,
                                 arg4: ::std::os::raw::c_uint,
                                 arg5: ::std::os::raw::c_uint,
                                 arg6: ::std::os::raw::c_uint,
                                 arg7: *const ::std::os::raw::c_char,
                                 arg8: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ConstructModuleToCode(arg1: *mut Environment, arg2: *mut FILE,
                                 arg3: *mut Defmodule,
                                 arg4: ::std::os::raw::c_uint,
                                 arg5: ::std::os::raw::c_uint,
                                 arg6: ::std::os::raw::c_uint,
                                 arg7: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn PrintHashedExpressionReference(arg1: *mut Environment,
                                          arg2: *mut FILE, arg3: *mut expr,
                                          arg4: ::std::os::raw::c_uint,
                                          arg5: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct constraintRecord {
    pub _bitfield_1: [u8; 3usize],
    pub bsaveIndex: ::std::os::raw::c_ushort,
    pub classList: *mut expr,
    pub restrictionList: *mut expr,
    pub minValue: *mut expr,
    pub maxValue: *mut expr,
    pub minFields: *mut expr,
    pub maxFields: *mut expr,
    pub multifield: *mut constraintRecord,
    pub next: *mut constraintRecord,
    pub bucket: ::std::os::raw::c_uint,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_constraintRecord() {
    assert_eq!(::std::mem::size_of::<constraintRecord>() , 80usize , concat !
               ( "Size of: " , stringify ! ( constraintRecord ) ));
    assert_eq! (::std::mem::align_of::<constraintRecord>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( constraintRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . bsaveIndex as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( bsaveIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . classList as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( classList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . restrictionList as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( restrictionList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . minValue as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( minValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . maxValue as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( maxValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . minFields as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( minFields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . maxFields as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( maxFields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . multifield as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( multifield ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . next as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . bucket as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintRecord ) ) . count as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintRecord ) ,
                "::" , stringify ! ( count ) ));
}
impl Clone for constraintRecord {
    fn clone(&self) -> Self { *self }
}
impl constraintRecord {
    #[inline]
    pub fn anyAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_anyAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn symbolsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_symbolsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn stringsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_stringsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn floatsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_floatsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn integersAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_integersAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn instanceNamesAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32u64 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_instanceNamesAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn instanceAddressesAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 64u64 as u32;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_instanceAddressesAllowed(&mut self,
                                        val: ::std::os::raw::c_uint) {
        let mask = 64u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn externalAddressesAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_externalAddressesAllowed(&mut self,
                                        val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn factAddressesAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 256u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_factAddressesAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 256u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn voidAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 512u64 as u32;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_voidAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 512u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn anyRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1024u64 as u32;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_anyRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1024u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn symbolRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2048u64 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_symbolRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn stringRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_stringRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn floatRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8192u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_floatRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8192u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn integerRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16384u64 as u32;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_integerRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16384u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn classRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32768u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_classRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn instanceNameRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65536u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_instanceNameRestriction(&mut self,
                                       val: ::std::os::raw::c_uint) {
        let mask = 65536u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn multifieldsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 131072u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_multifieldsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 131072u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn singlefieldsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 262144u64 as u32;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_singlefieldsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 262144u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn installed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 524288u64 as u32;
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_installed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 524288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(anyAllowed: ::std::os::raw::c_uint,
                          symbolsAllowed: ::std::os::raw::c_uint,
                          stringsAllowed: ::std::os::raw::c_uint,
                          floatsAllowed: ::std::os::raw::c_uint,
                          integersAllowed: ::std::os::raw::c_uint,
                          instanceNamesAllowed: ::std::os::raw::c_uint,
                          instanceAddressesAllowed: ::std::os::raw::c_uint,
                          externalAddressesAllowed: ::std::os::raw::c_uint,
                          factAddressesAllowed: ::std::os::raw::c_uint,
                          voidAllowed: ::std::os::raw::c_uint,
                          anyRestriction: ::std::os::raw::c_uint,
                          symbolRestriction: ::std::os::raw::c_uint,
                          stringRestriction: ::std::os::raw::c_uint,
                          floatRestriction: ::std::os::raw::c_uint,
                          integerRestriction: ::std::os::raw::c_uint,
                          classRestriction: ::std::os::raw::c_uint,
                          instanceNameRestriction: ::std::os::raw::c_uint,
                          multifieldsAllowed: ::std::os::raw::c_uint,
                          singlefieldsAllowed: ::std::os::raw::c_uint,
                          installed: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              ({
                                                                                   ({
                                                                                        ({
                                                                                             ({
                                                                                                  ({
                                                                                                       ({
                                                                                                            0
                                                                                                        }
                                                                                                            |
                                                                                                            ((anyAllowed
                                                                                                                  as
                                                                                                                  u32
                                                                                                                  as
                                                                                                                  u32)
                                                                                                                 <<
                                                                                                                 0usize)
                                                                                                                &
                                                                                                                (1u64
                                                                                                                     as
                                                                                                                     u32))
                                                                                                   }
                                                                                                       |
                                                                                                       ((symbolsAllowed
                                                                                                             as
                                                                                                             u32
                                                                                                             as
                                                                                                             u32)
                                                                                                            <<
                                                                                                            1usize)
                                                                                                           &
                                                                                                           (2u64
                                                                                                                as
                                                                                                                u32))
                                                                                              }
                                                                                                  |
                                                                                                  ((stringsAllowed
                                                                                                        as
                                                                                                        u32
                                                                                                        as
                                                                                                        u32)
                                                                                                       <<
                                                                                                       2usize)
                                                                                                      &
                                                                                                      (4u64
                                                                                                           as
                                                                                                           u32))
                                                                                         }
                                                                                             |
                                                                                             ((floatsAllowed
                                                                                                   as
                                                                                                   u32
                                                                                                   as
                                                                                                   u32)
                                                                                                  <<
                                                                                                  3usize)
                                                                                                 &
                                                                                                 (8u64
                                                                                                      as
                                                                                                      u32))
                                                                                    }
                                                                                        |
                                                                                        ((integersAllowed
                                                                                              as
                                                                                              u32
                                                                                              as
                                                                                              u32)
                                                                                             <<
                                                                                             4usize)
                                                                                            &
                                                                                            (16u64
                                                                                                 as
                                                                                                 u32))
                                                                               }
                                                                                   |
                                                                                   ((instanceNamesAllowed
                                                                                         as
                                                                                         u32
                                                                                         as
                                                                                         u32)
                                                                                        <<
                                                                                        5usize)
                                                                                       &
                                                                                       (32u64
                                                                                            as
                                                                                            u32))
                                                                          } |
                                                                              ((instanceAddressesAllowed
                                                                                    as
                                                                                    u32
                                                                                    as
                                                                                    u32)
                                                                                   <<
                                                                                   6usize)
                                                                                  &
                                                                                  (64u64
                                                                                       as
                                                                                       u32))
                                                                     } |
                                                                         ((externalAddressesAllowed
                                                                               as
                                                                               u32
                                                                               as
                                                                               u32)
                                                                              <<
                                                                              7usize)
                                                                             &
                                                                             (128u64
                                                                                  as
                                                                                  u32))
                                                                } |
                                                                    ((factAddressesAllowed
                                                                          as
                                                                          u32
                                                                          as
                                                                          u32)
                                                                         <<
                                                                         8usize)
                                                                        &
                                                                        (256u64
                                                                             as
                                                                             u32))
                                                           } |
                                                               ((voidAllowed
                                                                     as u32 as
                                                                     u32) <<
                                                                    9usize) &
                                                                   (512u64 as
                                                                        u32))
                                                      } |
                                                          ((anyRestriction as
                                                                u32 as u32) <<
                                                               10usize) &
                                                              (1024u64 as
                                                                   u32))
                                                 } |
                                                     ((symbolRestriction as
                                                           u32 as u32) <<
                                                          11usize) &
                                                         (2048u64 as u32))
                                            } |
                                                ((stringRestriction as u32 as
                                                      u32) << 12usize) &
                                                    (4096u64 as u32))
                                       } |
                                           ((floatRestriction as u32 as u32)
                                                << 13usize) &
                                               (8192u64 as u32))
                                  } |
                                      ((integerRestriction as u32 as u32) <<
                                           14usize) & (16384u64 as u32))
                             } |
                                 ((classRestriction as u32 as u32) << 15usize)
                                     & (32768u64 as u32))
                        } |
                            ((instanceNameRestriction as u32 as u32) <<
                                 16usize) & (65536u64 as u32))
                   } |
                       ((multifieldsAllowed as u32 as u32) << 17usize) &
                           (131072u64 as u32))
              } |
                  ((singlefieldsAllowed as u32 as u32) << 18usize) &
                      (262144u64 as u32))
         } | ((installed as u32 as u32) << 19usize) & (524288u64 as u32))
    }
}
pub type CONSTRAINT_RECORD = constraintRecord;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct constraintData {
    pub ConstraintHashtable: *mut *mut constraintRecord,
    pub DynamicConstraintChecking: bool,
    pub ConstraintArray: *mut constraintRecord,
    pub NumberOfConstraints: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_constraintData() {
    assert_eq!(::std::mem::size_of::<constraintData>() , 32usize , concat ! (
               "Size of: " , stringify ! ( constraintData ) ));
    assert_eq! (::std::mem::align_of::<constraintData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( constraintData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintData ) ) . ConstraintHashtable
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintData ) , "::"
                , stringify ! ( ConstraintHashtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintData ) ) .
                DynamicConstraintChecking as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( constraintData ) , "::"
                , stringify ! ( DynamicConstraintChecking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintData ) ) . ConstraintArray as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintData ) , "::"
                , stringify ! ( ConstraintArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const constraintData ) ) . NumberOfConstraints
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( constraintData ) , "::"
                , stringify ! ( NumberOfConstraints ) ));
}
impl Clone for constraintData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeConstraints(arg1: *mut Environment);
}
extern "C" {
    pub fn GDCCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn SDCCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetDynamicConstraintChecking(arg1: *mut Environment, arg2: bool)
     -> bool;
}
extern "C" {
    pub fn GetDynamicConstraintChecking(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn HashConstraint(arg1: *mut constraintRecord)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn AddConstraint(arg1: *mut Environment, arg2: *mut constraintRecord)
     -> *mut constraintRecord;
}
extern "C" {
    pub fn RemoveConstraint(arg1: *mut Environment,
                            arg2: *mut constraintRecord);
}
pub type ConstructGetWatchFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
pub type ConstructSetWatchFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: bool)>;
pub type ConstructActionFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: *mut ConstructHeader,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn AddConstructToModule(arg1: *mut ConstructHeader);
}
extern "C" {
    pub fn DeleteNamedConstruct(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: *mut Construct) -> bool;
}
extern "C" {
    pub fn FindNamedConstructInModule(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3: *mut Construct)
     -> *mut ConstructHeader;
}
extern "C" {
    pub fn FindNamedConstructInModuleOrImports(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3: *mut Construct)
     -> *mut ConstructHeader;
}
extern "C" {
    pub fn UndefconstructCommand(arg1: *mut UDFContext,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut Construct);
}
extern "C" {
    pub fn PPConstruct(arg1: *mut Environment,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *const ::std::os::raw::c_char,
                       arg4: *mut Construct) -> bool;
}
extern "C" {
    pub fn GetConstructModuleCommand(arg1: *mut UDFContext,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: *mut Construct)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn GetConstructModule(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: *mut Construct) -> *mut Defmodule;
}
extern "C" {
    pub fn Undefconstruct(arg1: *mut Environment, arg2: *mut ConstructHeader,
                          arg3: *mut Construct) -> bool;
}
extern "C" {
    pub fn UndefconstructAll(arg1: *mut Environment, arg2: *mut Construct)
     -> bool;
}
extern "C" {
    pub fn SaveConstruct(arg1: *mut Environment, arg2: *mut Defmodule,
                         arg3: *const ::std::os::raw::c_char,
                         arg4: *mut Construct);
}
extern "C" {
    pub fn GetConstructNameString(arg1: *mut ConstructHeader)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetConstructModuleName(arg1: *mut ConstructHeader)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetConstructNamePointer(arg1: *mut ConstructHeader)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn GetConstructListFunction(arg1: *mut UDFContext,
                                    arg2: *mut UDFValue,
                                    arg3: *mut Construct);
}
extern "C" {
    pub fn GetConstructList(arg1: *mut Environment, arg2: *mut UDFValue,
                            arg3: *mut Construct, arg4: *mut Defmodule);
}
extern "C" {
    pub fn ListConstructCommand(arg1: *mut UDFContext, arg2: *mut Construct);
}
extern "C" {
    pub fn ListConstruct(arg1: *mut Environment, arg2: *mut Construct,
                         arg3: *const ::std::os::raw::c_char,
                         arg4: *mut Defmodule);
}
extern "C" {
    pub fn SetNextConstruct(arg1: *mut ConstructHeader,
                            arg2: *mut ConstructHeader);
}
extern "C" {
    pub fn GetConstructModuleItem(arg1: *mut ConstructHeader)
     -> *mut defmoduleItemHeader;
}
extern "C" {
    pub fn GetConstructPPForm(arg1: *mut ConstructHeader)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn PPConstructCommand(arg1: *mut UDFContext,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: *mut Construct);
}
extern "C" {
    pub fn GetNextConstructItem(arg1: *mut Environment,
                                arg2: *mut ConstructHeader,
                                arg3: ::std::os::raw::c_uint)
     -> *mut ConstructHeader;
}
extern "C" {
    pub fn GetConstructModuleItemByIndex(arg1: *mut Environment,
                                         arg2: *mut Defmodule,
                                         arg3: ::std::os::raw::c_uint)
     -> *mut defmoduleItemHeader;
}
extern "C" {
    pub fn FreeConstructHeaderModule(arg1: *mut Environment,
                                     arg2: *mut defmoduleItemHeader,
                                     arg3: *mut Construct);
}
extern "C" {
    pub fn DoForAllConstructs(arg1: *mut Environment,
                              arg2: ConstructActionFunction,
                              arg3: ::std::os::raw::c_uint, arg4: bool,
                              arg5: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn DoForAllConstructsInModule(arg1: *mut Environment,
                                      arg2: *mut Defmodule,
                                      arg3: ConstructActionFunction,
                                      arg4: ::std::os::raw::c_uint,
                                      arg5: bool,
                                      arg6: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn InitializeConstructHeader(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: ConstructType,
                                     arg4: *mut ConstructHeader,
                                     arg5: *mut CLIPSLexeme);
}
extern "C" {
    pub fn SetConstructPPForm(arg1: *mut Environment,
                              arg2: *mut ConstructHeader,
                              arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn LookupConstruct(arg1: *mut Environment, arg2: *mut Construct,
                           arg3: *const ::std::os::raw::c_char, arg4: bool)
     -> *mut ConstructHeader;
}
extern "C" {
    pub fn ConstructPrintWatchAccess(arg1: *mut Environment,
                                     arg2: *mut Construct,
                                     arg3: *const ::std::os::raw::c_char,
                                     arg4: *mut Expression,
                                     arg5: ConstructGetWatchFunction,
                                     arg6: ConstructSetWatchFunction) -> bool;
}
extern "C" {
    pub fn ConstructSetWatchAccess(arg1: *mut Environment,
                                   arg2: *mut Construct, arg3: bool,
                                   arg4: *mut Expression,
                                   arg5: ConstructGetWatchFunction,
                                   arg6: ConstructSetWatchFunction) -> bool;
}
extern "C" {
    pub fn ConstructsDeletable(arg1: *mut Environment) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defruleData {
    pub DefruleConstruct: *mut Construct,
    pub DefruleModuleIndex: ::std::os::raw::c_uint,
    pub CurrentEntityTimeTag: ::std::os::raw::c_ulonglong,
    pub AlphaMemoryTable: *mut *mut alphaMemoryHash,
    pub BetaMemoryResizingFlag: bool,
    pub RightPrimeJoins: *mut joinLink,
    pub LeftPrimeJoins: *mut joinLink,
    pub WatchRules: bool,
    pub DeletedRuleDebugFlags: ::std::os::raw::c_int,
    pub DefruleCodeItem: *mut CodeGeneratorItem,
}
#[test]
fn bindgen_test_layout_defruleData() {
    assert_eq!(::std::mem::size_of::<defruleData>() , 72usize , concat ! (
               "Size of: " , stringify ! ( defruleData ) ));
    assert_eq! (::std::mem::align_of::<defruleData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defruleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . DefruleConstruct as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( DefruleConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . DefruleModuleIndex as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( DefruleModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . CurrentEntityTimeTag as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( CurrentEntityTimeTag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . AlphaMemoryTable as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( AlphaMemoryTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . BetaMemoryResizingFlag
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( BetaMemoryResizingFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . RightPrimeJoins as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( RightPrimeJoins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . LeftPrimeJoins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( LeftPrimeJoins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . WatchRules as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( WatchRules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . DeletedRuleDebugFlags
                as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( DeletedRuleDebugFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defruleData ) ) . DefruleCodeItem as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( defruleData ) , "::" ,
                stringify ! ( DefruleCodeItem ) ));
}
impl Clone for defruleData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeDefrules(arg1: *mut Environment);
}
extern "C" {
    pub fn FindDefrule(arg1: *mut Environment,
                       arg2: *const ::std::os::raw::c_char) -> *mut Defrule;
}
extern "C" {
    pub fn FindDefruleInModule(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char)
     -> *mut Defrule;
}
extern "C" {
    pub fn GetNextDefrule(arg1: *mut Environment, arg2: *mut Defrule)
     -> *mut Defrule;
}
extern "C" {
    pub fn GetDefruleModuleItem(arg1: *mut Environment, arg2: *mut Defmodule)
     -> *mut defruleModule;
}
extern "C" {
    pub fn DefruleIsDeletable(arg1: *mut Defrule) -> bool;
}
extern "C" {
    pub fn AddBetaMemoriesToJoin(arg1: *mut Environment, arg2: *mut joinNode);
}
extern "C" {
    pub fn GetDisjunctCount(arg1: *mut Environment, arg2: *mut Defrule)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn GetNthDisjunct(arg1: *mut Environment, arg2: *mut Defrule,
                          arg3: ::std::os::raw::c_long) -> *mut Defrule;
}
extern "C" {
    pub fn DefruleModule(arg1: *mut Defrule) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefruleName(arg1: *mut Defrule) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefrulePPForm(arg1: *mut Defrule) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefruleBasicCommands(arg1: *mut Environment);
}
extern "C" {
    pub fn UndefruleCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn Undefrule(arg1: *mut Defrule, arg2: *mut Environment) -> bool;
}
extern "C" {
    pub fn GetDefruleListFunction(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefruleList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                          arg3: *mut Defmodule);
}
extern "C" {
    pub fn DefruleModuleFunction(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDefruleCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDefrule(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn ListDefrulesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefrules(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut Defmodule);
}
extern "C" {
    pub fn DefruleGetWatchFirings(arg1: *mut Defrule) -> bool;
}
extern "C" {
    pub fn DefruleGetWatchActivations(arg1: *mut Defrule) -> bool;
}
extern "C" {
    pub fn DefruleSetWatchFirings(arg1: *mut Defrule, arg2: bool);
}
extern "C" {
    pub fn DefruleSetWatchActivations(arg1: *mut Defrule, arg2: bool);
}
extern "C" {
    pub fn DefruleWatchAccess(arg1: *mut Environment,
                              arg2: ::std::os::raw::c_int, arg3: bool,
                              arg4: *mut expr) -> bool;
}
extern "C" {
    pub fn DefruleWatchPrint(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: ::std::os::raw::c_int, arg4: *mut expr)
     -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct focalModule {
    pub theModule: *mut Defmodule,
    pub theDefruleModule: *mut defruleModule,
    pub next: *mut FocalModule,
}
#[test]
fn bindgen_test_layout_focalModule() {
    assert_eq!(::std::mem::size_of::<focalModule>() , 24usize , concat ! (
               "Size of: " , stringify ! ( focalModule ) ));
    assert_eq! (::std::mem::align_of::<focalModule>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( focalModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const focalModule ) ) . theModule as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( focalModule ) , "::" ,
                stringify ! ( theModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const focalModule ) ) . theDefruleModule as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( focalModule ) , "::" ,
                stringify ! ( theDefruleModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const focalModule ) ) . next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( focalModule ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for focalModule {
    fn clone(&self) -> Self { *self }
}
pub type FocalModule = focalModule;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dependency {
    pub dPtr: *mut ::std::os::raw::c_void,
    pub next: *mut dependency,
}
#[test]
fn bindgen_test_layout_dependency() {
    assert_eq!(::std::mem::size_of::<dependency>() , 16usize , concat ! (
               "Size of: " , stringify ! ( dependency ) ));
    assert_eq! (::std::mem::align_of::<dependency>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dependency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dependency ) ) . dPtr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dependency ) , "::" ,
                stringify ! ( dPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dependency ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dependency ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for dependency {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn AddLogicalDependencies(arg1: *mut Environment,
                                  arg2: *mut PatternEntity, arg3: bool)
     -> bool;
}
extern "C" {
    pub fn RemoveEntityDependencies(arg1: *mut Environment,
                                    arg2: *mut PatternEntity);
}
extern "C" {
    pub fn RemovePMDependencies(arg1: *mut Environment,
                                arg2: *mut PartialMatch);
}
extern "C" {
    pub fn DestroyPMDependencies(arg1: *mut Environment,
                                 arg2: *mut PartialMatch);
}
extern "C" {
    pub fn RemoveLogicalSupport(arg1: *mut Environment,
                                arg2: *mut PartialMatch);
}
extern "C" {
    pub fn ForceLogicalRetractions(arg1: *mut Environment);
}
extern "C" {
    pub fn Dependencies(arg1: *mut Environment, arg2: *mut PatternEntity);
}
extern "C" {
    pub fn Dependents(arg1: *mut Environment, arg2: *mut PatternEntity);
}
extern "C" {
    pub fn DependenciesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn DependentsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn ReturnEntityDependencies(arg1: *mut Environment,
                                    arg2: *mut PatternEntity);
}
extern "C" {
    pub fn FindLogicalBind(arg1: *mut joinNode, arg2: *mut PartialMatch)
     -> *mut PartialMatch;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rdriveinfo {
    pub link: *mut partialMatch,
    pub jlist: *mut joinNode,
    pub next: *mut rdriveinfo,
}
#[test]
fn bindgen_test_layout_rdriveinfo() {
    assert_eq!(::std::mem::size_of::<rdriveinfo>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rdriveinfo ) ));
    assert_eq! (::std::mem::align_of::<rdriveinfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rdriveinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdriveinfo ) ) . link as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rdriveinfo ) , "::" ,
                stringify ! ( link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdriveinfo ) ) . jlist as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rdriveinfo ) , "::" ,
                stringify ! ( jlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdriveinfo ) ) . next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rdriveinfo ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for rdriveinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn NetworkRetract(arg1: *mut Environment, arg2: *mut patternMatch);
}
extern "C" {
    pub fn ReturnPartialMatch(arg1: *mut Environment,
                              arg2: *mut partialMatch);
}
extern "C" {
    pub fn DestroyPartialMatch(arg1: *mut Environment,
                               arg2: *mut partialMatch);
}
extern "C" {
    pub fn FlushGarbagePartialMatches(arg1: *mut Environment);
}
extern "C" {
    pub fn DeletePartialMatches(arg1: *mut Environment,
                                arg2: *mut partialMatch);
}
extern "C" {
    pub fn PosEntryRetractBeta(arg1: *mut Environment,
                               arg2: *mut partialMatch,
                               arg3: *mut partialMatch,
                               arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PosEntryRetractAlpha(arg1: *mut Environment,
                                arg2: *mut partialMatch,
                                arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PartialMatchWillBeDeleted(arg1: *mut Environment,
                                     arg2: *mut partialMatch) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ruleFiredFunctionItem {
    pub name: *const ::std::os::raw::c_char,
    pub func: RuleFiredFunction,
    pub priority: ::std::os::raw::c_int,
    pub next: *mut RuleFiredFunctionItem,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ruleFiredFunctionItem() {
    assert_eq!(::std::mem::size_of::<ruleFiredFunctionItem>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( ruleFiredFunctionItem )
               ));
    assert_eq! (::std::mem::align_of::<ruleFiredFunctionItem>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ruleFiredFunctionItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ruleFiredFunctionItem ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ruleFiredFunctionItem )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ruleFiredFunctionItem ) ) . func as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ruleFiredFunctionItem )
                , "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ruleFiredFunctionItem ) ) . priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ruleFiredFunctionItem )
                , "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ruleFiredFunctionItem ) ) . next as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ruleFiredFunctionItem )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ruleFiredFunctionItem ) ) . context as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ruleFiredFunctionItem )
                , "::" , stringify ! ( context ) ));
}
impl Clone for ruleFiredFunctionItem {
    fn clone(&self) -> Self { *self }
}
pub type RuleFiredFunctionItem = ruleFiredFunctionItem;
pub type RuleFiredFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: *mut Activation,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct engineData {
    pub ExecutingRule: *mut Defrule,
    pub HaltRules: bool,
    pub TheLogicalJoin: *mut joinNode,
    pub TheLogicalBind: *mut partialMatch,
    pub UnsupportedDataEntities: *mut dependency,
    pub alreadyEntered: bool,
    pub ListOfAfterRuleFiresFunctions: *mut RuleFiredFunctionItem,
    pub ListOfBeforeRuleFiresFunctions: *mut RuleFiredFunctionItem,
    pub CurrentFocus: *mut FocalModule,
    pub FocusChanged: bool,
    pub WatchStatistics: bool,
    pub WatchFocus: bool,
    pub IncrementalResetInProgress: bool,
    pub JoinOperationInProgress: bool,
    pub GlobalLHSBinds: *mut partialMatch,
    pub GlobalRHSBinds: *mut partialMatch,
    pub GlobalJoin: *mut joinNode,
    pub GarbagePartialMatches: *mut partialMatch,
    pub GarbageAlphaMatches: *mut alphaMatch,
    pub AlreadyRunning: bool,
}
#[test]
fn bindgen_test_layout_engineData() {
    assert_eq!(::std::mem::size_of::<engineData>() , 128usize , concat ! (
               "Size of: " , stringify ! ( engineData ) ));
    assert_eq! (::std::mem::align_of::<engineData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( engineData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . ExecutingRule as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( ExecutingRule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . HaltRules as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( HaltRules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . TheLogicalJoin as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( TheLogicalJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . TheLogicalBind as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( TheLogicalBind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . UnsupportedDataEntities
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( UnsupportedDataEntities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . alreadyEntered as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( alreadyEntered ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) .
                ListOfAfterRuleFiresFunctions as * const _ as usize } ,
                48usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( ListOfAfterRuleFiresFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) .
                ListOfBeforeRuleFiresFunctions as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( ListOfBeforeRuleFiresFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . CurrentFocus as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( CurrentFocus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . FocusChanged as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( FocusChanged ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . WatchStatistics as *
                const _ as usize } , 73usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( WatchStatistics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . WatchFocus as * const _
                as usize } , 74usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( WatchFocus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) .
                IncrementalResetInProgress as * const _ as usize } , 75usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( IncrementalResetInProgress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . JoinOperationInProgress
                as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( JoinOperationInProgress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . GlobalLHSBinds as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( GlobalLHSBinds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . GlobalRHSBinds as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( GlobalRHSBinds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . GlobalJoin as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( GlobalJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . GarbagePartialMatches as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( GarbagePartialMatches ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . GarbageAlphaMatches as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( GarbageAlphaMatches ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const engineData ) ) . AlreadyRunning as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( engineData ) , "::" ,
                stringify ! ( AlreadyRunning ) ));
}
impl Clone for engineData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn Run(arg1: *mut Environment, arg2: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn AddAfterRuleFiresFunction(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: RuleFiredFunction,
                                     arg4: ::std::os::raw::c_int,
                                     arg5: *mut ::std::os::raw::c_void)
     -> bool;
}
extern "C" {
    pub fn RemoveAfterRuleFiresFunction(arg1: *mut Environment,
                                        arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn AddBeforeRuleFiresFunction(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3: RuleFiredFunction,
                                      arg4: ::std::os::raw::c_int,
                                      arg5: *mut ::std::os::raw::c_void)
     -> bool;
}
extern "C" {
    pub fn RemoveBeforeRuleFiresFunction(arg1: *mut Environment,
                                         arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn AddRuleFiredFunctionToCallList(arg1: *mut Environment,
                                          arg2: *const ::std::os::raw::c_char,
                                          arg3: ::std::os::raw::c_int,
                                          arg4: RuleFiredFunction,
                                          arg5: *mut RuleFiredFunctionItem,
                                          arg6: *mut ::std::os::raw::c_void)
     -> *mut RuleFiredFunctionItem;
}
extern "C" {
    pub fn RemoveRuleFiredFunctionFromCallList(arg1: *mut Environment,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3:
                                                   *mut RuleFiredFunctionItem,
                                               arg4: *mut bool)
     -> *mut RuleFiredFunctionItem;
}
extern "C" {
    pub fn DeallocateRuleFiredCallList(arg1: *mut Environment,
                                       arg2: *mut RuleFiredFunctionItem);
}
extern "C" {
    pub fn InitializeEngine(arg1: *mut Environment);
}
extern "C" {
    pub fn SetBreak(arg1: *mut Defrule);
}
extern "C" {
    pub fn Halt(arg1: *mut Environment);
}
extern "C" {
    pub fn RemoveBreak(arg1: *mut Defrule) -> bool;
}
extern "C" {
    pub fn RemoveAllBreakpoints(arg1: *mut Environment);
}
extern "C" {
    pub fn ShowBreaks(arg1: *mut Environment,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: *mut Defmodule);
}
extern "C" {
    pub fn DefruleHasBreakpoint(arg1: *mut Defrule) -> bool;
}
extern "C" {
    pub fn RunCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetBreakCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn RemoveBreakCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn ShowBreaksCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn HaltCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn FocusCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClearFocusStackCommand(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClearFocusStack(arg1: *mut Environment);
}
extern "C" {
    pub fn GetNextFocus(arg1: *mut Environment, arg2: *mut FocalModule)
     -> *mut FocalModule;
}
extern "C" {
    pub fn FocalModuleName(arg1: *mut FocalModule)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FocalModuleModule(arg1: *mut FocalModule) -> *mut Defmodule;
}
extern "C" {
    pub fn Focus(arg1: *mut Defmodule);
}
extern "C" {
    pub fn GetFocusChanged(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetFocusChanged(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn ListFocusStackCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListFocusStack(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn GetFocusStackFunction(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetFocusStack(arg1: *mut Environment, arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn PopFocusFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn PopFocus(arg1: *mut Environment) -> *mut Defmodule;
}
extern "C" {
    pub fn GetHaltRules(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetHaltRules(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn NextActivationToFire(arg1: *mut Environment) -> *mut Activation;
}
extern "C" {
    pub fn NetworkAssert(arg1: *mut Environment, arg2: *mut partialMatch,
                         arg3: *mut joinNode);
}
extern "C" {
    pub fn EvaluateJoinExpression(arg1: *mut Environment, arg2: *mut expr,
                                  arg3: *mut joinNode) -> bool;
}
extern "C" {
    pub fn NetworkAssertLeft(arg1: *mut Environment, arg2: *mut partialMatch,
                             arg3: *mut joinNode,
                             arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NetworkAssertRight(arg1: *mut Environment, arg2: *mut partialMatch,
                              arg3: *mut joinNode,
                              arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PPDrive(arg1: *mut Environment, arg2: *mut partialMatch,
                   arg3: *mut partialMatch, arg4: *mut joinNode,
                   arg5: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BetaMemoryHashValue(arg1: *mut Environment, arg2: *mut expr,
                               arg3: *mut partialMatch,
                               arg4: *mut partialMatch, arg5: *mut joinNode)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn EvaluateSecondaryNetworkTest(arg1: *mut Environment,
                                        arg2: *mut partialMatch,
                                        arg3: *mut joinNode) -> bool;
}
extern "C" {
    pub fn EPMDrive(arg1: *mut Environment, arg2: *mut partialMatch,
                    arg3: *mut joinNode, arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn IncrementalReset(arg1: *mut Environment, arg2: *mut Defrule);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct joinInformation {
    pub whichCE: ::std::os::raw::c_ushort,
    pub theJoin: *mut joinNode,
    pub patternBegin: ::std::os::raw::c_int,
    pub patternEnd: ::std::os::raw::c_int,
    pub marked: ::std::os::raw::c_int,
    pub theMemory: *mut betaMemory,
    pub nextJoin: *mut joinNode,
}
#[test]
fn bindgen_test_layout_joinInformation() {
    assert_eq!(::std::mem::size_of::<joinInformation>() , 48usize , concat ! (
               "Size of: " , stringify ! ( joinInformation ) ));
    assert_eq! (::std::mem::align_of::<joinInformation>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( joinInformation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinInformation ) ) . whichCE as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( joinInformation ) ,
                "::" , stringify ! ( whichCE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinInformation ) ) . theJoin as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( joinInformation ) ,
                "::" , stringify ! ( theJoin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinInformation ) ) . patternBegin as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( joinInformation ) ,
                "::" , stringify ! ( patternBegin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinInformation ) ) . patternEnd as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( joinInformation ) ,
                "::" , stringify ! ( patternEnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinInformation ) ) . marked as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( joinInformation ) ,
                "::" , stringify ! ( marked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinInformation ) ) . theMemory as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( joinInformation ) ,
                "::" , stringify ! ( theMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const joinInformation ) ) . nextJoin as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( joinInformation ) ,
                "::" , stringify ! ( nextJoin ) ));
}
impl Clone for joinInformation {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Verbosity { VERBOSE = 0, SUCCINCT = 1, TERSE = 2, }
extern "C" {
    pub fn GetBetaMemoryResizing(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetBetaMemoryResizing(arg1: *mut Environment, arg2: bool) -> bool;
}
extern "C" {
    pub fn GetBetaMemoryResizingCommand(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetBetaMemoryResizingCommand(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn Matches(arg1: *mut Defrule, arg2: Verbosity,
                   arg3: *mut CLIPSValue);
}
extern "C" {
    pub fn JoinActivity(arg1: *mut Environment, arg2: *mut Defrule,
                        arg3: ::std::os::raw::c_int, arg4: *mut UDFValue);
}
extern "C" {
    pub fn DefruleCommands(arg1: *mut Environment);
}
extern "C" {
    pub fn MatchesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn JoinActivityCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn TimetagFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn AlphaJoinCount(arg1: *mut Environment, arg2: *mut Defrule)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn BetaJoinCount(arg1: *mut Environment, arg2: *mut Defrule)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn CreateJoinArray(arg1: *mut Environment,
                           arg2: ::std::os::raw::c_ushort)
     -> *mut joinInformation;
}
extern "C" {
    pub fn FreeJoinArray(arg1: *mut Environment, arg2: *mut joinInformation,
                         arg3: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn AlphaJoins(arg1: *mut Environment, arg2: *mut Defrule,
                      arg3: ::std::os::raw::c_ushort,
                      arg4: *mut joinInformation);
}
extern "C" {
    pub fn BetaJoins(arg1: *mut Environment, arg2: *mut Defrule,
                     arg3: ::std::os::raw::c_ushort,
                     arg4: *mut joinInformation);
}
extern "C" {
    pub fn JoinActivityResetCommand(arg1: *mut Environment,
                                    arg2: *mut UDFContext,
                                    arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetFocusFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetFocus(arg1: *mut Environment) -> *mut Defmodule;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deffacts {
    pub header: ConstructHeader,
    pub assertList: *mut expr,
}
#[test]
fn bindgen_test_layout_deffacts() {
    assert_eq!(::std::mem::size_of::<deffacts>() , 72usize , concat ! (
               "Size of: " , stringify ! ( deffacts ) ));
    assert_eq! (::std::mem::align_of::<deffacts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( deffacts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffacts ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( deffacts ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffacts ) ) . assertList as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( deffacts ) , "::" ,
                stringify ! ( assertList ) ));
}
impl Clone for deffacts {
    fn clone(&self) -> Self { *self }
}
pub type Deffacts = deffacts;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deffactsData {
    pub DeffactsConstruct: *mut Construct,
    pub DeffactsModuleIndex: ::std::os::raw::c_uint,
    pub DeffactsCodeItem: *mut CodeGeneratorItem,
}
#[test]
fn bindgen_test_layout_deffactsData() {
    assert_eq!(::std::mem::size_of::<deffactsData>() , 24usize , concat ! (
               "Size of: " , stringify ! ( deffactsData ) ));
    assert_eq! (::std::mem::align_of::<deffactsData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( deffactsData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffactsData ) ) . DeffactsConstruct as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( deffactsData ) , "::" ,
                stringify ! ( DeffactsConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffactsData ) ) . DeffactsModuleIndex as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( deffactsData ) , "::" ,
                stringify ! ( DeffactsModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffactsData ) ) . DeffactsCodeItem as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( deffactsData ) , "::" ,
                stringify ! ( DeffactsCodeItem ) ));
}
impl Clone for deffactsData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deffactsModule {
    pub header: defmoduleItemHeader,
}
#[test]
fn bindgen_test_layout_deffactsModule() {
    assert_eq!(::std::mem::size_of::<deffactsModule>() , 24usize , concat ! (
               "Size of: " , stringify ! ( deffactsModule ) ));
    assert_eq! (::std::mem::align_of::<deffactsModule>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( deffactsModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffactsModule ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( deffactsModule ) , "::"
                , stringify ! ( header ) ));
}
impl Clone for deffactsModule {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeDeffacts(arg1: *mut Environment);
}
extern "C" {
    pub fn FindDeffacts(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char) -> *mut Deffacts;
}
extern "C" {
    pub fn FindDeffactsInModule(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char)
     -> *mut Deffacts;
}
extern "C" {
    pub fn GetNextDeffacts(arg1: *mut Environment, arg2: *mut Deffacts)
     -> *mut Deffacts;
}
extern "C" {
    pub fn CreateInitialFactDeffacts();
}
extern "C" {
    pub fn DeffactsIsDeletable(arg1: *mut Deffacts) -> bool;
}
extern "C" {
    pub fn GetDeffactsModuleItem(arg1: *mut Environment, arg2: *mut Defmodule)
     -> *mut deffactsModule;
}
extern "C" {
    pub fn DeffactsModule(arg1: *mut Deffacts)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DeffactsName(arg1: *mut Deffacts) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DeffactsPPForm(arg1: *mut Deffacts)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DeffactsBasicCommands(arg1: *mut Environment);
}
extern "C" {
    pub fn UndeffactsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn Undeffacts(arg1: *mut Deffacts, arg2: *mut Environment) -> bool;
}
extern "C" {
    pub fn GetDeffactsListFunction(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDeffactsList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                           arg3: *mut Defmodule);
}
extern "C" {
    pub fn DeffactsModuleFunction(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDeffactsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDeffacts(arg1: *mut Environment,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn ListDeffactsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDeffacts(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut Defmodule);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deftemplate {
    pub header: ConstructHeader,
    pub slotList: *mut templateSlot,
    pub _bitfield_1: u8,
    pub numberOfSlots: ::std::os::raw::c_ushort,
    pub busyCount: ::std::os::raw::c_long,
    pub patternNetwork: *mut factPatternNode,
    pub factList: *mut Fact,
    pub lastFact: *mut Fact,
}
#[test]
fn bindgen_test_layout_deftemplate() {
    assert_eq!(::std::mem::size_of::<deftemplate>() , 112usize , concat ! (
               "Size of: " , stringify ! ( deftemplate ) ));
    assert_eq! (::std::mem::align_of::<deftemplate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( deftemplate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplate ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplate ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplate ) ) . slotList as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplate ) , "::" ,
                stringify ! ( slotList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplate ) ) . numberOfSlots as *
                const _ as usize } , 74usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplate ) , "::" ,
                stringify ! ( numberOfSlots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplate ) ) . busyCount as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplate ) , "::" ,
                stringify ! ( busyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplate ) ) . patternNetwork as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplate ) , "::" ,
                stringify ! ( patternNetwork ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplate ) ) . factList as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplate ) , "::" ,
                stringify ! ( factList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplate ) ) . lastFact as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplate ) , "::" ,
                stringify ! ( lastFact ) ));
}
impl Clone for deftemplate {
    fn clone(&self) -> Self { *self }
}
impl deftemplate {
    #[inline]
    pub fn implied(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_implied(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn watch(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_watch(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn inScope(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inScope(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(implied: ::std::os::raw::c_uint,
                          watch: ::std::os::raw::c_uint,
                          inScope: ::std::os::raw::c_uint) -> u8 {
        ({
             ({ ({ 0 } | ((implied as u32 as u8) << 0usize) & (1u64 as u8)) }
                  | ((watch as u32 as u8) << 1usize) & (2u64 as u8))
         } | ((inScope as u32 as u8) << 2usize) & (4u64 as u8))
    }
}
pub type Deftemplate = deftemplate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct templateSlot {
    pub slotName: *mut CLIPSLexeme,
    pub _bitfield_1: u8,
    pub constraints: *mut CONSTRAINT_RECORD,
    pub defaultList: *mut Expression,
    pub facetList: *mut Expression,
    pub next: *mut templateSlot,
}
#[test]
fn bindgen_test_layout_templateSlot() {
    assert_eq!(::std::mem::size_of::<templateSlot>() , 48usize , concat ! (
               "Size of: " , stringify ! ( templateSlot ) ));
    assert_eq! (::std::mem::align_of::<templateSlot>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( templateSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const templateSlot ) ) . slotName as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( templateSlot ) , "::" ,
                stringify ! ( slotName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const templateSlot ) ) . constraints as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( templateSlot ) , "::" ,
                stringify ! ( constraints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const templateSlot ) ) . defaultList as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( templateSlot ) , "::" ,
                stringify ! ( defaultList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const templateSlot ) ) . facetList as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( templateSlot ) , "::" ,
                stringify ! ( facetList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const templateSlot ) ) . next as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( templateSlot ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for templateSlot {
    fn clone(&self) -> Self { *self }
}
impl templateSlot {
    #[inline]
    pub fn multislot(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_multislot(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn noDefault(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_noDefault(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn defaultPresent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_defaultPresent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn defaultDynamic(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_defaultDynamic(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(multislot: ::std::os::raw::c_uint,
                          noDefault: ::std::os::raw::c_uint,
                          defaultPresent: ::std::os::raw::c_uint,
                          defaultDynamic: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((multislot as u32 as u8) << 0usize) &
                                (1u64 as u8))
                   } | ((noDefault as u32 as u8) << 1usize) & (2u64 as u8))
              } | ((defaultPresent as u32 as u8) << 2usize) & (4u64 as u8))
         } | ((defaultDynamic as u32 as u8) << 3usize) & (8u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deftemplateModule {
    pub header: defmoduleItemHeader,
}
#[test]
fn bindgen_test_layout_deftemplateModule() {
    assert_eq!(::std::mem::size_of::<deftemplateModule>() , 24usize , concat !
               ( "Size of: " , stringify ! ( deftemplateModule ) ));
    assert_eq! (::std::mem::align_of::<deftemplateModule>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( deftemplateModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplateModule ) ) . header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplateModule ) ,
                "::" , stringify ! ( header ) ));
}
impl Clone for deftemplateModule {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct factPatternNode {
    pub header: patternNodeHeader,
    pub bsaveID: ::std::os::raw::c_ulong,
    pub whichField: ::std::os::raw::c_ushort,
    pub whichSlot: ::std::os::raw::c_ushort,
    pub leaveFields: ::std::os::raw::c_ushort,
    pub networkTest: *mut expr,
    pub nextLevel: *mut factPatternNode,
    pub lastLevel: *mut factPatternNode,
    pub leftNode: *mut factPatternNode,
    pub rightNode: *mut factPatternNode,
}
#[test]
fn bindgen_test_layout_factPatternNode() {
    assert_eq!(::std::mem::size_of::<factPatternNode>() , 96usize , concat ! (
               "Size of: " , stringify ! ( factPatternNode ) ));
    assert_eq! (::std::mem::align_of::<factPatternNode>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( factPatternNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . bsaveID as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( bsaveID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . whichField as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( whichField ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . whichSlot as *
                const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( whichSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . leaveFields as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( leaveFields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . networkTest as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( networkTest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . nextLevel as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( nextLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . lastLevel as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( lastLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . leftNode as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( leftNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factPatternNode ) ) . rightNode as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( factPatternNode ) ,
                "::" , stringify ! ( rightNode ) ));
}
impl Clone for factPatternNode {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeFactPatterns(arg1: *mut Environment);
}
extern "C" {
    pub fn DestroyFactPatternNetwork(arg1: *mut Environment,
                                     arg2: *mut factPatternNode);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deftemplateData {
    pub DeftemplateConstruct: *mut Construct,
    pub DeftemplateModuleIndex: ::std::os::raw::c_uint,
    pub DeftemplatePtrRecord: entityRecord,
    pub DeletedTemplateDebugFlags: ::std::os::raw::c_int,
    pub DeftemplateCodeItem: *mut CodeGeneratorItem,
    pub DeftemplateError: bool,
}
#[test]
fn bindgen_test_layout_deftemplateData() {
    assert_eq!(::std::mem::size_of::<deftemplateData>() , 152usize , concat !
               ( "Size of: " , stringify ! ( deftemplateData ) ));
    assert_eq! (::std::mem::align_of::<deftemplateData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( deftemplateData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplateData ) ) .
                DeftemplateConstruct as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( deftemplateData ) ,
                "::" , stringify ! ( DeftemplateConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplateData ) ) .
                DeftemplateModuleIndex as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( deftemplateData ) ,
                "::" , stringify ! ( DeftemplateModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplateData ) ) .
                DeftemplatePtrRecord as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( deftemplateData ) ,
                "::" , stringify ! ( DeftemplatePtrRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplateData ) ) .
                DeletedTemplateDebugFlags as * const _ as usize } , 128usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( deftemplateData ) ,
                "::" , stringify ! ( DeletedTemplateDebugFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplateData ) ) . DeftemplateCodeItem
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplateData ) ,
                "::" , stringify ! ( DeftemplateCodeItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deftemplateData ) ) . DeftemplateError as
                * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( deftemplateData ) ,
                "::" , stringify ! ( DeftemplateError ) ));
}
impl Clone for deftemplateData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeDeftemplates(arg1: *mut Environment);
}
extern "C" {
    pub fn FindDeftemplate(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char)
     -> *mut Deftemplate;
}
extern "C" {
    pub fn FindDeftemplateInModule(arg1: *mut Environment,
                                   arg2: *const ::std::os::raw::c_char)
     -> *mut Deftemplate;
}
extern "C" {
    pub fn GetNextDeftemplate(arg1: *mut Environment, arg2: *mut Deftemplate)
     -> *mut Deftemplate;
}
extern "C" {
    pub fn DeftemplateIsDeletable(arg1: *mut Deftemplate) -> bool;
}
extern "C" {
    pub fn GetNextFactInTemplate(arg1: *mut Deftemplate, arg2: *mut Fact)
     -> *mut Fact;
}
extern "C" {
    pub fn GetDeftemplateModuleItem(arg1: *mut Environment,
                                    arg2: *mut Defmodule)
     -> *mut deftemplateModule;
}
extern "C" {
    pub fn ReturnSlots(arg1: *mut Environment, arg2: *mut templateSlot);
}
extern "C" {
    pub fn IncrementDeftemplateBusyCount(arg1: *mut Environment,
                                         arg2: *mut Deftemplate);
}
extern "C" {
    pub fn DecrementDeftemplateBusyCount(arg1: *mut Environment,
                                         arg2: *mut Deftemplate);
}
extern "C" {
    pub fn CreateDeftemplateScopeMap(arg1: *mut Environment,
                                     arg2: *mut Deftemplate)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DeftemplateModule(arg1: *mut Deftemplate)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DeftemplateName(arg1: *mut Deftemplate)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DeftemplatePPForm(arg1: *mut Deftemplate)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DeftemplateBasicCommands(arg1: *mut Environment);
}
extern "C" {
    pub fn UndeftemplateCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn Undeftemplate(arg1: *mut Deftemplate, arg2: *mut Environment)
     -> bool;
}
extern "C" {
    pub fn GetDeftemplateListFunction(arg1: *mut Environment,
                                      arg2: *mut UDFContext,
                                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDeftemplateList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                              arg3: *mut Defmodule);
}
extern "C" {
    pub fn DeftemplateModuleFunction(arg1: *mut Environment,
                                     arg2: *mut UDFContext,
                                     arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDeftemplateCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDeftemplate(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn ListDeftemplatesCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDeftemplates(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *mut Defmodule);
}
extern "C" {
    pub fn DeftemplateGetWatch(arg1: *mut Deftemplate) -> bool;
}
extern "C" {
    pub fn DeftemplateSetWatch(arg1: *mut Deftemplate, arg2: bool);
}
extern "C" {
    pub fn DeftemplateWatchAccess(arg1: *mut Environment,
                                  arg2: ::std::os::raw::c_int, arg3: bool,
                                  arg4: *mut expr) -> bool;
}
extern "C" {
    pub fn DeftemplateWatchPrint(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: ::std::os::raw::c_int, arg4: *mut expr)
     -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct factBuilder {
    pub fbEnv: *mut Environment,
    pub fbDeftemplate: *mut Deftemplate,
    pub fbValueArray: *mut CLIPSValue,
}
#[test]
fn bindgen_test_layout_factBuilder() {
    assert_eq!(::std::mem::size_of::<factBuilder>() , 24usize , concat ! (
               "Size of: " , stringify ! ( factBuilder ) ));
    assert_eq! (::std::mem::align_of::<factBuilder>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( factBuilder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factBuilder ) ) . fbEnv as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( factBuilder ) , "::" ,
                stringify ! ( fbEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factBuilder ) ) . fbDeftemplate as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( factBuilder ) , "::" ,
                stringify ! ( fbDeftemplate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factBuilder ) ) . fbValueArray as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( factBuilder ) , "::" ,
                stringify ! ( fbValueArray ) ));
}
impl Clone for factBuilder {
    fn clone(&self) -> Self { *self }
}
pub type FactBuilder = factBuilder;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct factModifier {
    pub fmEnv: *mut Environment,
    pub fmOldFact: *mut Fact,
    pub fmValueArray: *mut CLIPSValue,
    pub changeMap: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_factModifier() {
    assert_eq!(::std::mem::size_of::<factModifier>() , 32usize , concat ! (
               "Size of: " , stringify ! ( factModifier ) ));
    assert_eq! (::std::mem::align_of::<factModifier>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( factModifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factModifier ) ) . fmEnv as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( factModifier ) , "::" ,
                stringify ! ( fmEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factModifier ) ) . fmOldFact as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( factModifier ) , "::" ,
                stringify ! ( fmOldFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factModifier ) ) . fmValueArray as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( factModifier ) , "::" ,
                stringify ! ( fmValueArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factModifier ) ) . changeMap as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( factModifier ) , "::" ,
                stringify ! ( changeMap ) ));
}
impl Clone for factModifier {
    fn clone(&self) -> Self { *self }
}
pub type FactModifier = factModifier;
pub type ModifyCallFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Environment,
                                               arg2: *mut Fact,
                                               arg3: *mut Fact,
                                               arg4:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct modifyCallFunctionItem {
    pub name: *const ::std::os::raw::c_char,
    pub func: ModifyCallFunction,
    pub priority: ::std::os::raw::c_int,
    pub next: *mut ModifyCallFunctionItem,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_modifyCallFunctionItem() {
    assert_eq!(::std::mem::size_of::<modifyCallFunctionItem>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( modifyCallFunctionItem )
               ));
    assert_eq! (::std::mem::align_of::<modifyCallFunctionItem>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( modifyCallFunctionItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modifyCallFunctionItem ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( modifyCallFunctionItem
                ) , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modifyCallFunctionItem ) ) . func as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( modifyCallFunctionItem
                ) , "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modifyCallFunctionItem ) ) . priority as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( modifyCallFunctionItem
                ) , "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modifyCallFunctionItem ) ) . next as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( modifyCallFunctionItem
                ) , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modifyCallFunctionItem ) ) . context as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( modifyCallFunctionItem
                ) , "::" , stringify ! ( context ) ));
}
impl Clone for modifyCallFunctionItem {
    fn clone(&self) -> Self { *self }
}
pub type ModifyCallFunctionItem = modifyCallFunctionItem;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RetractError {
    RE_NO_ERROR = 0,
    RE_NULL_POINTER_ERROR = 1,
    RE_COULD_NOT_RETRACT_ERROR = 2,
    RE_RULE_NETWORK_ERROR = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AssertError {
    AE_NO_ERROR = 0,
    AE_NULL_POINTER_ERROR = 1,
    AE_RETRACTED_ERROR = 2,
    AE_COULD_NOT_ASSERT_ERROR = 3,
    AE_RULE_NETWORK_ERROR = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AssertStringError {
    ASE_NO_ERROR = 0,
    ASE_NULL_POINTER_ERROR = 1,
    ASE_PARSING_ERROR = 2,
    ASE_COULD_NOT_ASSERT_ERROR = 3,
    ASE_RULE_NETWORK_ERROR = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FactBuilderError {
    FBE_NO_ERROR = 0,
    FBE_NULL_POINTER_ERROR = 1,
    FBE_DEFTEMPLATE_NOT_FOUND_ERROR = 2,
    FBE_IMPLIED_DEFTEMPLATE_ERROR = 3,
    FBE_COULD_NOT_ASSERT_ERROR = 4,
    FBE_RULE_NETWORK_ERROR = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FactModifierError {
    FME_NO_ERROR = 0,
    FME_NULL_POINTER_ERROR = 1,
    FME_RETRACTED_ERROR = 2,
    FME_IMPLIED_DEFTEMPLATE_ERROR = 3,
    FME_COULD_NOT_MODIFY_ERROR = 4,
    FME_RULE_NETWORK_ERROR = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct factHashEntry {
    pub theFact: *mut Fact,
    pub next: *mut FactHashEntry,
}
#[test]
fn bindgen_test_layout_factHashEntry() {
    assert_eq!(::std::mem::size_of::<factHashEntry>() , 16usize , concat ! (
               "Size of: " , stringify ! ( factHashEntry ) ));
    assert_eq! (::std::mem::align_of::<factHashEntry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( factHashEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factHashEntry ) ) . theFact as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( factHashEntry ) , "::"
                , stringify ! ( theFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factHashEntry ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( factHashEntry ) , "::"
                , stringify ! ( next ) ));
}
impl Clone for factHashEntry {
    fn clone(&self) -> Self { *self }
}
pub type FactHashEntry = factHashEntry;
extern "C" {
    pub fn AddHashedFact(arg1: *mut Environment, arg2: *mut Fact,
                         arg3: usize);
}
extern "C" {
    pub fn RemoveHashedFact(arg1: *mut Environment, arg2: *mut Fact) -> bool;
}
extern "C" {
    pub fn HandleFactDuplication(arg1: *mut Environment, arg2: *mut Fact,
                                 arg3: *mut *mut Fact,
                                 arg4: ::std::os::raw::c_longlong) -> usize;
}
extern "C" {
    pub fn GetFactDuplication(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetFactDuplication(arg1: *mut Environment, arg2: bool) -> bool;
}
extern "C" {
    pub fn InitializeFactHashTable(arg1: *mut Environment);
}
extern "C" {
    pub fn ShowFactHashTableCommand(arg1: *mut Environment,
                                    arg2: *mut UDFContext,
                                    arg3: *mut UDFValue);
}
extern "C" {
    pub fn HashFact(arg1: *mut Fact) -> usize;
}
extern "C" {
    pub fn FactWillBeAsserted(arg1: *mut Environment, arg2: *mut Fact)
     -> bool;
}
#[repr(C)]
#[derive(Copy)]
pub struct factsData {
    pub ChangeToFactList: bool,
    pub WatchFacts: bool,
    pub DummyFact: Fact,
    pub GarbageFacts: *mut Fact,
    pub LastFact: *mut Fact,
    pub FactList: *mut Fact,
    pub NextFactIndex: ::std::os::raw::c_longlong,
    pub NumberOfFacts: ::std::os::raw::c_ulong,
    pub ListOfAssertFunctions: *mut callFunctionItemWithArg,
    pub ListOfRetractFunctions: *mut callFunctionItemWithArg,
    pub ListOfModifyFunctions: *mut ModifyCallFunctionItem,
    pub FactInfo: patternEntityRecord,
    pub CurrentDeftemplate: *mut Deftemplate,
    pub FactCodeItem: *mut CodeGeneratorItem,
    pub FactHashTable: *mut *mut factHashEntry,
    pub FactHashTableSize: ::std::os::raw::c_ulong,
    pub FactDuplication: bool,
    pub CurrentPatternFact: *mut Fact,
    pub CurrentPatternMarks: *mut multifieldMarker,
    pub LastModuleIndex: ::std::os::raw::c_long,
    pub retractError: RetractError,
    pub assertError: AssertError,
    pub assertStringError: AssertStringError,
    pub factModifierError: FactModifierError,
    pub factBuilderError: FactBuilderError,
}
#[test]
fn bindgen_test_layout_factsData() {
    assert_eq!(::std::mem::size_of::<factsData>() , 464usize , concat ! (
               "Size of: " , stringify ! ( factsData ) ));
    assert_eq! (::std::mem::align_of::<factsData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( factsData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . ChangeToFactList as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( ChangeToFactList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . WatchFacts as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( WatchFacts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . DummyFact as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( DummyFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . GarbageFacts as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( GarbageFacts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . LastFact as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( LastFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . FactList as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( FactList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . NextFactIndex as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( NextFactIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . NumberOfFacts as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( NumberOfFacts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . ListOfAssertFunctions as
                * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( ListOfAssertFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . ListOfRetractFunctions as
                * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( ListOfRetractFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . ListOfModifyFunctions as
                * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( ListOfModifyFunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . FactInfo as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( FactInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . CurrentDeftemplate as *
                const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( CurrentDeftemplate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . FactCodeItem as * const _
                as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( FactCodeItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . FactHashTable as * const
                _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( FactHashTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . FactHashTableSize as *
                const _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( FactHashTableSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . FactDuplication as *
                const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( FactDuplication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . CurrentPatternFact as *
                const _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( CurrentPatternFact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . CurrentPatternMarks as *
                const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( CurrentPatternMarks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . LastModuleIndex as *
                const _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( LastModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . retractError as * const _
                as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( retractError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . assertError as * const _
                as usize } , 444usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( assertError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . assertStringError as *
                const _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( assertStringError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . factModifierError as *
                const _ as usize } , 452usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( factModifierError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const factsData ) ) . factBuilderError as *
                const _ as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( factsData ) , "::" ,
                stringify ! ( factBuilderError ) ));
}
impl Clone for factsData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn Assert(arg1: *mut Fact) -> *mut Fact;
}
extern "C" {
    pub fn GetAssertStringError(arg1: *mut Environment) -> AssertStringError;
}
extern "C" {
    pub fn AssertDriver(arg1: *mut Fact, arg2: ::std::os::raw::c_longlong,
                        arg3: *mut Fact, arg4: *mut Fact,
                        arg5: *mut ::std::os::raw::c_char) -> *mut Fact;
}
extern "C" {
    pub fn AssertString(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char) -> *mut Fact;
}
extern "C" {
    pub fn CreateFact(arg1: *mut Deftemplate) -> *mut Fact;
}
extern "C" {
    pub fn ReleaseFact(arg1: *mut Fact);
}
extern "C" {
    pub fn DecrementFactCallback(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn FactIndex(arg1: *mut Fact) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn GetFactSlot(arg1: *mut Fact, arg2: *const ::std::os::raw::c_char,
                       arg3: *mut CLIPSValue) -> GetSlotError;
}
extern "C" {
    pub fn PrintFactWithIdentifier(arg1: *mut Environment,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: *mut Fact,
                                   arg4: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn PrintFact(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char, arg3: *mut Fact,
                     arg4: bool, arg5: bool,
                     arg6: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn PrintFactIdentifierInLongForm(arg1: *mut Environment,
                                         arg2: *const ::std::os::raw::c_char,
                                         arg3: *mut Fact);
}
extern "C" {
    pub fn Retract(arg1: *mut Fact) -> RetractError;
}
extern "C" {
    pub fn RetractDriver(arg1: *mut Environment, arg2: *mut Fact, arg3: bool,
                         arg4: *mut ::std::os::raw::c_char) -> RetractError;
}
extern "C" {
    pub fn RetractAllFacts(arg1: *mut Environment) -> RetractError;
}
extern "C" {
    pub fn CreateFactBySize(arg1: *mut Environment, arg2: usize) -> *mut Fact;
}
extern "C" {
    pub fn FactInstall(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn FactDeinstall(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn GetNextFact(arg1: *mut Environment, arg2: *mut Fact) -> *mut Fact;
}
extern "C" {
    pub fn GetNextFactInScope(arg1: *mut Environment, arg2: *mut Fact)
     -> *mut Fact;
}
extern "C" {
    pub fn FactPPForm(arg1: *mut Fact, arg2: *mut StringBuilder);
}
extern "C" {
    pub fn GetFactListChanged(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetFactListChanged(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn GetNumberOfFacts(arg1: *mut Environment)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn InitializeFacts(arg1: *mut Environment);
}
extern "C" {
    pub fn FindIndexedFact(arg1: *mut Environment,
                           arg2: ::std::os::raw::c_longlong) -> *mut Fact;
}
extern "C" {
    pub fn RetainFact(arg1: *mut Fact);
}
extern "C" {
    pub fn IncrementFactCallback(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn PrintFactIdentifier(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut Fact);
}
extern "C" {
    pub fn DecrementFactBasisCount(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn IncrementFactBasisCount(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn FactIsDeleted(arg1: *mut Environment, arg2: *mut Fact) -> bool;
}
extern "C" {
    pub fn ReturnFact(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn MatchFactFunction(arg1: *mut Environment, arg2: *mut Fact);
}
extern "C" {
    pub fn PutFactSlot(arg1: *mut Fact, arg2: *const ::std::os::raw::c_char,
                       arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn AssignFactSlotDefaults(arg1: *mut Fact) -> bool;
}
extern "C" {
    pub fn CopyFactSlotValues(arg1: *mut Environment, arg2: *mut Fact,
                              arg3: *mut Fact) -> bool;
}
extern "C" {
    pub fn DeftemplateSlotDefault(arg1: *mut Environment,
                                  arg2: *mut Deftemplate,
                                  arg3: *mut templateSlot,
                                  arg4: *mut UDFValue, arg5: bool) -> bool;
}
extern "C" {
    pub fn AddAssertFunction(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: VoidCallFunctionWithArg,
                             arg4: ::std::os::raw::c_int,
                             arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn RemoveAssertFunction(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn AddRetractFunction(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: VoidCallFunctionWithArg,
                              arg4: ::std::os::raw::c_int,
                              arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn RemoveRetractFunction(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn CreateFactBuilder(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char)
     -> *mut FactBuilder;
}
extern "C" {
    pub fn FBPutSlot(arg1: *mut FactBuilder,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut CLIPSValue) -> PutSlotError;
}
extern "C" {
    pub fn FBAssert(arg1: *mut FactBuilder) -> *mut Fact;
}
extern "C" {
    pub fn FBDispose(arg1: *mut FactBuilder);
}
extern "C" {
    pub fn FBAbort(arg1: *mut FactBuilder);
}
extern "C" {
    pub fn FBSetDeftemplate(arg1: *mut FactBuilder,
                            arg2: *const ::std::os::raw::c_char)
     -> FactBuilderError;
}
extern "C" {
    pub fn FBPutSlotCLIPSInteger(arg1: *mut FactBuilder,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut CLIPSInteger) -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotInteger(arg1: *mut FactBuilder,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: ::std::os::raw::c_longlong) -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotCLIPSFloat(arg1: *mut FactBuilder,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut CLIPSFloat) -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotFloat(arg1: *mut FactBuilder,
                          arg2: *const ::std::os::raw::c_char, arg3: f64)
     -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotCLIPSLexeme(arg1: *mut FactBuilder,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: *mut CLIPSLexeme) -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotSymbol(arg1: *mut FactBuilder,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotString(arg1: *mut FactBuilder,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotInstanceName(arg1: *mut FactBuilder,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotFact(arg1: *mut FactBuilder,
                         arg2: *const ::std::os::raw::c_char, arg3: *mut Fact)
     -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotInstance(arg1: *mut FactBuilder,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut Instance) -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotCLIPSExternalAddress(arg1: *mut FactBuilder,
                                         arg2: *const ::std::os::raw::c_char,
                                         arg3: *mut CLIPSExternalAddress)
     -> PutSlotError;
}
extern "C" {
    pub fn FBPutSlotMultifield(arg1: *mut FactBuilder,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut Multifield) -> PutSlotError;
}
extern "C" {
    pub fn FBError(arg1: *mut Environment) -> FactBuilderError;
}
extern "C" {
    pub fn CreateFactModifier(arg1: *mut Environment, arg2: *mut Fact)
     -> *mut FactModifier;
}
extern "C" {
    pub fn FMPutSlot(arg1: *mut FactModifier,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut CLIPSValue) -> PutSlotError;
}
extern "C" {
    pub fn FMModify(arg1: *mut FactModifier) -> *mut Fact;
}
extern "C" {
    pub fn FMDispose(arg1: *mut FactModifier);
}
extern "C" {
    pub fn FMAbort(arg1: *mut FactModifier);
}
extern "C" {
    pub fn FMSetFact(arg1: *mut FactModifier, arg2: *mut Fact)
     -> FactModifierError;
}
extern "C" {
    pub fn FMPutSlotCLIPSInteger(arg1: *mut FactModifier,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut CLIPSInteger) -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotInteger(arg1: *mut FactModifier,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: ::std::os::raw::c_longlong) -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotCLIPSFloat(arg1: *mut FactModifier,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut CLIPSFloat) -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotFloat(arg1: *mut FactModifier,
                          arg2: *const ::std::os::raw::c_char, arg3: f64)
     -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotCLIPSLexeme(arg1: *mut FactModifier,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: *mut CLIPSLexeme) -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotSymbol(arg1: *mut FactModifier,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotString(arg1: *mut FactModifier,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotInstanceName(arg1: *mut FactModifier,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotFact(arg1: *mut FactModifier,
                         arg2: *const ::std::os::raw::c_char, arg3: *mut Fact)
     -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotInstance(arg1: *mut FactModifier,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut Instance) -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotExternalAddress(arg1: *mut FactModifier,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: *mut CLIPSExternalAddress)
     -> PutSlotError;
}
extern "C" {
    pub fn FMPutSlotMultifield(arg1: *mut FactModifier,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut Multifield) -> PutSlotError;
}
extern "C" {
    pub fn FMError(arg1: *mut Environment) -> FactModifierError;
}
extern "C" {
    pub fn AddModifyFunction(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: ModifyCallFunction,
                             arg4: ::std::os::raw::c_int,
                             arg5: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn RemoveModifyFunction(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn AddModifyFunctionToCallList(arg1: *mut Environment,
                                       arg2: *const ::std::os::raw::c_char,
                                       arg3: ::std::os::raw::c_int,
                                       arg4: ModifyCallFunction,
                                       arg5: *mut ModifyCallFunctionItem,
                                       arg6: *mut ::std::os::raw::c_void)
     -> *mut ModifyCallFunctionItem;
}
extern "C" {
    pub fn RemoveModifyFunctionFromCallList(arg1: *mut Environment,
                                            arg2:
                                                *const ::std::os::raw::c_char,
                                            arg3: *mut ModifyCallFunctionItem,
                                            arg4: *mut bool)
     -> *mut ModifyCallFunctionItem;
}
extern "C" {
    pub fn DeallocateModifyCallList(arg1: *mut Environment,
                                    arg2: *mut ModifyCallFunctionItem);
}
extern "C" {
    pub fn UpdateModifyDuplicate(arg1: *mut Environment, arg2: *mut expr,
                                 arg3: *const ::std::os::raw::c_char,
                                 arg4: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn ModifyParse(arg1: *mut Environment, arg2: *mut expr,
                       arg3: *const ::std::os::raw::c_char) -> *mut expr;
}
extern "C" {
    pub fn DuplicateParse(arg1: *mut Environment, arg2: *mut expr,
                          arg3: *const ::std::os::raw::c_char) -> *mut expr;
}
extern "C" {
    pub fn DeftemplateFunctions(arg1: *mut Environment);
}
extern "C" {
    pub fn ModifyCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn DuplicateCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotNamesFunction(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotNames(arg1: *mut Deftemplate,
                                arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn DeftemplateSlotDefaultValueFunction(arg1: *mut Environment,
                                               arg2: *mut UDFContext,
                                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotDefaultValue(arg1: *mut Deftemplate,
                                       arg2: *const ::std::os::raw::c_char,
                                       arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn DeftemplateSlotCardinalityFunction(arg1: *mut Environment,
                                              arg2: *mut UDFContext,
                                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotCardinality(arg1: *mut Deftemplate,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn DeftemplateSlotAllowedValuesFunction(arg1: *mut Environment,
                                                arg2: *mut UDFContext,
                                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotAllowedValues(arg1: *mut Deftemplate,
                                        arg2: *const ::std::os::raw::c_char,
                                        arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn DeftemplateSlotRangeFunction(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotRange(arg1: *mut Deftemplate,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn DeftemplateSlotTypesFunction(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotTypes(arg1: *mut Deftemplate,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn DeftemplateSlotMultiPFunction(arg1: *mut Environment,
                                         arg2: *mut UDFContext,
                                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotMultiP(arg1: *mut Deftemplate,
                                 arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn DeftemplateSlotSinglePFunction(arg1: *mut Environment,
                                          arg2: *mut UDFContext,
                                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotSingleP(arg1: *mut Deftemplate,
                                  arg2: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn DeftemplateSlotExistPFunction(arg1: *mut Environment,
                                         arg2: *mut UDFContext,
                                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotExistP(arg1: *mut Deftemplate,
                                 arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn DeftemplateSlotDefaultPFunction(arg1: *mut Environment,
                                           arg2: *mut UDFContext,
                                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotDefaultP(arg1: *mut Deftemplate,
                                   arg2: *const ::std::os::raw::c_char)
     -> DefaultType;
}
extern "C" {
    pub fn DeftemplateSlotFacetExistPFunction(arg1: *mut Environment,
                                              arg2: *mut UDFContext,
                                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotFacetExistP(arg1: *mut Environment,
                                      arg2: *mut Deftemplate,
                                      arg3: *const ::std::os::raw::c_char,
                                      arg4: *const ::std::os::raw::c_char)
     -> bool;
}
extern "C" {
    pub fn DeftemplateSlotFacetValueFunction(arg1: *mut Environment,
                                             arg2: *mut UDFContext,
                                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeftemplateSlotFacetValue(arg1: *mut Environment,
                                     arg2: *mut Deftemplate,
                                     arg3: *const ::std::os::raw::c_char,
                                     arg4: *const ::std::os::raw::c_char,
                                     arg5: *mut UDFValue) -> bool;
}
extern "C" {
    pub fn ReplaceFact(arg1: *mut Environment, arg2: *mut Fact,
                       arg3: *mut CLIPSValue,
                       arg4: *mut ::std::os::raw::c_char) -> *mut Fact;
}
extern "C" {
    pub fn FactCommandDefinitions(arg1: *mut Environment);
}
extern "C" {
    pub fn AssertCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn RetractCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn AssertStringFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn FactsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn Facts(arg1: *mut Environment, arg2: *const ::std::os::raw::c_char,
                 arg3: *mut Defmodule, arg4: ::std::os::raw::c_longlong,
                 arg5: ::std::os::raw::c_longlong,
                 arg6: ::std::os::raw::c_longlong);
}
extern "C" {
    pub fn SetFactDuplicationCommand(arg1: *mut Environment,
                                     arg2: *mut UDFContext,
                                     arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetFactDuplicationCommand(arg1: *mut Environment,
                                     arg2: *mut UDFContext,
                                     arg3: *mut UDFValue);
}
extern "C" {
    pub fn SaveFactsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn LoadFactsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn SaveFacts(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char, arg3: SaveScope)
     -> bool;
}
extern "C" {
    pub fn SaveFactsDriver(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: SaveScope, arg4: *mut expr) -> bool;
}
extern "C" {
    pub fn LoadFacts(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn LoadFactsFromString(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: usize) -> bool;
}
extern "C" {
    pub fn FactIndexFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn FactFunctionDefinitions(arg1: *mut Environment);
}
extern "C" {
    pub fn FactRelationFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn FactRelation(arg1: *mut Fact) -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn FactDeftemplate(arg1: *mut Fact) -> *mut Deftemplate;
}
extern "C" {
    pub fn FactExistpFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn FactExistp(arg1: *mut Fact) -> bool;
}
extern "C" {
    pub fn FactSlotValueFunction(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn FactSlotValue(arg1: *mut Environment, arg2: *mut Fact,
                         arg3: *const ::std::os::raw::c_char,
                         arg4: *mut CLIPSValue);
}
extern "C" {
    pub fn FactSlotNamesFunction(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn FactSlotNames(arg1: *mut Fact, arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn GetFactListFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetFactList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                       arg3: *mut Defmodule);
}
extern "C" {
    pub fn PPFactFunction(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPFact(arg1: *mut Fact, arg2: *const ::std::os::raw::c_char,
                  arg3: bool);
}
extern "C" {
    pub fn GetFactAddressOrIndexArgument(arg1: *mut UDFContext, arg2: bool)
     -> *mut Fact;
}
#[repr(C)]
#[derive(Copy)]
pub struct defglobal {
    pub header: ConstructHeader,
    pub _bitfield_1: u8,
    pub busyCount: ::std::os::raw::c_long,
    pub current: CLIPSValue,
    pub initial: *mut expr,
}
#[test]
fn bindgen_test_layout_defglobal() {
    assert_eq!(::std::mem::size_of::<defglobal>() , 96usize , concat ! (
               "Size of: " , stringify ! ( defglobal ) ));
    assert_eq! (::std::mem::align_of::<defglobal>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defglobal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobal ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobal ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobal ) ) . busyCount as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobal ) , "::" ,
                stringify ! ( busyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobal ) ) . current as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobal ) , "::" ,
                stringify ! ( current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobal ) ) . initial as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobal ) , "::" ,
                stringify ! ( initial ) ));
}
impl Clone for defglobal {
    fn clone(&self) -> Self { *self }
}
impl defglobal {
    #[inline]
    pub fn watch(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_watch(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn inScope(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inScope(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(watch: ::std::os::raw::c_uint,
                          inScope: ::std::os::raw::c_uint) -> u8 {
        ({ ({ 0 } | ((watch as u32 as u8) << 0usize) & (1u64 as u8)) } |
             ((inScope as u32 as u8) << 1usize) & (2u64 as u8))
    }
}
pub type Defglobal = defglobal;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defglobalData {
    pub DefglobalConstruct: *mut Construct,
    pub DefglobalModuleIndex: ::std::os::raw::c_uint,
    pub ChangeToGlobals: bool,
    pub WatchGlobals: bool,
    pub ResetGlobals: bool,
    pub GlobalInfo: entityRecord,
    pub DefglobalPtrRecord: entityRecord,
    pub LastModuleIndex: ::std::os::raw::c_long,
    pub TheDefmodule: *mut Defmodule,
    pub DefglobalCodeItem: *mut CodeGeneratorItem,
}
#[test]
fn bindgen_test_layout_defglobalData() {
    assert_eq!(::std::mem::size_of::<defglobalData>() , 264usize , concat ! (
               "Size of: " , stringify ! ( defglobalData ) ));
    assert_eq! (::std::mem::align_of::<defglobalData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defglobalData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . DefglobalConstruct as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( DefglobalConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . DefglobalModuleIndex
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( DefglobalModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . ChangeToGlobals as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( ChangeToGlobals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . WatchGlobals as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( WatchGlobals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . ResetGlobals as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( ResetGlobals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . GlobalInfo as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( GlobalInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . DefglobalPtrRecord as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( DefglobalPtrRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . LastModuleIndex as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( LastModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . TheDefmodule as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( TheDefmodule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalData ) ) . DefglobalCodeItem as
                * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalData ) , "::"
                , stringify ! ( DefglobalCodeItem ) ));
}
impl Clone for defglobalData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defglobalModule {
    pub header: defmoduleItemHeader,
}
#[test]
fn bindgen_test_layout_defglobalModule() {
    assert_eq!(::std::mem::size_of::<defglobalModule>() , 24usize , concat ! (
               "Size of: " , stringify ! ( defglobalModule ) ));
    assert_eq! (::std::mem::align_of::<defglobalModule>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( defglobalModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defglobalModule ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defglobalModule ) ,
                "::" , stringify ! ( header ) ));
}
impl Clone for defglobalModule {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitializeDefglobals(arg1: *mut Environment);
}
extern "C" {
    pub fn FindDefglobal(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char)
     -> *mut Defglobal;
}
extern "C" {
    pub fn FindDefglobalInModule(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char)
     -> *mut Defglobal;
}
extern "C" {
    pub fn GetNextDefglobal(arg1: *mut Environment, arg2: *mut Defglobal)
     -> *mut Defglobal;
}
extern "C" {
    pub fn CreateInitialFactDefglobal();
}
extern "C" {
    pub fn DefglobalIsDeletable(arg1: *mut Defglobal) -> bool;
}
extern "C" {
    pub fn GetDefglobalModuleItem(arg1: *mut Environment,
                                  arg2: *mut Defmodule)
     -> *mut defglobalModule;
}
extern "C" {
    pub fn QSetDefglobalValue(arg1: *mut Environment, arg2: *mut Defglobal,
                              arg3: *mut UDFValue, arg4: bool);
}
extern "C" {
    pub fn QFindDefglobal(arg1: *mut Environment, arg2: *mut CLIPSLexeme)
     -> *mut Defglobal;
}
extern "C" {
    pub fn DefglobalValueForm(arg1: *mut Defglobal, arg2: *mut StringBuilder);
}
extern "C" {
    pub fn GetGlobalsChanged(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetGlobalsChanged(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn DefglobalGetValue(arg1: *mut Defglobal, arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn DefglobalSetValue(arg1: *mut Defglobal, arg2: *mut CLIPSValue);
}
extern "C" {
    pub fn DefglobalSetInteger(arg1: *mut Defglobal,
                               arg2: ::std::os::raw::c_longlong);
}
extern "C" {
    pub fn DefglobalSetFloat(arg1: *mut Defglobal, arg2: f64);
}
extern "C" {
    pub fn DefglobalSetSymbol(arg1: *mut Defglobal,
                              arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn DefglobalSetString(arg1: *mut Defglobal,
                              arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn DefglobalSetInstanceName(arg1: *mut Defglobal,
                                    arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn DefglobalSetCLIPSInteger(arg1: *mut Defglobal,
                                    arg2: *mut CLIPSInteger);
}
extern "C" {
    pub fn DefglobalSetCLIPSFloat(arg1: *mut Defglobal,
                                  arg2: *mut CLIPSFloat);
}
extern "C" {
    pub fn DefglobalSetCLIPSLexeme(arg1: *mut Defglobal,
                                   arg2: *mut CLIPSLexeme);
}
extern "C" {
    pub fn DefglobalSetFact(arg1: *mut Defglobal, arg2: *mut Fact);
}
extern "C" {
    pub fn DefglobalSetInstance(arg1: *mut Defglobal, arg2: *mut Instance);
}
extern "C" {
    pub fn DefglobalSetMultifield(arg1: *mut Defglobal,
                                  arg2: *mut Multifield);
}
extern "C" {
    pub fn DefglobalSetCLIPSExternalAddress(arg1: *mut Defglobal,
                                            arg2: *mut CLIPSExternalAddress);
}
extern "C" {
    pub fn UpdateDefglobalScope(arg1: *mut Environment);
}
extern "C" {
    pub fn GetNextDefglobalInScope(arg1: *mut Environment,
                                   arg2: *mut Defglobal) -> *mut Defglobal;
}
extern "C" {
    pub fn QGetDefglobalUDFValue(arg1: *mut Environment, arg2: *mut Defglobal,
                                 arg3: *mut UDFValue) -> bool;
}
extern "C" {
    pub fn DefglobalModule(arg1: *mut Defglobal)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefglobalName(arg1: *mut Defglobal)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefglobalPPForm(arg1: *mut Defglobal)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefglobalBasicCommands(arg1: *mut Environment);
}
extern "C" {
    pub fn UndefglobalCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn Undefglobal(arg1: *mut Defglobal, arg2: *mut Environment) -> bool;
}
extern "C" {
    pub fn GetDefglobalListFunction(arg1: *mut Environment,
                                    arg2: *mut UDFContext,
                                    arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefglobalList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                            arg3: *mut Defmodule);
}
extern "C" {
    pub fn DefglobalModuleFunction(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDefglobalCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDefglobal(arg1: *mut Environment,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn ListDefglobalsCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn DefglobalGetWatch(arg1: *mut Defglobal) -> bool;
}
extern "C" {
    pub fn ListDefglobals(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *mut Defmodule);
}
extern "C" {
    pub fn DefglobalSetWatch(arg1: *mut Defglobal, arg2: bool);
}
extern "C" {
    pub fn ResetDefglobals(arg1: *mut Environment,
                           arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn DefglobalCommandDefinitions(arg1: *mut Environment);
}
extern "C" {
    pub fn SetResetGlobalsCommand(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetResetGlobals(arg1: *mut Environment, arg2: bool) -> bool;
}
extern "C" {
    pub fn GetResetGlobalsCommand(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetResetGlobals(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn ShowDefglobalsCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ShowDefglobals(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *mut Defmodule);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deffunction {
    pub header: ConstructHeader,
    pub busy: ::std::os::raw::c_uint,
    pub executing: ::std::os::raw::c_uint,
    pub trace: bool,
    pub code: *mut Expression,
    pub minNumberOfParameters: ::std::os::raw::c_ushort,
    pub maxNumberOfParameters: ::std::os::raw::c_ushort,
    pub numberOfLocalVars: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_deffunction() {
    assert_eq!(::std::mem::size_of::<deffunction>() , 96usize , concat ! (
               "Size of: " , stringify ! ( deffunction ) ));
    assert_eq! (::std::mem::align_of::<deffunction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( deffunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunction ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunction ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunction ) ) . busy as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunction ) , "::" ,
                stringify ! ( busy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunction ) ) . executing as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunction ) , "::" ,
                stringify ! ( executing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunction ) ) . trace as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunction ) , "::" ,
                stringify ! ( trace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunction ) ) . code as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunction ) , "::" ,
                stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunction ) ) . minNumberOfParameters
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunction ) , "::" ,
                stringify ! ( minNumberOfParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunction ) ) . maxNumberOfParameters
                as * const _ as usize } , 90usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunction ) , "::" ,
                stringify ! ( maxNumberOfParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunction ) ) . numberOfLocalVars as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunction ) , "::" ,
                stringify ! ( numberOfLocalVars ) ));
}
impl Clone for deffunction {
    fn clone(&self) -> Self { *self }
}
pub type Deffunction = deffunction;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deffunctionModuleData {
    pub header: defmoduleItemHeader,
}
#[test]
fn bindgen_test_layout_deffunctionModuleData() {
    assert_eq!(::std::mem::size_of::<deffunctionModuleData>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( deffunctionModuleData )
               ));
    assert_eq! (::std::mem::align_of::<deffunctionModuleData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( deffunctionModuleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunctionModuleData ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunctionModuleData )
                , "::" , stringify ! ( header ) ));
}
impl Clone for deffunctionModuleData {
    fn clone(&self) -> Self { *self }
}
pub type DeffunctionModuleData = deffunctionModuleData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct deffunctionData {
    pub DeffunctionConstruct: *mut Construct,
    pub DeffunctionModuleIndex: ::std::os::raw::c_uint,
    pub DeffunctionEntityRecord: EntityRecord,
    pub WatchDeffunctions: bool,
    pub DeffunctionCodeItem: *mut CodeGeneratorItem,
    pub ExecutingDeffunction: *mut Deffunction,
}
#[test]
fn bindgen_test_layout_deffunctionData() {
    assert_eq!(::std::mem::size_of::<deffunctionData>() , 152usize , concat !
               ( "Size of: " , stringify ! ( deffunctionData ) ));
    assert_eq! (::std::mem::align_of::<deffunctionData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( deffunctionData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunctionData ) ) .
                DeffunctionConstruct as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( deffunctionData ) ,
                "::" , stringify ! ( DeffunctionConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunctionData ) ) .
                DeffunctionModuleIndex as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( deffunctionData ) ,
                "::" , stringify ! ( DeffunctionModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunctionData ) ) .
                DeffunctionEntityRecord as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( deffunctionData ) ,
                "::" , stringify ! ( DeffunctionEntityRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunctionData ) ) . WatchDeffunctions
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunctionData ) ,
                "::" , stringify ! ( WatchDeffunctions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunctionData ) ) . DeffunctionCodeItem
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( deffunctionData ) ,
                "::" , stringify ! ( DeffunctionCodeItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const deffunctionData ) ) .
                ExecutingDeffunction as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( deffunctionData ) ,
                "::" , stringify ! ( ExecutingDeffunction ) ));
}
impl Clone for deffunctionData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn CheckDeffunctionCall(arg1: *mut Environment,
                                arg2: *mut Deffunction,
                                arg3: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn DeffunctionGetBind(arg1: *mut UDFValue);
}
extern "C" {
    pub fn DFRtnUnknown(arg1: *mut UDFValue);
}
extern "C" {
    pub fn DFWildargs(arg1: *mut UDFValue);
}
extern "C" {
    pub fn DeffunctionModule(arg1: *mut Deffunction)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FindDeffunction(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char)
     -> *mut Deffunction;
}
extern "C" {
    pub fn FindDeffunctionInModule(arg1: *mut Environment,
                                   arg2: *const ::std::os::raw::c_char)
     -> *mut Deffunction;
}
extern "C" {
    pub fn GetDeffunctionList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                              arg3: *mut Defmodule);
}
extern "C" {
    pub fn DeffunctionName(arg1: *mut Deffunction)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetDeffunctionNamePointer(arg1: *mut Environment,
                                     arg2: *mut Deffunction)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn DeffunctionPPForm(arg1: *mut Deffunction)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetNextDeffunction(arg1: *mut Environment, arg2: *mut Deffunction)
     -> *mut Deffunction;
}
extern "C" {
    pub fn DeffunctionIsDeletable(arg1: *mut Deffunction) -> bool;
}
extern "C" {
    pub fn SetDeffunctionPPForm(arg1: *mut Environment,
                                arg2: *mut Deffunction,
                                arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Undeffunction(arg1: *mut Deffunction, arg2: *mut Environment)
     -> bool;
}
extern "C" {
    pub fn GetDeffunctionListFunction(arg1: *mut Environment,
                                      arg2: *mut UDFContext,
                                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDeffunctionModuleCommand(arg1: *mut Environment,
                                       arg2: *mut UDFContext,
                                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn LookupDeffunctionByMdlOrScope(arg1: *mut Environment,
                                         arg2: *const ::std::os::raw::c_char)
     -> *mut Deffunction;
}
extern "C" {
    pub fn LookupDeffunctionInScope(arg1: *mut Environment,
                                    arg2: *const ::std::os::raw::c_char)
     -> *mut Deffunction;
}
extern "C" {
    pub fn RemoveDeffunction(arg1: *mut Environment, arg2: *mut Deffunction);
}
extern "C" {
    pub fn SetupDeffunctions(arg1: *mut Environment);
}
extern "C" {
    pub fn UndeffunctionCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeffunctionGetWatch(arg1: *mut Deffunction) -> bool;
}
extern "C" {
    pub fn ListDeffunctions(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *mut Defmodule);
}
extern "C" {
    pub fn DeffunctionSetWatch(arg1: *mut Deffunction, arg2: bool);
}
extern "C" {
    pub fn ListDeffunctionsCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDeffunctionCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defgenericModule {
    pub header: defmoduleItemHeader,
}
#[test]
fn bindgen_test_layout_defgenericModule() {
    assert_eq!(::std::mem::size_of::<defgenericModule>() , 24usize , concat !
               ( "Size of: " , stringify ! ( defgenericModule ) ));
    assert_eq! (::std::mem::align_of::<defgenericModule>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( defgenericModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericModule ) ) . header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericModule ) ,
                "::" , stringify ! ( header ) ));
}
impl Clone for defgenericModule {
    fn clone(&self) -> Self { *self }
}
pub type DEFGENERIC_MODULE = defgenericModule;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct restriction {
    pub types: *mut *mut ::std::os::raw::c_void,
    pub query: *mut Expression,
    pub tcnt: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_restriction() {
    assert_eq!(::std::mem::size_of::<restriction>() , 24usize , concat ! (
               "Size of: " , stringify ! ( restriction ) ));
    assert_eq! (::std::mem::align_of::<restriction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( restriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const restriction ) ) . types as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( restriction ) , "::" ,
                stringify ! ( types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const restriction ) ) . query as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( restriction ) , "::" ,
                stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const restriction ) ) . tcnt as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( restriction ) , "::" ,
                stringify ! ( tcnt ) ));
}
impl Clone for restriction {
    fn clone(&self) -> Self { *self }
}
pub type RESTRICTION = restriction;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defmethod {
    pub header: ConstructHeader,
    pub index: ::std::os::raw::c_ushort,
    pub busy: ::std::os::raw::c_uint,
    pub restrictionCount: ::std::os::raw::c_ushort,
    pub minRestrictions: ::std::os::raw::c_ushort,
    pub maxRestrictions: ::std::os::raw::c_ushort,
    pub localVarCount: ::std::os::raw::c_ushort,
    pub _bitfield_1: u8,
    pub restrictions: *mut RESTRICTION,
    pub actions: *mut Expression,
}
#[test]
fn bindgen_test_layout_defmethod() {
    assert_eq!(::std::mem::size_of::<defmethod>() , 104usize , concat ! (
               "Size of: " , stringify ! ( defmethod ) ));
    assert_eq! (::std::mem::align_of::<defmethod>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defmethod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . index as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . busy as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( busy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . restrictionCount as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( restrictionCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . minRestrictions as *
                const _ as usize } , 74usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( minRestrictions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . maxRestrictions as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( maxRestrictions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . localVarCount as * const
                _ as usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( localVarCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . restrictions as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( restrictions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmethod ) ) . actions as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( defmethod ) , "::" ,
                stringify ! ( actions ) ));
}
impl Clone for defmethod {
    fn clone(&self) -> Self { *self }
}
impl defmethod {
    #[inline]
    pub fn system(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_system(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn trace(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(system: ::std::os::raw::c_uint,
                          trace: ::std::os::raw::c_uint) -> u8 {
        ({ ({ 0 } | ((system as u32 as u8) << 0usize) & (1u64 as u8)) } |
             ((trace as u32 as u8) << 1usize) & (2u64 as u8))
    }
}
pub type Defmethod = defmethod;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defgeneric {
    pub header: ConstructHeader,
    pub busy: ::std::os::raw::c_uint,
    pub trace: bool,
    pub methods: *mut Defmethod,
    pub mcnt: ::std::os::raw::c_ushort,
    pub new_index: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_defgeneric() {
    assert_eq!(::std::mem::size_of::<defgeneric>() , 88usize , concat ! (
               "Size of: " , stringify ! ( defgeneric ) ));
    assert_eq! (::std::mem::align_of::<defgeneric>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defgeneric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgeneric ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defgeneric ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgeneric ) ) . busy as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( defgeneric ) , "::" ,
                stringify ! ( busy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgeneric ) ) . trace as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( defgeneric ) , "::" ,
                stringify ! ( trace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgeneric ) ) . methods as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( defgeneric ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgeneric ) ) . mcnt as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( defgeneric ) , "::" ,
                stringify ! ( mcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgeneric ) ) . new_index as * const _
                as usize } , 82usize , concat ! (
                "Alignment of field: " , stringify ! ( defgeneric ) , "::" ,
                stringify ! ( new_index ) ));
}
impl Clone for defgeneric {
    fn clone(&self) -> Self { *self }
}
pub type Defgeneric = defgeneric;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defgenericData {
    pub DefgenericConstruct: *mut Construct,
    pub DefgenericModuleIndex: ::std::os::raw::c_uint,
    pub GenericEntityRecord: EntityRecord,
    pub WatchGenerics: bool,
    pub WatchMethods: bool,
    pub CurrentGeneric: *mut Defgeneric,
    pub CurrentMethod: *mut Defmethod,
    pub GenericCurrentArgument: *mut UDFValue,
    pub OldGenericBusySave: ::std::os::raw::c_uint,
    pub DefgenericCodeItem: *mut CodeGeneratorItem,
}
#[test]
fn bindgen_test_layout_defgenericData() {
    assert_eq!(::std::mem::size_of::<defgenericData>() , 176usize , concat ! (
               "Size of: " , stringify ! ( defgenericData ) ));
    assert_eq! (::std::mem::align_of::<defgenericData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defgenericData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) . DefgenericConstruct
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( DefgenericConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) .
                DefgenericModuleIndex as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( DefgenericModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) . GenericEntityRecord
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( GenericEntityRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) . WatchGenerics as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( WatchGenerics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) . WatchMethods as *
                const _ as usize } , 129usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( WatchMethods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) . CurrentGeneric as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( CurrentGeneric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) . CurrentMethod as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( CurrentMethod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) .
                GenericCurrentArgument as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( GenericCurrentArgument ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) . OldGenericBusySave
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( OldGenericBusySave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defgenericData ) ) . DefgenericCodeItem
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( defgenericData ) , "::"
                , stringify ! ( DefgenericCodeItem ) ));
}
impl Clone for defgenericData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ClearDefgenericsReady(arg1: *mut Environment,
                                 arg2: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn AllocateDefgenericModule(arg1: *mut Environment)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn FreeDefgenericModule(arg1: *mut Environment,
                                arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ClearDefmethods(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn RemoveAllExplicitMethods(arg1: *mut Environment,
                                    arg2: *mut Defgeneric) -> bool;
}
extern "C" {
    pub fn RemoveDefgeneric(arg1: *mut Environment, arg2: *mut Defgeneric);
}
extern "C" {
    pub fn ClearDefgenerics(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn MethodAlterError(arg1: *mut Environment, arg2: *mut Defgeneric);
}
extern "C" {
    pub fn DeleteMethodInfo(arg1: *mut Environment, arg2: *mut Defgeneric,
                            arg3: *mut Defmethod);
}
extern "C" {
    pub fn DestroyMethodInfo(arg1: *mut Environment, arg2: *mut Defgeneric,
                             arg3: *mut Defmethod);
}
extern "C" {
    pub fn MethodsExecuting(arg1: *mut Defgeneric) -> bool;
}
extern "C" {
    pub fn FindMethodByIndex(arg1: *mut Defgeneric,
                             arg2: ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn PrintMethod(arg1: *mut Environment, arg2: *mut Defmethod,
                       arg3: *mut StringBuilder);
}
extern "C" {
    pub fn PreviewGeneric(arg1: *mut Environment, arg2: *mut UDFContext,
                          arg3: *mut UDFValue);
}
extern "C" {
    pub fn CheckGenericExists(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: *const ::std::os::raw::c_char)
     -> *mut Defgeneric;
}
extern "C" {
    pub fn CheckMethodExists(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut Defgeneric,
                             arg4: ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn PrintGenericName(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *mut Defgeneric);
}
extern "C" {
    pub fn SetupGenericFunctions(arg1: *mut Environment);
}
extern "C" {
    pub fn FindDefgeneric(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char)
     -> *mut Defgeneric;
}
extern "C" {
    pub fn FindDefgenericInModule(arg1: *mut Environment,
                                  arg2: *const ::std::os::raw::c_char)
     -> *mut Defgeneric;
}
extern "C" {
    pub fn LookupDefgenericByMdlOrScope(arg1: *mut Environment,
                                        arg2: *const ::std::os::raw::c_char)
     -> *mut Defgeneric;
}
extern "C" {
    pub fn LookupDefgenericInScope(arg1: *mut Environment,
                                   arg2: *const ::std::os::raw::c_char)
     -> *mut Defgeneric;
}
extern "C" {
    pub fn GetNextDefgeneric(arg1: *mut Environment, arg2: *mut Defgeneric)
     -> *mut Defgeneric;
}
extern "C" {
    pub fn GetNextDefmethod(arg1: *mut Defgeneric,
                            arg2: ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn DefgenericIsDeletable(arg1: *mut Defgeneric) -> bool;
}
extern "C" {
    pub fn DefmethodIsDeletable(arg1: *mut Defgeneric,
                                arg2: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn UndefgenericCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefgenericModuleCommand(arg1: *mut Environment,
                                      arg2: *mut UDFContext,
                                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn UndefmethodCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefmethodPointer(arg1: *mut Defgeneric,
                               arg2: ::std::os::raw::c_long)
     -> *mut Defmethod;
}
extern "C" {
    pub fn Undefgeneric(arg1: *mut Defgeneric, arg2: *mut Environment)
     -> bool;
}
extern "C" {
    pub fn Undefmethod(arg1: *mut Defgeneric, arg2: ::std::os::raw::c_ushort,
                       arg3: *mut Environment) -> bool;
}
extern "C" {
    pub fn DefmethodDescription(arg1: *mut Defgeneric,
                                arg2: ::std::os::raw::c_ushort,
                                arg3: *mut StringBuilder);
}
extern "C" {
    pub fn DefgenericGetWatch(arg1: *mut Defgeneric) -> bool;
}
extern "C" {
    pub fn DefgenericSetWatch(arg1: *mut Defgeneric, arg2: bool);
}
extern "C" {
    pub fn DefmethodGetWatch(arg1: *mut Defgeneric,
                             arg2: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    pub fn DefmethodSetWatch(arg1: *mut Defgeneric,
                             arg2: ::std::os::raw::c_ushort, arg3: bool);
}
extern "C" {
    pub fn PPDefgenericCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDefmethodCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefmethodsCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn DefmethodPPForm(arg1: *mut Defgeneric,
                           arg2: ::std::os::raw::c_ushort)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ListDefgenericsCommand(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefgenerics(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *mut Defmodule);
}
extern "C" {
    pub fn ListDefmethods(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *mut Defgeneric);
}
extern "C" {
    pub fn GetDefgenericListFunction(arg1: *mut Environment,
                                     arg2: *mut UDFContext,
                                     arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefgenericList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                             arg3: *mut Defmodule);
}
extern "C" {
    pub fn GetDefmethodListCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefmethodList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                            arg3: *mut Defgeneric);
}
extern "C" {
    pub fn GetMethodRestrictionsCommand(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetMethodRestrictions(arg1: *mut Defgeneric,
                                 arg2: ::std::os::raw::c_ushort,
                                 arg3: *mut CLIPSValue);
}
extern "C" {
    pub fn SetNextDefgeneric(arg1: *mut Defgeneric, arg2: *mut Defgeneric);
}
extern "C" {
    pub fn DefgenericModule(arg1: *mut Defgeneric)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefgenericName(arg1: *mut Defgeneric)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefgenericPPForm(arg1: *mut Defgeneric)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetDefgenericNamePointer(arg1: *mut Defgeneric)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn SetDefgenericPPForm(arg1: *mut Environment, arg2: *mut Defgeneric,
                               arg3: *const ::std::os::raw::c_char);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ClassDefaultsMode { CONVENIENCE_MODE = 0, CONSERVATION_MODE = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defclassModule {
    pub header: defmoduleItemHeader,
}
#[test]
fn bindgen_test_layout_defclassModule() {
    assert_eq!(::std::mem::size_of::<defclassModule>() , 24usize , concat ! (
               "Size of: " , stringify ! ( defclassModule ) ));
    assert_eq! (::std::mem::align_of::<defclassModule>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defclassModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassModule ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassModule ) , "::"
                , stringify ! ( header ) ));
}
impl Clone for defclassModule {
    fn clone(&self) -> Self { *self }
}
pub type DEFCLASS_MODULE = defclassModule;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defclass {
    pub header: ConstructHeader,
    pub _bitfield_1: u8,
    pub id: ::std::os::raw::c_ushort,
    pub busy: ::std::os::raw::c_uint,
    pub hashTableIndex: ::std::os::raw::c_uint,
    pub directSuperclasses: PACKED_CLASS_LINKS,
    pub directSubclasses: PACKED_CLASS_LINKS,
    pub allSuperclasses: PACKED_CLASS_LINKS,
    pub slots: *mut SlotDescriptor,
    pub instanceTemplate: *mut *mut SlotDescriptor,
    pub slotNameMap: *mut ::std::os::raw::c_uint,
    pub slotCount: ::std::os::raw::c_ushort,
    pub localInstanceSlotCount: ::std::os::raw::c_ushort,
    pub instanceSlotCount: ::std::os::raw::c_ushort,
    pub maxSlotNameID: ::std::os::raw::c_ushort,
    pub instanceList: *mut Instance,
    pub instanceListBottom: *mut Instance,
    pub handlers: *mut DefmessageHandler,
    pub handlerOrderMap: *mut ::std::os::raw::c_uint,
    pub handlerCount: ::std::os::raw::c_ushort,
    pub nxtHash: *mut Defclass,
    pub scopeMap: *mut CLIPSBitMap,
    pub traversalRecord: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_defclass() {
    assert_eq!(::std::mem::size_of::<defclass>() , 248usize , concat ! (
               "Size of: " , stringify ! ( defclass ) ));
    assert_eq! (::std::mem::align_of::<defclass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . id as * const _ as usize }
                , 66usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . busy as * const _ as usize
                } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( busy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . hashTableIndex as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( hashTableIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . directSuperclasses as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( directSuperclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . directSubclasses as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( directSubclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . allSuperclasses as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( allSuperclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . slots as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( slots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . instanceTemplate as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( instanceTemplate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . slotNameMap as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( slotNameMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . slotCount as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( slotCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . localInstanceSlotCount as
                * const _ as usize } , 154usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( localInstanceSlotCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . instanceSlotCount as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( instanceSlotCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . maxSlotNameID as * const _
                as usize } , 158usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( maxSlotNameID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . instanceList as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( instanceList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . instanceListBottom as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( instanceListBottom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . handlers as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( handlers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . handlerOrderMap as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( handlerOrderMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . handlerCount as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( handlerCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . nxtHash as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( nxtHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . scopeMap as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( scopeMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclass ) ) . traversalRecord as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( defclass ) , "::" ,
                stringify ! ( traversalRecord ) ));
}
impl Clone for defclass {
    fn clone(&self) -> Self { *self }
}
impl defclass {
    #[inline]
    pub fn installed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_installed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn system(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_system(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn abstract_(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_abstract(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn reactive(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reactive(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn traceInstances(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_traceInstances(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn traceSlots(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_traceSlots(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(installed: ::std::os::raw::c_uint,
                          system: ::std::os::raw::c_uint,
                          abstract_: ::std::os::raw::c_uint,
                          reactive: ::std::os::raw::c_uint,
                          traceInstances: ::std::os::raw::c_uint,
                          traceSlots: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((installed as u32 as u8) << 0usize) &
                                          (1u64 as u8))
                             } |
                                 ((system as u32 as u8) << 1usize) &
                                     (2u64 as u8))
                        } |
                            ((abstract_ as u32 as u8) << 2usize) &
                                (4u64 as u8))
                   } | ((reactive as u32 as u8) << 3usize) & (8u64 as u8))
              } | ((traceInstances as u32 as u8) << 4usize) & (16u64 as u8))
         } | ((traceSlots as u32 as u8) << 5usize) & (32u64 as u8))
    }
}
pub type Defclass = defclass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct packedClassLinks {
    pub classCount: ::std::os::raw::c_ulong,
    pub classArray: *mut *mut Defclass,
}
#[test]
fn bindgen_test_layout_packedClassLinks() {
    assert_eq!(::std::mem::size_of::<packedClassLinks>() , 16usize , concat !
               ( "Size of: " , stringify ! ( packedClassLinks ) ));
    assert_eq! (::std::mem::align_of::<packedClassLinks>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( packedClassLinks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const packedClassLinks ) ) . classCount as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( packedClassLinks ) ,
                "::" , stringify ! ( classCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const packedClassLinks ) ) . classArray as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( packedClassLinks ) ,
                "::" , stringify ! ( classArray ) ));
}
impl Clone for packedClassLinks {
    fn clone(&self) -> Self { *self }
}
pub type PACKED_CLASS_LINKS = packedClassLinks;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct classLink {
    pub cls: *mut Defclass,
    pub nxt: *mut classLink,
}
#[test]
fn bindgen_test_layout_classLink() {
    assert_eq!(::std::mem::size_of::<classLink>() , 16usize , concat ! (
               "Size of: " , stringify ! ( classLink ) ));
    assert_eq! (::std::mem::align_of::<classLink>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( classLink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const classLink ) ) . cls as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( classLink ) , "::" ,
                stringify ! ( cls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const classLink ) ) . nxt as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( classLink ) , "::" ,
                stringify ! ( nxt ) ));
}
impl Clone for classLink {
    fn clone(&self) -> Self { *self }
}
pub type CLASS_LINK = classLink;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct slotName {
    pub hashTableIndex: ::std::os::raw::c_uint,
    pub use_: ::std::os::raw::c_uint,
    pub id: ::std::os::raw::c_ushort,
    pub name: *mut CLIPSLexeme,
    pub putHandlerName: *mut CLIPSLexeme,
    pub nxt: *mut slotName,
    pub bsaveIndex: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_slotName() {
    assert_eq!(::std::mem::size_of::<slotName>() , 48usize , concat ! (
               "Size of: " , stringify ! ( slotName ) ));
    assert_eq! (::std::mem::align_of::<slotName>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( slotName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotName ) ) . hashTableIndex as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( slotName ) , "::" ,
                stringify ! ( hashTableIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotName ) ) . use_ as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( slotName ) , "::" ,
                stringify ! ( use_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotName ) ) . id as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( slotName ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotName ) ) . name as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( slotName ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotName ) ) . putHandlerName as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( slotName ) , "::" ,
                stringify ! ( putHandlerName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotName ) ) . nxt as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( slotName ) , "::" ,
                stringify ! ( nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotName ) ) . bsaveIndex as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( slotName ) , "::" ,
                stringify ! ( bsaveIndex ) ));
}
impl Clone for slotName {
    fn clone(&self) -> Self { *self }
}
pub type SLOT_NAME = slotName;
#[repr(C)]
#[derive(Copy)]
pub struct slotDescriptor {
    pub _bitfield_1: [u8; 2usize],
    pub cls: *mut Defclass,
    pub slotName: *mut SLOT_NAME,
    pub overrideMessage: *mut CLIPSLexeme,
    pub defaultValue: *mut ::std::os::raw::c_void,
    pub constraint: *mut CONSTRAINT_RECORD,
    pub sharedCount: ::std::os::raw::c_uint,
    pub bsaveIndex: ::std::os::raw::c_ulong,
    pub sharedValue: InstanceSlot,
}
#[test]
fn bindgen_test_layout_slotDescriptor() {
    assert_eq!(::std::mem::size_of::<slotDescriptor>() , 88usize , concat ! (
               "Size of: " , stringify ! ( slotDescriptor ) ));
    assert_eq! (::std::mem::align_of::<slotDescriptor>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( slotDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotDescriptor ) ) . cls as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( slotDescriptor ) , "::"
                , stringify ! ( cls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotDescriptor ) ) . slotName as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( slotDescriptor ) , "::"
                , stringify ! ( slotName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotDescriptor ) ) . overrideMessage as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( slotDescriptor ) , "::"
                , stringify ! ( overrideMessage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotDescriptor ) ) . defaultValue as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( slotDescriptor ) , "::"
                , stringify ! ( defaultValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotDescriptor ) ) . constraint as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( slotDescriptor ) , "::"
                , stringify ! ( constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotDescriptor ) ) . sharedCount as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( slotDescriptor ) , "::"
                , stringify ! ( sharedCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotDescriptor ) ) . bsaveIndex as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( slotDescriptor ) , "::"
                , stringify ! ( bsaveIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotDescriptor ) ) . sharedValue as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( slotDescriptor ) , "::"
                , stringify ! ( sharedValue ) ));
}
impl Clone for slotDescriptor {
    fn clone(&self) -> Self { *self }
}
impl slotDescriptor {
    #[inline]
    pub fn shared(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn multiple(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_multiple(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn composite(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_composite(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn noInherit(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_noInherit(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn noWrite(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_noWrite(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn initializeOnly(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_initializeOnly(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn dynamicDefault(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dynamicDefault(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 64u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn defaultSpecified(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_defaultSpecified(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn noDefault(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_noDefault(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 256u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn reactive(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reactive(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 512u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn publicVisibility(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_publicVisibility(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1024u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn createReadAccessor(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2048u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_createReadAccessor(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn createWriteAccessor(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4096u64 as u16;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_createWriteAccessor(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn overrideMessageSpecified(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8192u64 as u16;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_overrideMessageSpecified(&mut self,
                                        val: ::std::os::raw::c_uint) {
        let mask = 8192u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(shared: ::std::os::raw::c_uint,
                          multiple: ::std::os::raw::c_uint,
                          composite: ::std::os::raw::c_uint,
                          noInherit: ::std::os::raw::c_uint,
                          noWrite: ::std::os::raw::c_uint,
                          initializeOnly: ::std::os::raw::c_uint,
                          dynamicDefault: ::std::os::raw::c_uint,
                          defaultSpecified: ::std::os::raw::c_uint,
                          noDefault: ::std::os::raw::c_uint,
                          reactive: ::std::os::raw::c_uint,
                          publicVisibility: ::std::os::raw::c_uint,
                          createReadAccessor: ::std::os::raw::c_uint,
                          createWriteAccessor: ::std::os::raw::c_uint,
                          overrideMessageSpecified: ::std::os::raw::c_uint)
     -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              0
                                                                          } |
                                                                              ((shared
                                                                                    as
                                                                                    u32
                                                                                    as
                                                                                    u16)
                                                                                   <<
                                                                                   0usize)
                                                                                  &
                                                                                  (1u64
                                                                                       as
                                                                                       u16))
                                                                     } |
                                                                         ((multiple
                                                                               as
                                                                               u32
                                                                               as
                                                                               u16)
                                                                              <<
                                                                              1usize)
                                                                             &
                                                                             (2u64
                                                                                  as
                                                                                  u16))
                                                                } |
                                                                    ((composite
                                                                          as
                                                                          u32
                                                                          as
                                                                          u16)
                                                                         <<
                                                                         2usize)
                                                                        &
                                                                        (4u64
                                                                             as
                                                                             u16))
                                                           } |
                                                               ((noInherit as
                                                                     u32 as
                                                                     u16) <<
                                                                    3usize) &
                                                                   (8u64 as
                                                                        u16))
                                                      } |
                                                          ((noWrite as u32 as
                                                                u16) <<
                                                               4usize) &
                                                              (16u64 as u16))
                                                 } |
                                                     ((initializeOnly as u32
                                                           as u16) << 5usize)
                                                         & (32u64 as u16))
                                            } |
                                                ((dynamicDefault as u32 as
                                                      u16) << 6usize) &
                                                    (64u64 as u16))
                                       } |
                                           ((defaultSpecified as u32 as u16)
                                                << 7usize) & (128u64 as u16))
                                  } |
                                      ((noDefault as u32 as u16) << 8usize) &
                                          (256u64 as u16))
                             } |
                                 ((reactive as u32 as u16) << 9usize) &
                                     (512u64 as u16))
                        } |
                            ((publicVisibility as u32 as u16) << 10usize) &
                                (1024u64 as u16))
                   } |
                       ((createReadAccessor as u32 as u16) << 11usize) &
                           (2048u64 as u16))
              } |
                  ((createWriteAccessor as u32 as u16) << 12usize) &
                      (4096u64 as u16))
         } |
             ((overrideMessageSpecified as u32 as u16) << 13usize) &
                 (8192u64 as u16))
    }
}
pub type SlotDescriptor = slotDescriptor;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct defmessageHandler {
    pub header: ConstructHeader,
    pub _bitfield_1: u8,
    pub busy: ::std::os::raw::c_uint,
    pub cls: *mut Defclass,
    pub minParams: ::std::os::raw::c_ushort,
    pub maxParams: ::std::os::raw::c_ushort,
    pub localVarCount: ::std::os::raw::c_ushort,
    pub actions: *mut Expression,
}
#[test]
fn bindgen_test_layout_defmessageHandler() {
    assert_eq!(::std::mem::size_of::<defmessageHandler>() , 96usize , concat !
               ( "Size of: " , stringify ! ( defmessageHandler ) ));
    assert_eq! (::std::mem::align_of::<defmessageHandler>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( defmessageHandler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmessageHandler ) ) . header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defmessageHandler ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmessageHandler ) ) . busy as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( defmessageHandler ) ,
                "::" , stringify ! ( busy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmessageHandler ) ) . cls as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( defmessageHandler ) ,
                "::" , stringify ! ( cls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmessageHandler ) ) . minParams as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( defmessageHandler ) ,
                "::" , stringify ! ( minParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmessageHandler ) ) . maxParams as *
                const _ as usize } , 82usize , concat ! (
                "Alignment of field: " , stringify ! ( defmessageHandler ) ,
                "::" , stringify ! ( maxParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmessageHandler ) ) . localVarCount as
                * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( defmessageHandler ) ,
                "::" , stringify ! ( localVarCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defmessageHandler ) ) . actions as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( defmessageHandler ) ,
                "::" , stringify ! ( actions ) ));
}
impl Clone for defmessageHandler {
    fn clone(&self) -> Self { *self }
}
impl defmessageHandler {
    #[inline]
    pub fn system(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_system(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 6u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 6u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn mark(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mark(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn trace(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(system: ::std::os::raw::c_uint,
                          type_: ::std::os::raw::c_uint,
                          mark: ::std::os::raw::c_uint,
                          trace: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((system as u32 as u8) << 0usize) & (1u64 as u8))
                   } | ((type_ as u32 as u8) << 1usize) & (6u64 as u8))
              } | ((mark as u32 as u8) << 3usize) & (8u64 as u8))
         } | ((trace as u32 as u8) << 4usize) & (16u64 as u8))
    }
}
pub type DefmessageHandler = defmessageHandler;
#[repr(C)]
#[derive(Copy)]
pub struct instanceSlot {
    pub desc: *mut SlotDescriptor,
    pub _bitfield_1: u8,
    pub type_: ::std::os::raw::c_ushort,
    pub __bindgen_anon_1: instanceSlot__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union instanceSlot__bindgen_ty_1 {
    pub value: *mut ::std::os::raw::c_void,
    pub header: *mut TypeHeader,
    pub lexemeValue: *mut CLIPSLexeme,
    pub floatValue: *mut CLIPSFloat,
    pub integerValue: *mut CLIPSInteger,
    pub voidValue: *mut CLIPSVoid,
    pub factValue: *mut Fact,
    pub instanceValue: *mut Instance,
    pub multifieldValue: *mut Multifield,
    pub externalAddressValue: *mut CLIPSExternalAddress,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_instanceSlot__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<instanceSlot__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( instanceSlot__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<instanceSlot__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( instanceSlot__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) . value as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! ( value )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) . header
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! ( header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) .
                lexemeValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! (
                lexemeValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) .
                floatValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! ( floatValue
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) .
                integerValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! (
                integerValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) .
                voidValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! ( voidValue
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) .
                factValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! ( factValue
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) .
                instanceValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! (
                instanceValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) .
                multifieldValue as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! (
                multifieldValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot__bindgen_ty_1 ) ) .
                externalAddressValue as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                instanceSlot__bindgen_ty_1 ) , "::" , stringify ! (
                externalAddressValue ) ));
}
impl Clone for instanceSlot__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_instanceSlot() {
    assert_eq!(::std::mem::size_of::<instanceSlot>() , 24usize , concat ! (
               "Size of: " , stringify ! ( instanceSlot ) ));
    assert_eq! (::std::mem::align_of::<instanceSlot>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( instanceSlot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot ) ) . desc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceSlot ) , "::" ,
                stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceSlot ) ) . type_ as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceSlot ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for instanceSlot {
    fn clone(&self) -> Self { *self }
}
impl instanceSlot {
    #[inline]
    pub fn valueRequired(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_valueRequired(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn override_(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_override(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(valueRequired: ::std::os::raw::c_uint,
                          override_: ::std::os::raw::c_uint) -> u8 {
        ({ ({ 0 } | ((valueRequired as u32 as u8) << 0usize) & (1u64 as u8)) }
             | ((override_ as u32 as u8) << 1usize) & (2u64 as u8))
    }
}
pub type InstanceSlot = instanceSlot;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct instanceBuilder {
    pub ibEnv: *mut Environment,
    pub ibDefclass: *mut Defclass,
    pub ibValueArray: *mut CLIPSValue,
}
#[test]
fn bindgen_test_layout_instanceBuilder() {
    assert_eq!(::std::mem::size_of::<instanceBuilder>() , 24usize , concat ! (
               "Size of: " , stringify ! ( instanceBuilder ) ));
    assert_eq! (::std::mem::align_of::<instanceBuilder>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( instanceBuilder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceBuilder ) ) . ibEnv as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceBuilder ) ,
                "::" , stringify ! ( ibEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceBuilder ) ) . ibDefclass as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceBuilder ) ,
                "::" , stringify ! ( ibDefclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceBuilder ) ) . ibValueArray as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceBuilder ) ,
                "::" , stringify ! ( ibValueArray ) ));
}
impl Clone for instanceBuilder {
    fn clone(&self) -> Self { *self }
}
pub type InstanceBuilder = instanceBuilder;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct instanceModifier {
    pub imEnv: *mut Environment,
    pub imOldInstance: *mut Instance,
    pub imValueArray: *mut CLIPSValue,
    pub changeMap: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_instanceModifier() {
    assert_eq!(::std::mem::size_of::<instanceModifier>() , 32usize , concat !
               ( "Size of: " , stringify ! ( instanceModifier ) ));
    assert_eq! (::std::mem::align_of::<instanceModifier>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( instanceModifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceModifier ) ) . imEnv as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceModifier ) ,
                "::" , stringify ! ( imEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceModifier ) ) . imOldInstance as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceModifier ) ,
                "::" , stringify ! ( imOldInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceModifier ) ) . imValueArray as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceModifier ) ,
                "::" , stringify ! ( imValueArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceModifier ) ) . changeMap as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceModifier ) ,
                "::" , stringify ! ( changeMap ) ));
}
impl Clone for instanceModifier {
    fn clone(&self) -> Self { *self }
}
pub type InstanceModifier = instanceModifier;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct multifieldBuilder {
    pub mbEnv: *mut Environment,
    pub contents: *mut CLIPSValue,
    pub bufferReset: usize,
    pub length: usize,
    pub bufferMaximum: usize,
}
#[test]
fn bindgen_test_layout_multifieldBuilder() {
    assert_eq!(::std::mem::size_of::<multifieldBuilder>() , 40usize , concat !
               ( "Size of: " , stringify ! ( multifieldBuilder ) ));
    assert_eq! (::std::mem::align_of::<multifieldBuilder>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( multifieldBuilder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldBuilder ) ) . mbEnv as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldBuilder ) ,
                "::" , stringify ! ( mbEnv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldBuilder ) ) . contents as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldBuilder ) ,
                "::" , stringify ! ( contents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldBuilder ) ) . bufferReset as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldBuilder ) ,
                "::" , stringify ! ( bufferReset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldBuilder ) ) . length as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldBuilder ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multifieldBuilder ) ) . bufferMaximum as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( multifieldBuilder ) ,
                "::" , stringify ! ( bufferMaximum ) ));
}
impl Clone for multifieldBuilder {
    fn clone(&self) -> Self { *self }
}
pub type MultifieldBuilder = multifieldBuilder;
extern "C" {
    pub fn CreateUnmanagedMultifield(arg1: *mut Environment, arg2: usize)
     -> *mut Multifield;
}
extern "C" {
    pub fn ReturnMultifield(arg1: *mut Environment, arg2: *mut Multifield);
}
extern "C" {
    pub fn RetainMultifield(arg1: *mut Environment, arg2: *mut Multifield);
}
extern "C" {
    pub fn ReleaseMultifield(arg1: *mut Environment, arg2: *mut Multifield);
}
extern "C" {
    pub fn IncrementCLIPSValueMultifieldReferenceCount(arg1: *mut Environment,
                                                       arg2: *mut Multifield);
}
extern "C" {
    pub fn DecrementCLIPSValueMultifieldReferenceCount(arg1: *mut Environment,
                                                       arg2: *mut Multifield);
}
extern "C" {
    pub fn StringToMultifield(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char)
     -> *mut Multifield;
}
extern "C" {
    pub fn CreateMultifield(arg1: *mut Environment, arg2: usize)
     -> *mut Multifield;
}
extern "C" {
    pub fn AddToMultifieldList(arg1: *mut Environment, arg2: *mut Multifield);
}
extern "C" {
    pub fn FlushMultifields(arg1: *mut Environment);
}
extern "C" {
    pub fn DuplicateMultifield(arg1: *mut Environment, arg2: *mut UDFValue,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn WriteMultifield(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *mut Multifield);
}
extern "C" {
    pub fn PrintMultifieldDriver(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut Multifield, arg4: usize,
                                 arg5: usize, arg6: bool);
}
extern "C" {
    pub fn MultifieldDOsEqual(arg1: *mut UDFValue, arg2: *mut UDFValue)
     -> bool;
}
extern "C" {
    pub fn StoreInMultifield(arg1: *mut Environment, arg2: *mut UDFValue,
                             arg3: *mut Expression, arg4: bool);
}
extern "C" {
    pub fn CopyMultifield(arg1: *mut Environment, arg2: *mut Multifield)
     -> *mut Multifield;
}
extern "C" {
    pub fn MultifieldsEqual(arg1: *mut Multifield, arg2: *mut Multifield)
     -> bool;
}
extern "C" {
    pub fn DOToMultifield(arg1: *mut Environment, arg2: *mut UDFValue)
     -> *mut Multifield;
}
extern "C" {
    pub fn HashMultifield(arg1: *mut Multifield, arg2: usize) -> usize;
}
extern "C" {
    pub fn GetMultifieldList(arg1: *mut Environment) -> *mut Multifield;
}
extern "C" {
    pub fn ImplodeMultifield(arg1: *mut Environment, arg2: *mut UDFValue)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn EphemerateMultifield(arg1: *mut Environment,
                                arg2: *mut Multifield);
}
extern "C" {
    pub fn ArrayToMultifield(arg1: *mut Environment, arg2: *mut CLIPSValue,
                             arg3: ::std::os::raw::c_ulong)
     -> *mut Multifield;
}
extern "C" {
    pub fn NormalizeMultifield(arg1: *mut Environment, arg2: *mut UDFValue);
}
extern "C" {
    pub fn CLIPSToUDFValue(arg1: *mut CLIPSValue, arg2: *mut UDFValue);
}
extern "C" {
    pub fn UDFToCLIPSValue(arg1: *mut Environment, arg2: *mut UDFValue,
                           arg3: *mut CLIPSValue);
}
extern "C" {
    pub fn CreateMultifieldBuilder(arg1: *mut Environment, arg2: usize)
     -> *mut MultifieldBuilder;
}
extern "C" {
    pub fn MBReset(arg1: *mut MultifieldBuilder);
}
extern "C" {
    pub fn MBDispose(arg1: *mut MultifieldBuilder);
}
extern "C" {
    pub fn MBAppend(theMB: *mut MultifieldBuilder, arg1: *mut CLIPSValue);
}
extern "C" {
    pub fn MBCreate(arg1: *mut MultifieldBuilder) -> *mut Multifield;
}
extern "C" {
    pub fn EmptyMultifield(arg1: *mut Environment) -> *mut Multifield;
}
extern "C" {
    pub fn MBAppendCLIPSInteger(arg1: *mut MultifieldBuilder,
                                arg2: *mut CLIPSInteger);
}
extern "C" {
    pub fn MBAppendInteger(arg1: *mut MultifieldBuilder,
                           arg2: ::std::os::raw::c_longlong);
}
extern "C" {
    pub fn MBAppendCLIPSFloat(arg1: *mut MultifieldBuilder,
                              arg2: *mut CLIPSFloat);
}
extern "C" {
    pub fn MBAppendFloat(arg1: *mut MultifieldBuilder, arg2: f64);
}
extern "C" {
    pub fn MBAppendCLIPSLexeme(arg1: *mut MultifieldBuilder,
                               arg2: *mut CLIPSLexeme);
}
extern "C" {
    pub fn MBAppendSymbol(arg1: *mut MultifieldBuilder,
                          arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn MBAppendString(arg1: *mut MultifieldBuilder,
                          arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn MBAppendInstanceName(arg1: *mut MultifieldBuilder,
                                arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn MBAppendCLIPSExternalAddress(arg1: *mut MultifieldBuilder,
                                        arg2: *mut CLIPSExternalAddress);
}
extern "C" {
    pub fn MBAppendFact(arg1: *mut MultifieldBuilder, arg2: *mut Fact);
}
extern "C" {
    pub fn MBAppendInstance(arg1: *mut MultifieldBuilder,
                            arg2: *mut Instance);
}
extern "C" {
    pub fn MBAppendMultifield(arg1: *mut MultifieldBuilder,
                              arg2: *mut Multifield);
}
extern "C" {
    pub fn MBAppendUDFValue(theMB: *mut MultifieldBuilder,
                            arg1: *mut UDFValue);
}
extern "C" {
    pub fn DefclassName(arg1: *mut Defclass) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefclassPPForm(arg1: *mut Defclass)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetDefclassModule(arg1: *mut Environment, arg2: *mut Defclass)
     -> *mut defmoduleItemHeader;
}
extern "C" {
    pub fn DefclassModule(arg1: *mut Defclass)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetDefclassNamePointer(arg1: *mut Defclass) -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn SetNextDefclass(arg1: *mut Defclass, arg2: *mut Defclass);
}
extern "C" {
    pub fn SetDefclassPPForm(arg1: *mut Environment, arg2: *mut Defclass,
                             arg3: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn FindDefclass(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char) -> *mut Defclass;
}
extern "C" {
    pub fn FindDefclassInModule(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char)
     -> *mut Defclass;
}
extern "C" {
    pub fn LookupDefclassByMdlOrScope(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char)
     -> *mut Defclass;
}
extern "C" {
    pub fn LookupDefclassInScope(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char)
     -> *mut Defclass;
}
extern "C" {
    pub fn LookupDefclassAnywhere(arg1: *mut Environment,
                                  arg2: *mut Defmodule,
                                  arg3: *const ::std::os::raw::c_char)
     -> *mut Defclass;
}
extern "C" {
    pub fn DefclassInScope(arg1: *mut Environment, arg2: *mut Defclass,
                           arg3: *mut Defmodule) -> bool;
}
extern "C" {
    pub fn GetNextDefclass(arg1: *mut Environment, arg2: *mut Defclass)
     -> *mut Defclass;
}
extern "C" {
    pub fn DefclassIsDeletable(arg1: *mut Defclass) -> bool;
}
extern "C" {
    pub fn UndefclassCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetClassDefaultsMode(arg1: *mut Environment,
                                arg2: ClassDefaultsMode) -> ClassDefaultsMode;
}
extern "C" {
    pub fn GetClassDefaultsMode(arg1: *mut Environment) -> ClassDefaultsMode;
}
extern "C" {
    pub fn GetClassDefaultsModeCommand(arg1: *mut Environment,
                                       arg2: *mut UDFContext,
                                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetClassDefaultsModeCommand(arg1: *mut Environment,
                                       arg2: *mut UDFContext,
                                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDefclassCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefclassesCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefclasses(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *mut Defmodule);
}
extern "C" {
    pub fn DefclassGetWatchInstances(arg1: *mut Defclass) -> bool;
}
extern "C" {
    pub fn DefclassSetWatchInstances(arg1: *mut Defclass, arg2: bool);
}
extern "C" {
    pub fn DefclassGetWatchSlots(arg1: *mut Defclass) -> bool;
}
extern "C" {
    pub fn DefclassSetWatchSlots(arg1: *mut Defclass, arg2: bool);
}
extern "C" {
    pub fn DefclassWatchAccess(arg1: *mut Environment,
                               arg2: ::std::os::raw::c_int, arg3: bool,
                               arg4: *mut Expression) -> bool;
}
extern "C" {
    pub fn DefclassWatchPrint(arg1: *mut Environment,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: ::std::os::raw::c_int,
                              arg4: *mut Expression) -> bool;
}
extern "C" {
    pub fn GetDefclassListFunction(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefclassList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                           arg3: *mut Defmodule);
}
extern "C" {
    pub fn Undefclass(arg1: *mut Defclass, arg2: *mut Environment) -> bool;
}
extern "C" {
    pub fn HasSuperclass(arg1: *mut Defclass, arg2: *mut Defclass) -> bool;
}
extern "C" {
    pub fn CheckClassAndSlot(arg1: *mut UDFContext,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut *mut Defclass) -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn SaveDefclasses(arg1: *mut Environment, arg2: *mut Defmodule,
                          arg3: *const ::std::os::raw::c_char,
                          arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn BrowseClassesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn BrowseClasses(arg1: *mut Defclass,
                         arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn DescribeClassCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn DescribeClass(arg1: *mut Defclass,
                         arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn GetCreateAccessorString(arg1: *mut SlotDescriptor)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetDefclassModuleCommand(arg1: *mut Environment,
                                    arg2: *mut UDFContext,
                                    arg3: *mut UDFValue);
}
extern "C" {
    pub fn SuperclassPCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn SuperclassP(arg1: *mut Defclass, arg2: *mut Defclass) -> bool;
}
extern "C" {
    pub fn SubclassPCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn SubclassP(arg1: *mut Defclass, arg2: *mut Defclass) -> bool;
}
extern "C" {
    pub fn SlotExistPCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotExistP(arg1: *mut Defclass,
                      arg2: *const ::std::os::raw::c_char, arg3: bool)
     -> bool;
}
extern "C" {
    pub fn MessageHandlerExistPCommand(arg1: *mut Environment,
                                       arg2: *mut UDFContext,
                                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotWritablePCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotWritableP(arg1: *mut Defclass,
                         arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn SlotInitablePCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotInitableP(arg1: *mut Defclass,
                         arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn SlotPublicPCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotPublicP(arg1: *mut Defclass,
                       arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn SlotDirectAccessPCommand(arg1: *mut Environment,
                                    arg2: *mut UDFContext,
                                    arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotDirectAccessP(arg1: *mut Defclass,
                             arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn SlotDefaultValueCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotDefaultValue(arg1: *mut Defclass,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn ClassExistPCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotDefaultP(arg1: *mut Environment, arg2: *mut Defclass,
                        arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IncrementDefclassBusyCount(arg1: *mut Environment,
                                      arg2: *mut Defclass);
}
extern "C" {
    pub fn DecrementDefclassBusyCount(arg1: *mut Environment,
                                      arg2: *mut Defclass);
}
extern "C" {
    pub fn InstancesPurge(arg1: *mut Environment,
                          arg2: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn InitializeClasses(arg1: *mut Environment);
}
extern "C" {
    pub fn FindClassSlot(arg1: *mut Defclass, arg2: *mut CLIPSLexeme)
     -> *mut SlotDescriptor;
}
extern "C" {
    pub fn ClassExistError(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn DeleteClassLinks(arg1: *mut Environment, arg2: *mut CLASS_LINK);
}
extern "C" {
    pub fn PrintClassName(arg1: *mut Environment,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: *mut Defclass, arg4: bool, arg5: bool);
}
extern "C" {
    pub fn PrintPackedClassLinks(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *const ::std::os::raw::c_char,
                                 arg4: *mut PACKED_CLASS_LINKS);
}
extern "C" {
    pub fn PutClassInTable(arg1: *mut Environment, arg2: *mut Defclass);
}
extern "C" {
    pub fn RemoveClassFromTable(arg1: *mut Environment, arg2: *mut Defclass);
}
extern "C" {
    pub fn AddClassLink(arg1: *mut Environment, arg2: *mut PACKED_CLASS_LINKS,
                        arg3: *mut Defclass, arg4: bool,
                        arg5: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn DeleteSubclassLink(arg1: *mut Environment, arg2: *mut Defclass,
                              arg3: *mut Defclass);
}
extern "C" {
    pub fn DeleteSuperclassLink(arg1: *mut Environment, arg2: *mut Defclass,
                                arg3: *mut Defclass);
}
extern "C" {
    pub fn NewClass(arg1: *mut Environment, arg2: *mut CLIPSLexeme)
     -> *mut Defclass;
}
extern "C" {
    pub fn DeletePackedClassLinks(arg1: *mut Environment,
                                  arg2: *mut PACKED_CLASS_LINKS, arg3: bool);
}
extern "C" {
    pub fn AssignClassID(arg1: *mut Environment, arg2: *mut Defclass);
}
extern "C" {
    pub fn AddSlotName(arg1: *mut Environment, arg2: *mut CLIPSLexeme,
                       arg3: ::std::os::raw::c_ushort, arg4: bool)
     -> *mut SLOT_NAME;
}
extern "C" {
    pub fn DeleteSlotName(arg1: *mut Environment, arg2: *mut SLOT_NAME);
}
extern "C" {
    pub fn RemoveDefclass(arg1: *mut Environment, arg2: *mut Defclass);
}
extern "C" {
    pub fn InstallClass(arg1: *mut Environment, arg2: *mut Defclass,
                        arg3: bool);
}
extern "C" {
    pub fn DestroyDefclass(arg1: *mut Environment, arg2: *mut Defclass);
}
extern "C" {
    pub fn IsClassBeingUsed(arg1: *mut Defclass) -> bool;
}
extern "C" {
    pub fn RemoveAllUserClasses(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn DeleteClassUAG(arg1: *mut Environment, arg2: *mut Defclass)
     -> bool;
}
extern "C" {
    pub fn MarkBitMapSubclasses(arg1: *mut ::std::os::raw::c_char,
                                arg2: *mut Defclass,
                                arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn FindSlotNameID(arg1: *mut Environment, arg2: *mut CLIPSLexeme)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn FindIDSlotName(arg1: *mut Environment,
                          arg2: ::std::os::raw::c_ushort) -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn FindIDSlotNameHash(arg1: *mut Environment,
                              arg2: ::std::os::raw::c_ushort)
     -> *mut SLOT_NAME;
}
extern "C" {
    pub fn GetTraversalID(arg1: *mut Environment) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ReleaseTraversalID(arg1: *mut Environment);
}
extern "C" {
    pub fn HashClass(arg1: *mut CLIPSLexeme) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Copy)]
pub struct defclassData {
    pub DefclassConstruct: *mut Construct,
    pub DefclassModuleIndex: ::std::os::raw::c_uint,
    pub DefclassEntityRecord: EntityRecord,
    pub PrimitiveClassMap: [*mut Defclass; 9usize],
    pub ClassIDMap: *mut *mut Defclass,
    pub ClassTable: *mut *mut Defclass,
    pub MaxClassID: ::std::os::raw::c_ushort,
    pub AvailClassID: ::std::os::raw::c_ushort,
    pub SlotNameTable: *mut *mut SLOT_NAME,
    pub ISA_SYMBOL: *mut CLIPSLexeme,
    pub NAME_SYMBOL: *mut CLIPSLexeme,
    pub WatchInstances: bool,
    pub WatchSlots: bool,
    pub CTID: ::std::os::raw::c_ushort,
    pub ObjectParseToken: token,
    pub ClassDefaultsModeValue: ClassDefaultsMode,
}
#[test]
fn bindgen_test_layout_defclassData() {
    assert_eq!(::std::mem::size_of::<defclassData>() , 288usize , concat ! (
               "Size of: " , stringify ! ( defclassData ) ));
    assert_eq! (::std::mem::align_of::<defclassData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( defclassData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . DefclassConstruct as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( DefclassConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . DefclassModuleIndex as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( DefclassModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . DefclassEntityRecord
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( DefclassEntityRecord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . PrimitiveClassMap as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( PrimitiveClassMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . ClassIDMap as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( ClassIDMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . ClassTable as * const
                _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( ClassTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . MaxClassID as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( MaxClassID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . AvailClassID as *
                const _ as usize } , 218usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( AvailClassID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . SlotNameTable as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( SlotNameTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . ISA_SYMBOL as * const
                _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( ISA_SYMBOL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . NAME_SYMBOL as * const
                _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( NAME_SYMBOL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . WatchInstances as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( WatchInstances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . WatchSlots as * const
                _ as usize } , 249usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( WatchSlots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . CTID as * const _ as
                usize } , 250usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( CTID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . ObjectParseToken as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( ObjectParseToken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const defclassData ) ) . ClassDefaultsModeValue
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( defclassData ) , "::" ,
                stringify ! ( ClassDefaultsModeValue ) ));
}
impl Clone for defclassData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ClassAbstractPCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClassReactivePCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClassInfoFnxArgs(arg1: *mut UDFContext,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *mut bool) -> *mut Defclass;
}
extern "C" {
    pub fn ClassSlotsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClassSuperclassesCommand(arg1: *mut Environment,
                                    arg2: *mut UDFContext,
                                    arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClassSubclassesCommand(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefmessageHandlersListCmd(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotFacetsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotSourcesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotTypesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotAllowedValuesCommand(arg1: *mut Environment,
                                    arg2: *mut UDFContext,
                                    arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotAllowedClassesCommand(arg1: *mut Environment,
                                     arg2: *mut UDFContext,
                                     arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotRangeCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn SlotCardinalityCommand(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ClassAbstractP(arg1: *mut Defclass) -> bool;
}
extern "C" {
    pub fn ClassReactiveP(arg1: *mut Defclass) -> bool;
}
extern "C" {
    pub fn ClassSlots(arg1: *mut Defclass, arg2: *mut CLIPSValue, arg3: bool);
}
extern "C" {
    pub fn GetDefmessageHandlerList(arg1: *mut Environment,
                                    arg2: *mut Defclass,
                                    arg3: *mut CLIPSValue, arg4: bool);
}
extern "C" {
    pub fn ClassSuperclasses(arg1: *mut Defclass, arg2: *mut CLIPSValue,
                             arg3: bool);
}
extern "C" {
    pub fn ClassSubclasses(arg1: *mut Defclass, arg2: *mut CLIPSValue,
                           arg3: bool);
}
extern "C" {
    pub fn ClassSubclassAddresses(arg1: *mut Environment, arg2: *mut Defclass,
                                  arg3: *mut UDFValue, arg4: bool);
}
extern "C" {
    pub fn SlotFacets(arg1: *mut Defclass,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn SlotSources(arg1: *mut Defclass,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn SlotTypes(arg1: *mut Defclass, arg2: *const ::std::os::raw::c_char,
                     arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn SlotAllowedValues(arg1: *mut Defclass,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn SlotAllowedClasses(arg1: *mut Defclass,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn SlotRange(arg1: *mut Defclass, arg2: *const ::std::os::raw::c_char,
                     arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn SlotCardinality(arg1: *mut Defclass,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *mut CLIPSValue) -> bool;
}
extern "C" {
    pub fn SetupObjectSystem(arg1: *mut Environment);
}
extern "C" {
    pub fn CreateSystemClasses(arg1: *mut Environment,
                               arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ParseDefclass(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn CreateClassScopeMap(arg1: *mut Environment, arg2: *mut Defclass)
     -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct definstances {
    pub header: ConstructHeader,
    pub busy: ::std::os::raw::c_uint,
    pub mkinstance: *mut Expression,
}
#[test]
fn bindgen_test_layout_definstances() {
    assert_eq!(::std::mem::size_of::<definstances>() , 80usize , concat ! (
               "Size of: " , stringify ! ( definstances ) ));
    assert_eq! (::std::mem::align_of::<definstances>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( definstances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const definstances ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( definstances ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const definstances ) ) . busy as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( definstances ) , "::" ,
                stringify ! ( busy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const definstances ) ) . mkinstance as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( definstances ) , "::" ,
                stringify ! ( mkinstance ) ));
}
impl Clone for definstances {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct definstancesModule {
    pub header: defmoduleItemHeader,
}
#[test]
fn bindgen_test_layout_definstancesModule() {
    assert_eq!(::std::mem::size_of::<definstancesModule>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( definstancesModule ) ));
    assert_eq! (::std::mem::align_of::<definstancesModule>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( definstancesModule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const definstancesModule ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( definstancesModule ) ,
                "::" , stringify ! ( header ) ));
}
impl Clone for definstancesModule {
    fn clone(&self) -> Self { *self }
}
pub type DEFINSTANCES_MODULE = definstancesModule;
pub type Definstances = definstances;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct definstancesData {
    pub DefinstancesConstruct: *mut Construct,
    pub DefinstancesModuleIndex: ::std::os::raw::c_uint,
    pub DefinstancesCodeItem: *mut CodeGeneratorItem,
}
#[test]
fn bindgen_test_layout_definstancesData() {
    assert_eq!(::std::mem::size_of::<definstancesData>() , 24usize , concat !
               ( "Size of: " , stringify ! ( definstancesData ) ));
    assert_eq! (::std::mem::align_of::<definstancesData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( definstancesData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const definstancesData ) ) .
                DefinstancesConstruct as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( definstancesData ) ,
                "::" , stringify ! ( DefinstancesConstruct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const definstancesData ) ) .
                DefinstancesModuleIndex as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( definstancesData ) ,
                "::" , stringify ! ( DefinstancesModuleIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const definstancesData ) ) .
                DefinstancesCodeItem as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( definstancesData ) ,
                "::" , stringify ! ( DefinstancesCodeItem ) ));
}
impl Clone for definstancesData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn DefinstancesModule(arg1: *mut Definstances)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefinstancesModuleName(arg1: *mut Environment,
                                  arg2: *mut Definstances)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FindDefinstances(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char)
     -> *mut Definstances;
}
extern "C" {
    pub fn FindDefinstancesInModule(arg1: *mut Environment,
                                    arg2: *const ::std::os::raw::c_char)
     -> *mut Definstances;
}
extern "C" {
    pub fn GetDefinstancesList(arg1: *mut Environment, arg2: *mut CLIPSValue,
                               arg3: *mut Defmodule);
}
extern "C" {
    pub fn DefinstancesName(arg1: *mut Definstances)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetDefinstancesNamePointer(arg1: *mut Environment,
                                      arg2: *mut Definstances)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn DefinstancesPPForm(arg1: *mut Definstances)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetNextDefinstances(arg1: *mut Environment,
                               arg2: *mut Definstances) -> *mut Definstances;
}
extern "C" {
    pub fn DefinstancesIsDeletable(arg1: *mut Definstances) -> bool;
}
extern "C" {
    pub fn SetDefinstancesPPForm(arg1: *mut Environment,
                                 arg2: *mut Definstances,
                                 arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Undefinstances(arg1: *mut Definstances, arg2: *mut Environment)
     -> bool;
}
extern "C" {
    pub fn GetDefinstancesListFunction(arg1: *mut Environment,
                                       arg2: *mut UDFContext,
                                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetDefinstancesModuleCommand(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetupDefinstances(arg1: *mut Environment);
}
extern "C" {
    pub fn UndefinstancesCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPDefinstancesCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefinstancesCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefinstances(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: *mut Defmodule);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum UnmakeInstanceError {
    UIE_NO_ERROR = 0,
    UIE_NULL_POINTER_ERROR = 1,
    UIE_COULD_NOT_DELETE_ERROR = 2,
    UIE_DELETED_ERROR = 3,
    UIE_RULE_NETWORK_ERROR = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MakeInstanceError {
    MIE_NO_ERROR = 0,
    MIE_NULL_POINTER_ERROR = 1,
    MIE_PARSING_ERROR = 2,
    MIE_COULD_NOT_CREATE_ERROR = 3,
    MIE_RULE_NETWORK_ERROR = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum InstanceBuilderError {
    IBE_NO_ERROR = 0,
    IBE_NULL_POINTER_ERROR = 1,
    IBE_DEFCLASS_NOT_FOUND_ERROR = 2,
    IBE_COULD_NOT_CREATE_ERROR = 3,
    IBE_RULE_NETWORK_ERROR = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum InstanceModifierError {
    IME_NO_ERROR = 0,
    IME_NULL_POINTER_ERROR = 1,
    IME_DELETED_ERROR = 2,
    IME_COULD_NOT_MODIFY_ERROR = 3,
    IME_RULE_NETWORK_ERROR = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct igarbage {
    pub ins: *mut Instance,
    pub nxt: *mut igarbage,
}
#[test]
fn bindgen_test_layout_igarbage() {
    assert_eq!(::std::mem::size_of::<igarbage>() , 16usize , concat ! (
               "Size of: " , stringify ! ( igarbage ) ));
    assert_eq! (::std::mem::align_of::<igarbage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( igarbage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const igarbage ) ) . ins as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( igarbage ) , "::" ,
                stringify ! ( ins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const igarbage ) ) . nxt as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( igarbage ) , "::" ,
                stringify ! ( nxt ) ));
}
impl Clone for igarbage {
    fn clone(&self) -> Self { *self }
}
pub type IGARBAGE = igarbage;
extern "C" {
    pub fn RetainInstance(arg1: *mut Instance);
}
extern "C" {
    pub fn ReleaseInstance(arg1: *mut Instance);
}
extern "C" {
    pub fn IncrementInstanceCallback(arg1: *mut Environment,
                                     arg2: *mut Instance);
}
extern "C" {
    pub fn DecrementInstanceCallback(arg1: *mut Environment,
                                     arg2: *mut Instance);
}
extern "C" {
    pub fn InitializeInstanceTable(arg1: *mut Environment);
}
extern "C" {
    pub fn CleanupInstances(arg1: *mut Environment,
                            arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn HashInstance(arg1: *mut CLIPSLexeme) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn DestroyAllInstances(arg1: *mut Environment,
                               arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn RemoveInstanceData(arg1: *mut Environment, arg2: *mut Instance);
}
extern "C" {
    pub fn FindInstanceBySymbol(arg1: *mut Environment,
                                arg2: *mut CLIPSLexeme) -> *mut Instance;
}
extern "C" {
    pub fn FindInstanceInModule(arg1: *mut Environment,
                                arg2: *mut CLIPSLexeme, arg3: *mut Defmodule,
                                arg4: *mut Defmodule, arg5: bool)
     -> *mut Instance;
}
extern "C" {
    pub fn FindInstanceSlot(arg1: *mut Environment, arg2: *mut Instance,
                            arg3: *mut CLIPSLexeme) -> *mut InstanceSlot;
}
extern "C" {
    pub fn FindInstanceTemplateSlot(arg1: *mut Environment,
                                    arg2: *mut Defclass,
                                    arg3: *mut CLIPSLexeme)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PutSlotValue(arg1: *mut Environment, arg2: *mut Instance,
                        arg3: *mut InstanceSlot, arg4: *mut UDFValue,
                        arg5: *mut UDFValue,
                        arg6: *const ::std::os::raw::c_char) -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotValue(arg1: *mut Environment, arg2: *mut Instance,
                              arg3: *mut InstanceSlot, arg4: *mut UDFValue,
                              arg5: *mut UDFValue) -> PutSlotError;
}
extern "C" {
    pub fn ValidSlotValue(arg1: *mut Environment, arg2: *mut UDFValue,
                          arg3: *mut SlotDescriptor, arg4: *mut Instance,
                          arg5: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn CheckInstance(arg1: *mut UDFContext) -> *mut Instance;
}
extern "C" {
    pub fn NoInstanceError(arg1: *mut Environment,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn StaleInstanceAddress(arg1: *mut Environment,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GetInstancesChanged(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn SetInstancesChanged(arg1: *mut Environment, arg2: bool);
}
extern "C" {
    pub fn PrintSlot(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut SlotDescriptor, arg4: *mut Instance,
                     arg5: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn PrintInstanceNameAndClass(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: *mut Instance, arg4: bool);
}
extern "C" {
    pub fn PrintInstanceName(arg1: *mut Environment,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut Instance);
}
extern "C" {
    pub fn PrintInstanceLongForm(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut Instance);
}
extern "C" {
    pub fn DecrementObjectBasisCount(arg1: *mut Environment,
                                     arg2: *mut Instance);
}
extern "C" {
    pub fn IncrementObjectBasisCount(arg1: *mut Environment,
                                     arg2: *mut Instance);
}
extern "C" {
    pub fn MatchObjectFunction(arg1: *mut Environment, arg2: *mut Instance);
}
extern "C" {
    pub fn NetworkSynchronized(arg1: *mut Environment, arg2: *mut Instance)
     -> bool;
}
extern "C" {
    pub fn InstanceIsDeleted(arg1: *mut Environment, arg2: *mut Instance)
     -> bool;
}
#[repr(C)]
#[derive(Copy)]
pub struct instanceData {
    pub DummyInstance: Instance,
    pub InstanceTable: *mut *mut Instance,
    pub MaintainGarbageInstances: bool,
    pub MkInsMsgPass: bool,
    pub ChangesToInstances: bool,
    pub InstanceGarbageList: *mut IGARBAGE,
    pub InstanceInfo: patternEntityRecord,
    pub InstanceList: *mut Instance,
    pub GlobalNumberOfInstances: ::std::os::raw::c_ulong,
    pub CurrentInstance: *mut Instance,
    pub InstanceListBottom: *mut Instance,
    pub ObjectModDupMsgValid: bool,
    pub unmakeInstanceError: UnmakeInstanceError,
    pub makeInstanceError: MakeInstanceError,
    pub instanceModifierError: InstanceModifierError,
    pub instanceBuilderError: InstanceBuilderError,
}
#[test]
fn bindgen_test_layout_instanceData() {
    assert_eq!(::std::mem::size_of::<instanceData>() , 384usize , concat ! (
               "Size of: " , stringify ! ( instanceData ) ));
    assert_eq! (::std::mem::align_of::<instanceData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( instanceData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . DummyInstance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( DummyInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . InstanceTable as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( InstanceTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) .
                MaintainGarbageInstances as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( MaintainGarbageInstances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . MkInsMsgPass as *
                const _ as usize } , 161usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( MkInsMsgPass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . ChangesToInstances as
                * const _ as usize } , 162usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( ChangesToInstances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . InstanceGarbageList as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( InstanceGarbageList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . InstanceInfo as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( InstanceInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . InstanceList as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( InstanceList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) .
                GlobalNumberOfInstances as * const _ as usize } , 336usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( GlobalNumberOfInstances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . CurrentInstance as *
                const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( CurrentInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . InstanceListBottom as
                * const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( InstanceListBottom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . ObjectModDupMsgValid
                as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( ObjectModDupMsgValid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . unmakeInstanceError as
                * const _ as usize } , 364usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( unmakeInstanceError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . makeInstanceError as *
                const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( makeInstanceError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . instanceModifierError
                as * const _ as usize } , 372usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( instanceModifierError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceData ) ) . instanceBuilderError
                as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceData ) , "::" ,
                stringify ! ( instanceBuilderError ) ));
}
impl Clone for instanceData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn SetupInstances(arg1: *mut Environment);
}
extern "C" {
    pub fn DeleteInstance(arg1: *mut Instance) -> UnmakeInstanceError;
}
extern "C" {
    pub fn DeleteAllInstances(arg1: *mut Environment) -> UnmakeInstanceError;
}
extern "C" {
    pub fn UnmakeInstance(arg1: *mut Instance) -> UnmakeInstanceError;
}
extern "C" {
    pub fn UnmakeInstanceCallback(arg1: *mut Instance, arg2: *mut Environment)
     -> bool;
}
extern "C" {
    pub fn UnmakeAllInstances(arg1: *mut Environment) -> UnmakeInstanceError;
}
extern "C" {
    pub fn InstancesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn PPInstanceCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                             arg3: *mut UDFValue);
}
extern "C" {
    pub fn Instances(arg1: *mut Environment,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut Defmodule,
                     arg4: *const ::std::os::raw::c_char, arg5: bool);
}
extern "C" {
    pub fn MakeInstance(arg1: *mut Environment,
                        arg2: *const ::std::os::raw::c_char) -> *mut Instance;
}
extern "C" {
    pub fn GetMakeInstanceError(arg1: *mut Environment) -> MakeInstanceError;
}
extern "C" {
    pub fn CreateRawInstance(arg1: *mut Environment, arg2: *mut Defclass,
                             arg3: *const ::std::os::raw::c_char)
     -> *mut Instance;
}
extern "C" {
    pub fn FindInstance(arg1: *mut Environment, arg2: *mut Defmodule,
                        arg3: *const ::std::os::raw::c_char, arg4: bool)
     -> *mut Instance;
}
extern "C" {
    pub fn ValidInstanceAddress(arg1: *mut Instance) -> bool;
}
extern "C" {
    pub fn DirectGetSlot(arg1: *mut Instance,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: *mut CLIPSValue) -> GetSlotError;
}
extern "C" {
    pub fn DirectPutSlot(arg1: *mut Instance,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: *mut CLIPSValue) -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotInteger(arg1: *mut Instance,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: ::std::os::raw::c_longlong)
     -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotFloat(arg1: *mut Instance,
                              arg2: *const ::std::os::raw::c_char, arg3: f64)
     -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotSymbol(arg1: *mut Instance,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotString(arg1: *mut Instance,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotInstanceName(arg1: *mut Instance,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotCLIPSInteger(arg1: *mut Instance,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: *mut CLIPSInteger) -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotCLIPSFloat(arg1: *mut Instance,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: *mut CLIPSFloat) -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotCLIPSLexeme(arg1: *mut Instance,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: *mut CLIPSLexeme) -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotFact(arg1: *mut Instance,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut Fact) -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotInstance(arg1: *mut Instance,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut Instance) -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotMultifield(arg1: *mut Instance,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: *mut Multifield) -> PutSlotError;
}
extern "C" {
    pub fn DirectPutSlotCLIPSExternalAddress(arg1: *mut Instance,
                                             arg2:
                                                 *const ::std::os::raw::c_char,
                                             arg3: *mut CLIPSExternalAddress)
     -> PutSlotError;
}
extern "C" {
    pub fn InstanceName(arg1: *mut Instance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn InstanceClass(arg1: *mut Instance) -> *mut Defclass;
}
extern "C" {
    pub fn GetGlobalNumberOfInstances(arg1: *mut Environment)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn GetNextInstance(arg1: *mut Environment, arg2: *mut Instance)
     -> *mut Instance;
}
extern "C" {
    pub fn GetNextInstanceInScope(arg1: *mut Environment, arg2: *mut Instance)
     -> *mut Instance;
}
extern "C" {
    pub fn GetNextInstanceInClass(arg1: *mut Defclass, arg2: *mut Instance)
     -> *mut Instance;
}
extern "C" {
    pub fn GetNextInstanceInClassAndSubclasses(arg1: *mut *mut Defclass,
                                               arg2: *mut Instance,
                                               arg3: *mut UDFValue)
     -> *mut Instance;
}
extern "C" {
    pub fn InstancePPForm(arg1: *mut Instance, arg2: *mut StringBuilder);
}
extern "C" {
    pub fn ClassCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn DeleteInstanceCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn UnmakeInstanceCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn SymbolToInstanceNameFunction(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn InstanceNameToSymbolFunction(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn InstanceAddressCommand(arg1: *mut Environment,
                                  arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn InstanceNameCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn InstanceAddressPCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn InstanceNamePCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn InstancePCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn InstanceExistPCommand(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn CreateInstanceHandler(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct instanceFileData {
    pub InstanceBinaryPrefixID: *const ::std::os::raw::c_char,
    pub InstanceBinaryVersionID: *const ::std::os::raw::c_char,
    pub BinaryInstanceFileSize: usize,
    pub BinaryInstanceFileOffset: usize,
    pub CurrentReadBuffer: *mut ::std::os::raw::c_char,
    pub CurrentReadBufferSize: usize,
    pub CurrentReadBufferOffset: usize,
}
#[test]
fn bindgen_test_layout_instanceFileData() {
    assert_eq!(::std::mem::size_of::<instanceFileData>() , 56usize , concat !
               ( "Size of: " , stringify ! ( instanceFileData ) ));
    assert_eq! (::std::mem::align_of::<instanceFileData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( instanceFileData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceFileData ) ) .
                InstanceBinaryPrefixID as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( instanceFileData ) ,
                "::" , stringify ! ( InstanceBinaryPrefixID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceFileData ) ) .
                InstanceBinaryVersionID as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( instanceFileData ) ,
                "::" , stringify ! ( InstanceBinaryVersionID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceFileData ) ) .
                BinaryInstanceFileSize as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( instanceFileData ) ,
                "::" , stringify ! ( BinaryInstanceFileSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceFileData ) ) .
                BinaryInstanceFileOffset as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( instanceFileData ) ,
                "::" , stringify ! ( BinaryInstanceFileOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceFileData ) ) . CurrentReadBuffer
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( instanceFileData ) ,
                "::" , stringify ! ( CurrentReadBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceFileData ) ) .
                CurrentReadBufferSize as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( instanceFileData ) ,
                "::" , stringify ! ( CurrentReadBufferSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const instanceFileData ) ) .
                CurrentReadBufferOffset as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( instanceFileData ) ,
                "::" , stringify ! ( CurrentReadBufferOffset ) ));
}
impl Clone for instanceFileData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn SetupInstanceFileCommands(arg1: *mut Environment);
}
extern "C" {
    pub fn SaveInstancesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn LoadInstancesCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn RestoreInstancesCommand(arg1: *mut Environment,
                                   arg2: *mut UDFContext,
                                   arg3: *mut UDFValue);
}
extern "C" {
    pub fn SaveInstancesDriver(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: SaveScope, arg4: *mut Expression,
                               arg5: bool) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SaveInstances(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char, arg3: SaveScope)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BinarySaveInstancesCommand(arg1: *mut Environment,
                                      arg2: *mut UDFContext,
                                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn BinarySaveInstancesDriver(arg1: *mut Environment,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: SaveScope, arg4: *mut Expression,
                                     arg5: bool) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BinarySaveInstances(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: SaveScope) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BinaryLoadInstancesCommand(arg1: *mut Environment,
                                      arg2: *mut UDFContext,
                                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn BinaryLoadInstances(arg1: *mut Environment,
                               arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn LoadInstances(arg1: *mut Environment,
                         arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn LoadInstancesFromString(arg1: *mut Environment,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: usize) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn RestoreInstances(arg1: *mut Environment,
                            arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn RestoreInstancesFromString(arg1: *mut Environment,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3: usize) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn InitializeInstanceCommand(arg1: *mut Environment,
                                     arg2: *mut UDFContext,
                                     arg3: *mut UDFValue);
}
extern "C" {
    pub fn MakeInstanceCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                               arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetFullInstanceName(arg1: *mut Environment, arg2: *mut Instance)
     -> *mut CLIPSLexeme;
}
extern "C" {
    pub fn BuildInstance(arg1: *mut Environment, arg2: *mut CLIPSLexeme,
                         arg3: *mut Defclass, arg4: bool) -> *mut Instance;
}
extern "C" {
    pub fn InitSlotsCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn QuashInstance(arg1: *mut Environment, arg2: *mut Instance)
     -> UnmakeInstanceError;
}
extern "C" {
    pub fn InactiveInitializeInstance(arg1: *mut Environment,
                                      arg2: *mut UDFContext,
                                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn InactiveMakeInstance(arg1: *mut Environment, arg2: *mut UDFContext,
                                arg3: *mut UDFValue);
}
extern "C" {
    pub fn CreateInstanceBuilder(arg1: *mut Environment,
                                 arg2: *const ::std::os::raw::c_char)
     -> *mut InstanceBuilder;
}
extern "C" {
    pub fn IBPutSlot(arg1: *mut InstanceBuilder,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut CLIPSValue) -> PutSlotError;
}
extern "C" {
    pub fn IBMake(arg1: *mut InstanceBuilder,
                  arg2: *const ::std::os::raw::c_char) -> *mut Instance;
}
extern "C" {
    pub fn IBDispose(arg1: *mut InstanceBuilder);
}
extern "C" {
    pub fn IBAbort(arg1: *mut InstanceBuilder);
}
extern "C" {
    pub fn IBSetDefclass(arg1: *mut InstanceBuilder,
                         arg2: *const ::std::os::raw::c_char)
     -> InstanceBuilderError;
}
extern "C" {
    pub fn IBPutSlotCLIPSInteger(arg1: *mut InstanceBuilder,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut CLIPSInteger) -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotInteger(arg1: *mut InstanceBuilder,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: ::std::os::raw::c_longlong) -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotCLIPSFloat(arg1: *mut InstanceBuilder,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut CLIPSFloat) -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotFloat(arg1: *mut InstanceBuilder,
                          arg2: *const ::std::os::raw::c_char, arg3: f64)
     -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotCLIPSLexeme(arg1: *mut InstanceBuilder,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: *mut CLIPSLexeme) -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotSymbol(arg1: *mut InstanceBuilder,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotString(arg1: *mut InstanceBuilder,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotInstanceName(arg1: *mut InstanceBuilder,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotFact(arg1: *mut InstanceBuilder,
                         arg2: *const ::std::os::raw::c_char, arg3: *mut Fact)
     -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotInstance(arg1: *mut InstanceBuilder,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut Instance) -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotExternalAddress(arg1: *mut InstanceBuilder,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: *mut CLIPSExternalAddress)
     -> PutSlotError;
}
extern "C" {
    pub fn IBPutSlotMultifield(arg1: *mut InstanceBuilder,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut Multifield) -> PutSlotError;
}
extern "C" {
    pub fn IBError(arg1: *mut Environment) -> InstanceBuilderError;
}
extern "C" {
    pub fn CreateInstanceModifier(arg1: *mut Environment, arg2: *mut Instance)
     -> *mut InstanceModifier;
}
extern "C" {
    pub fn IMPutSlot(arg1: *mut InstanceModifier,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut CLIPSValue) -> PutSlotError;
}
extern "C" {
    pub fn IMDispose(arg1: *mut InstanceModifier);
}
extern "C" {
    pub fn IMAbort(arg1: *mut InstanceModifier);
}
extern "C" {
    pub fn IMSetInstance(arg1: *mut InstanceModifier, arg2: *mut Instance)
     -> InstanceModifierError;
}
extern "C" {
    pub fn IMModify(arg1: *mut InstanceModifier) -> *mut Instance;
}
extern "C" {
    pub fn IMPutSlotCLIPSInteger(arg1: *mut InstanceModifier,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut CLIPSInteger) -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotInteger(arg1: *mut InstanceModifier,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: ::std::os::raw::c_longlong) -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotCLIPSFloat(arg1: *mut InstanceModifier,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut CLIPSFloat) -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotFloat(arg1: *mut InstanceModifier,
                          arg2: *const ::std::os::raw::c_char, arg3: f64)
     -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotCLIPSLexeme(arg1: *mut InstanceModifier,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: *mut CLIPSLexeme) -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotSymbol(arg1: *mut InstanceModifier,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotString(arg1: *mut InstanceModifier,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotInstanceName(arg1: *mut InstanceModifier,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *const ::std::os::raw::c_char)
     -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotFact(arg1: *mut InstanceModifier,
                         arg2: *const ::std::os::raw::c_char, arg3: *mut Fact)
     -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotInstance(arg1: *mut InstanceModifier,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: *mut Instance) -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotExternalAddress(arg1: *mut InstanceModifier,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: *mut CLIPSExternalAddress)
     -> PutSlotError;
}
extern "C" {
    pub fn IMPutSlotMultifield(arg1: *mut InstanceModifier,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *mut Multifield) -> PutSlotError;
}
extern "C" {
    pub fn IMError(arg1: *mut Environment) -> InstanceModifierError;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct messageHandlerLink {
    pub hnd: *mut DefmessageHandler,
    pub nxt: *mut messageHandlerLink,
    pub nxtInStack: *mut messageHandlerLink,
}
#[test]
fn bindgen_test_layout_messageHandlerLink() {
    assert_eq!(::std::mem::size_of::<messageHandlerLink>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( messageHandlerLink ) ));
    assert_eq! (::std::mem::align_of::<messageHandlerLink>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( messageHandlerLink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerLink ) ) . hnd as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerLink ) ,
                "::" , stringify ! ( hnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerLink ) ) . nxt as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerLink ) ,
                "::" , stringify ! ( nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerLink ) ) . nxtInStack as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerLink ) ,
                "::" , stringify ! ( nxtInStack ) ));
}
impl Clone for messageHandlerLink {
    fn clone(&self) -> Self { *self }
}
pub type HANDLER_LINK = messageHandlerLink;
extern "C" {
    pub fn DirectMessage(arg1: *mut Environment, arg2: *mut CLIPSLexeme,
                         arg3: *mut Instance, arg4: *mut UDFValue,
                         arg5: *mut Expression) -> bool;
}
extern "C" {
    pub fn Send(arg1: *mut Environment, arg2: *mut CLIPSValue,
                arg3: *const ::std::os::raw::c_char,
                arg4: *const ::std::os::raw::c_char, arg5: *mut CLIPSValue);
}
extern "C" {
    pub fn DestroyHandlerLinks(arg1: *mut Environment,
                               arg2: *mut HANDLER_LINK);
}
extern "C" {
    pub fn SendCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                       arg3: *mut UDFValue);
}
extern "C" {
    pub fn GetNthMessageArgument(arg1: *mut Environment,
                                 arg2: ::std::os::raw::c_int)
     -> *mut UDFValue;
}
extern "C" {
    pub fn NextHandlerAvailable(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn NextHandlerAvailableFunction(arg1: *mut Environment,
                                        arg2: *mut UDFContext,
                                        arg3: *mut UDFValue);
}
extern "C" {
    pub fn CallNextHandler(arg1: *mut Environment, arg2: *mut UDFContext,
                           arg3: *mut UDFValue);
}
extern "C" {
    pub fn FindApplicableOfName(arg1: *mut Environment, arg2: *mut Defclass,
                                arg3: *mut *mut HANDLER_LINK,
                                arg4: *mut *mut HANDLER_LINK,
                                arg5: *mut CLIPSLexeme);
}
extern "C" {
    pub fn JoinHandlerLinks(arg1: *mut Environment,
                            arg2: *mut *mut HANDLER_LINK,
                            arg3: *mut *mut HANDLER_LINK,
                            arg4: *mut CLIPSLexeme) -> *mut HANDLER_LINK;
}
extern "C" {
    pub fn PrintHandlerSlotGetFunction(arg1: *mut Environment,
                                       arg2: *const ::std::os::raw::c_char,
                                       arg3: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn HandlerSlotGetFunction(arg1: *mut Environment,
                                  arg2: *mut ::std::os::raw::c_void,
                                  arg3: *mut UDFValue) -> bool;
}
extern "C" {
    pub fn PrintHandlerSlotPutFunction(arg1: *mut Environment,
                                       arg2: *const ::std::os::raw::c_char,
                                       arg3: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn HandlerSlotPutFunction(arg1: *mut Environment,
                                  arg2: *mut ::std::os::raw::c_void,
                                  arg3: *mut UDFValue) -> bool;
}
extern "C" {
    pub fn DynamicHandlerGetSlot(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
extern "C" {
    pub fn DynamicHandlerPutSlot(arg1: *mut Environment,
                                 arg2: *mut UDFContext, arg3: *mut UDFValue);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct messageHandlerData {
    pub HandlerGetInfo: EntityRecord,
    pub HandlerPutInfo: EntityRecord,
    pub INIT_SYMBOL: *mut CLIPSLexeme,
    pub DELETE_SYMBOL: *mut CLIPSLexeme,
    pub CREATE_SYMBOL: *mut CLIPSLexeme,
    pub WatchHandlers: bool,
    pub WatchMessages: bool,
    pub hndquals: [*const ::std::os::raw::c_char; 4usize],
    pub SELF_SYMBOL: *mut CLIPSLexeme,
    pub CurrentMessageName: *mut CLIPSLexeme,
    pub CurrentCore: *mut HANDLER_LINK,
    pub TopOfCore: *mut HANDLER_LINK,
    pub NextInCore: *mut HANDLER_LINK,
    pub OldCore: *mut HANDLER_LINK,
}
#[test]
fn bindgen_test_layout_messageHandlerData() {
    assert_eq!(::std::mem::size_of::<messageHandlerData>() , 336usize , concat
               ! ( "Size of: " , stringify ! ( messageHandlerData ) ));
    assert_eq! (::std::mem::align_of::<messageHandlerData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( messageHandlerData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . HandlerGetInfo
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( HandlerGetInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . HandlerPutInfo
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( HandlerPutInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . INIT_SYMBOL as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( INIT_SYMBOL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . DELETE_SYMBOL as
                * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( DELETE_SYMBOL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . CREATE_SYMBOL as
                * const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( CREATE_SYMBOL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . WatchHandlers as
                * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( WatchHandlers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . WatchMessages as
                * const _ as usize } , 249usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( WatchMessages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . hndquals as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( hndquals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . SELF_SYMBOL as *
                const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( SELF_SYMBOL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) .
                CurrentMessageName as * const _ as usize } , 296usize , concat
                ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( CurrentMessageName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . CurrentCore as *
                const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( CurrentCore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . TopOfCore as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( TopOfCore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . NextInCore as *
                const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( NextInCore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const messageHandlerData ) ) . OldCore as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( messageHandlerData ) ,
                "::" , stringify ! ( OldCore ) ));
}
impl Clone for messageHandlerData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn SetupMessageHandlers(arg1: *mut Environment);
}
extern "C" {
    pub fn DefmessageHandlerName(arg1: *mut Defclass,
                                 arg2: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DefmessageHandlerType(arg1: *mut Defclass,
                                 arg2: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetNextDefmessageHandler(arg1: *mut Defclass,
                                    arg2: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn GetDefmessageHandlerPointer(arg1: *mut Defclass,
                                       arg2: ::std::os::raw::c_uint)
     -> *mut DefmessageHandler;
}
extern "C" {
    pub fn DefmessageHandlerGetWatch(arg1: *mut Defclass,
                                     arg2: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn DefmessageHandlerSetWatch(arg1: *mut Defclass,
                                     arg2: ::std::os::raw::c_uint,
                                     arg3: bool);
}
extern "C" {
    pub fn FindDefmessageHandler(arg1: *mut Defclass,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn DefmessageHandlerIsDeletable(arg1: *mut Defclass,
                                        arg2: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn UndefmessageHandlerCommand(arg1: *mut Environment,
                                      arg2: *mut UDFContext,
                                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn UndefmessageHandler(arg1: *mut Defclass,
                               arg2: ::std::os::raw::c_uint,
                               arg3: *mut Environment) -> bool;
}
extern "C" {
    pub fn PPDefmessageHandlerCommand(arg1: *mut Environment,
                                      arg2: *mut UDFContext,
                                      arg3: *mut UDFValue);
}
extern "C" {
    pub fn ListDefmessageHandlersCommand(arg1: *mut Environment,
                                         arg2: *mut UDFContext,
                                         arg3: *mut UDFValue);
}
extern "C" {
    pub fn PreviewSendCommand(arg1: *mut Environment, arg2: *mut UDFContext,
                              arg3: *mut UDFValue);
}
extern "C" {
    pub fn DefmessageHandlerPPForm(arg1: *mut Defclass,
                                   arg2: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ListDefmessageHandlers(arg1: *mut Environment, arg2: *mut Defclass,
                                  arg3: *const ::std::os::raw::c_char,
                                  arg4: bool);
}
extern "C" {
    pub fn PreviewSend(arg1: *mut Defclass,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn DisplayHandlersInLinks(arg1: *mut Environment,
                                  arg2: *const ::std::os::raw::c_char,
                                  arg3: *mut PACKED_CLASS_LINKS,
                                  arg4: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct classBitMap {
    pub maxid: ::std::os::raw::c_ushort,
    pub map: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_classBitMap() {
    assert_eq!(::std::mem::size_of::<classBitMap>() , 4usize , concat ! (
               "Size of: " , stringify ! ( classBitMap ) ));
    assert_eq! (::std::mem::align_of::<classBitMap>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( classBitMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const classBitMap ) ) . maxid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( classBitMap ) , "::" ,
                stringify ! ( maxid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const classBitMap ) ) . map as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( classBitMap ) , "::" ,
                stringify ! ( map ) ));
}
impl Clone for classBitMap {
    fn clone(&self) -> Self { *self }
}
pub type CLASS_BITMAP = classBitMap;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct slotBitMap {
    pub maxid: ::std::os::raw::c_ushort,
    pub map: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_slotBitMap() {
    assert_eq!(::std::mem::size_of::<slotBitMap>() , 4usize , concat ! (
               "Size of: " , stringify ! ( slotBitMap ) ));
    assert_eq! (::std::mem::align_of::<slotBitMap>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( slotBitMap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotBitMap ) ) . maxid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( slotBitMap ) , "::" ,
                stringify ! ( maxid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const slotBitMap ) ) . map as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( slotBitMap ) , "::" ,
                stringify ! ( map ) ));
}
impl Clone for slotBitMap {
    fn clone(&self) -> Self { *self }
}
pub type SLOT_BITMAP = slotBitMap;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct objectAlphaNode {
    pub header: patternNodeHeader,
    pub matchTimeTag: ::std::os::raw::c_ulonglong,
    pub classbmp: *mut CLIPSBitMap,
    pub slotbmp: *mut CLIPSBitMap,
    pub patternNode: *mut OBJECT_PATTERN_NODE,
    pub nxtInGroup: *mut objectAlphaNode,
    pub nxtTerminal: *mut objectAlphaNode,
    pub bsaveID: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_objectAlphaNode() {
    assert_eq!(::std::mem::size_of::<objectAlphaNode>() , 96usize , concat ! (
               "Size of: " , stringify ! ( objectAlphaNode ) ));
    assert_eq! (::std::mem::align_of::<objectAlphaNode>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( objectAlphaNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectAlphaNode ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( objectAlphaNode ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectAlphaNode ) ) . matchTimeTag as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( objectAlphaNode ) ,
                "::" , stringify ! ( matchTimeTag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectAlphaNode ) ) . classbmp as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( objectAlphaNode ) ,
                "::" , stringify ! ( classbmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectAlphaNode ) ) . slotbmp as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( objectAlphaNode ) ,
                "::" , stringify ! ( slotbmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectAlphaNode ) ) . patternNode as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( objectAlphaNode ) ,
                "::" , stringify ! ( patternNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectAlphaNode ) ) . nxtInGroup as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( objectAlphaNode ) ,
                "::" , stringify ! ( nxtInGroup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectAlphaNode ) ) . nxtTerminal as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( objectAlphaNode ) ,
                "::" , stringify ! ( nxtTerminal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectAlphaNode ) ) . bsaveID as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( objectAlphaNode ) ,
                "::" , stringify ! ( bsaveID ) ));
}
impl Clone for objectAlphaNode {
    fn clone(&self) -> Self { *self }
}
pub type OBJECT_ALPHA_NODE = objectAlphaNode;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct objectPatternNode {
    pub _bitfield_1: [u8; 2usize],
    pub leaveFields: ::std::os::raw::c_ushort,
    pub matchTimeTag: ::std::os::raw::c_ulonglong,
    pub slotNameID: ::std::os::raw::c_ushort,
    pub networkTest: *mut Expression,
    pub nextLevel: *mut objectPatternNode,
    pub lastLevel: *mut objectPatternNode,
    pub leftNode: *mut objectPatternNode,
    pub rightNode: *mut objectPatternNode,
    pub alphaNode: *mut OBJECT_ALPHA_NODE,
    pub bsaveID: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_objectPatternNode() {
    assert_eq!(::std::mem::size_of::<objectPatternNode>() , 80usize , concat !
               ( "Size of: " , stringify ! ( objectPatternNode ) ));
    assert_eq! (::std::mem::align_of::<objectPatternNode>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( objectPatternNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . leaveFields as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( leaveFields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . matchTimeTag as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( matchTimeTag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . slotNameID as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( slotNameID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . networkTest as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( networkTest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . nextLevel as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( nextLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . lastLevel as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( lastLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . leftNode as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( leftNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . rightNode as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( rightNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . alphaNode as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( alphaNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectPatternNode ) ) . bsaveID as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( objectPatternNode ) ,
                "::" , stringify ! ( bsaveID ) ));
}
impl Clone for objectPatternNode {
    fn clone(&self) -> Self { *self }
}
impl objectPatternNode {
    #[inline]
    pub fn blocked(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_blocked(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn multifieldNode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_multifieldNode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn endSlot(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_endSlot(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn selector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_selector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn whichField(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4080u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_whichField(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4080u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(blocked: ::std::os::raw::c_uint,
                          multifieldNode: ::std::os::raw::c_uint,
                          endSlot: ::std::os::raw::c_uint,
                          selector: ::std::os::raw::c_uint,
                          whichField: ::std::os::raw::c_uint) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((blocked as u32 as u16) << 0usize) &
                                     (1u64 as u16))
                        } |
                            ((multifieldNode as u32 as u16) << 1usize) &
                                (2u64 as u16))
                   } | ((endSlot as u32 as u16) << 2usize) & (4u64 as u16))
              } | ((selector as u32 as u16) << 3usize) & (8u64 as u16))
         } | ((whichField as u32 as u16) << 4usize) & (4080u64 as u16))
    }
}
pub type OBJECT_PATTERN_NODE = objectPatternNode;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct objectMatchAction {
    pub type_: ::std::os::raw::c_int,
    pub ins: *mut Instance,
    pub slotNameIDs: *mut SLOT_BITMAP,
    pub nxt: *mut objectMatchAction,
}
#[test]
fn bindgen_test_layout_objectMatchAction() {
    assert_eq!(::std::mem::size_of::<objectMatchAction>() , 32usize , concat !
               ( "Size of: " , stringify ! ( objectMatchAction ) ));
    assert_eq! (::std::mem::align_of::<objectMatchAction>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( objectMatchAction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectMatchAction ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( objectMatchAction ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectMatchAction ) ) . ins as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( objectMatchAction ) ,
                "::" , stringify ! ( ins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectMatchAction ) ) . slotNameIDs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( objectMatchAction ) ,
                "::" , stringify ! ( slotNameIDs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const objectMatchAction ) ) . nxt as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( objectMatchAction ) ,
                "::" , stringify ! ( nxt ) ));
}
impl Clone for objectMatchAction {
    fn clone(&self) -> Self { *self }
}
pub type OBJECT_MATCH_ACTION = objectMatchAction;
extern "C" {
    pub fn ObjectMatchDelay(arg1: *mut Environment, arg2: *mut UDFContext,
                            arg3: *mut UDFValue);
}
extern "C" {
    pub fn SetDelayObjectPatternMatching(arg1: *mut Environment, arg2: bool)
     -> bool;
}
extern "C" {
    pub fn GetDelayObjectPatternMatching(arg1: *mut Environment) -> bool;
}
extern "C" {
    pub fn ObjectNetworkPointer(arg1: *mut Environment)
     -> *mut OBJECT_PATTERN_NODE;
}
extern "C" {
    pub fn ObjectNetworkTerminalPointer(arg1: *mut Environment)
     -> *mut OBJECT_ALPHA_NODE;
}
extern "C" {
    pub fn SetObjectNetworkPointer(arg1: *mut Environment,
                                   arg2: *mut OBJECT_PATTERN_NODE);
}
extern "C" {
    pub fn SetObjectNetworkTerminalPointer(arg1: *mut Environment,
                                           arg2: *mut OBJECT_ALPHA_NODE);
}
extern "C" {
    pub fn ObjectNetworkAction(arg1: *mut Environment,
                               arg2: ::std::os::raw::c_int,
                               arg3: *mut Instance,
                               arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ResetObjectMatchTimeTags(arg1: *mut Environment);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct portConstructItem {
    pub _address: u8,
}
impl Clone for portConstructItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}

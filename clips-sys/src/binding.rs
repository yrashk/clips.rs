/* automatically generated by rust-bindgen */



#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expr {
    pub type_: ::std::os::raw::c_ushort,
    pub value: *mut ::std::os::raw::c_void,
    pub argList: *mut expr,
    pub nextArg: *mut expr,
}
#[test]
fn bindgen_test_layout_expr() {
    assert_eq!(
        ::std::mem::size_of::<expr>(),
        32usize,
        concat!("Size of: ", stringify!(expr))
    );
    assert_eq!(
        ::std::mem::align_of::<expr>(),
        8usize,
        concat!("Alignment of ", stringify!(expr))
    );
    assert_eq!(
        unsafe { &(*(0 as *const expr)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(expr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const expr)).value as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(expr),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const expr)).argList as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(expr),
            "::",
            stringify!(argList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const expr)).nextArg as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(expr),
            "::",
            stringify!(nextArg)
        )
    );
}
pub type EXPRESSION = expr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct userData {
    pub dataID: ::std::os::raw::c_uchar,
    pub next: *mut userData,
}
#[test]
fn bindgen_test_layout_userData() {
    assert_eq!(
        ::std::mem::size_of::<userData>(),
        16usize,
        concat!("Size of: ", stringify!(userData))
    );
    assert_eq!(
        ::std::mem::align_of::<userData>(),
        8usize,
        concat!("Alignment of ", stringify!(userData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const userData)).dataID as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(userData),
            "::",
            stringify!(dataID)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const userData)).next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(userData),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn EnvDefineFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)
                                 -> ::std::os::raw::c_int,
        >,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDefineFunction2(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)
                                 -> ::std::os::raw::c_int,
        >,
        arg5: *const ::std::os::raw::c_char,
        arg6: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDefineFunctionWithContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)
                                 -> ::std::os::raw::c_int,
        >,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDefineFunction2WithContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)
                                 -> ::std::os::raw::c_int,
        >,
        arg5: *const ::std::os::raw::c_char,
        arg6: *const ::std::os::raw::c_char,
        arg7: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetSequenceOperatorRecognition(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetSequenceOperatorRecognition(
        arg1: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dataObject {
    pub supplementalInfo: *mut ::std::os::raw::c_void,
    pub type_: ::std::os::raw::c_ushort,
    pub value: *mut ::std::os::raw::c_void,
    pub begin: ::std::os::raw::c_long,
    pub end: ::std::os::raw::c_long,
    pub next: *mut dataObject,
}
#[test]
fn bindgen_test_layout_dataObject() {
    assert_eq!(
        ::std::mem::size_of::<dataObject>(),
        48usize,
        concat!("Size of: ", stringify!(dataObject))
    );
    assert_eq!(
        ::std::mem::align_of::<dataObject>(),
        8usize,
        concat!("Alignment of ", stringify!(dataObject))
    );
    assert_eq!(
        unsafe { &(*(0 as *const dataObject)).supplementalInfo as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(dataObject),
            "::",
            stringify!(supplementalInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const dataObject)).type_ as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(dataObject),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const dataObject)).value as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(dataObject),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const dataObject)).begin as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(dataObject),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const dataObject)).end as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(dataObject),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const dataObject)).next as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(dataObject),
            "::",
            stringify!(next)
        )
    );
}
pub type DATA_OBJECT = dataObject;
pub type DATA_OBJECT_PTR = *mut dataObject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct entityRecord {
    pub name: *const ::std::os::raw::c_char,
    pub _bitfield_1: u16,
    pub shortPrintFunction:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut ::std::os::raw::c_void),
        >,
    pub longPrintFunction:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *mut ::std::os::raw::c_void),
        >,
    pub deleteFunction:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void)
                                 -> ::std::os::raw::c_int,
        >,
    pub evaluateFunction:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void,
                                 arg3: *mut DATA_OBJECT)
                                 -> ::std::os::raw::c_int,
        >,
    pub getNextFunction:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void)
                                 -> *mut ::std::os::raw::c_void,
        >,
    pub decrementBusyCount:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
    pub incrementBusyCount:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
    pub propagateDepth:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
    pub markNeeded: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut ::std::os::raw::c_void),
    >,
    pub install: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut ::std::os::raw::c_void),
    >,
    pub deinstall: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut ::std::os::raw::c_void),
    >,
    pub usrData: *mut userData,
}
#[test]
fn bindgen_test_layout_entityRecord() {
    assert_eq!(
        ::std::mem::size_of::<entityRecord>(),
        112usize,
        concat!("Size of: ", stringify!(entityRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<entityRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(entityRecord))
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).shortPrintFunction as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(shortPrintFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).longPrintFunction as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(longPrintFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).deleteFunction as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(deleteFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).evaluateFunction as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(evaluateFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).getNextFunction as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(getNextFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).decrementBusyCount as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(decrementBusyCount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).incrementBusyCount as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(incrementBusyCount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).propagateDepth as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(propagateDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).markNeeded as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(markNeeded)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).install as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(install)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).deinstall as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(deinstall)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const entityRecord)).usrData as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(entityRecord),
            "::",
            stringify!(usrData)
        )
    );
}
impl entityRecord {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x1fff as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1fff as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn copyToEvaluate(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x2000 as u16;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_copyToEvaluate(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2000 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn bitMap(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x4000 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bitMap(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4000 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn addsToRuleComplexity(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x8000 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_addsToRuleComplexity(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x8000 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        copyToEvaluate: ::std::os::raw::c_uint,
        bitMap: ::std::os::raw::c_uint,
        addsToRuleComplexity: ::std::os::raw::c_uint,
    ) -> u16 {
        ((((0 | ((type_ as u32 as u16) << 0usize) & (0x1fff as u16)) |
               ((copyToEvaluate as u32 as u16) << 13usize) & (0x2000 as u16)) |
              ((bitMap as u32 as u16) << 14usize) & (0x4000 as u16)) |
             ((addsToRuleComplexity as u32 as u16) << 15usize) & (0x8000 as u16))
    }
}
extern "C" {
    pub fn EnvSetMultifieldErrorValue(arg1: *mut ::std::os::raw::c_void, arg2: *mut dataObject);
}
extern "C" {
    pub fn EnvFunctionCall(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct field {
    pub type_: ::std::os::raw::c_ushort,
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_field() {
    assert_eq!(
        ::std::mem::size_of::<field>(),
        16usize,
        concat!("Size of: ", stringify!(field))
    );
    assert_eq!(
        ::std::mem::align_of::<field>(),
        8usize,
        concat!("Alignment of ", stringify!(field))
    );
    assert_eq!(
        unsafe { &(*(0 as *const field)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(field),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const field)).value as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(field),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multifield {
    pub busyCount: ::std::os::raw::c_uint,
    pub multifieldLength: ::std::os::raw::c_long,
    pub next: *mut multifield,
    pub theFields: [field; 1usize],
}
#[test]
fn bindgen_test_layout_multifield() {
    assert_eq!(
        ::std::mem::size_of::<multifield>(),
        40usize,
        concat!("Size of: ", stringify!(multifield))
    );
    assert_eq!(
        ::std::mem::align_of::<multifield>(),
        8usize,
        concat!("Alignment of ", stringify!(multifield))
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifield)).busyCount as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifield),
            "::",
            stringify!(busyCount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifield)).multifieldLength as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifield),
            "::",
            stringify!(multifieldLength)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifield)).next as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifield),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifield)).theFields as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifield),
            "::",
            stringify!(theFields)
        )
    );
}
extern "C" {
    pub fn EnvCreateMultifield(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DOToMultifield(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut DATA_OBJECT,
    ) -> *mut ::std::os::raw::c_void;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symbolHashNode {
    pub next: *mut symbolHashNode,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_symbolHashNode() {
    assert_eq!(
        ::std::mem::size_of::<symbolHashNode>(),
        32usize,
        concat!("Size of: ", stringify!(symbolHashNode))
    );
    assert_eq!(
        ::std::mem::align_of::<symbolHashNode>(),
        8usize,
        concat!("Alignment of ", stringify!(symbolHashNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const symbolHashNode)).next as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(symbolHashNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const symbolHashNode)).count as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(symbolHashNode),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const symbolHashNode)).contents as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(symbolHashNode),
            "::",
            stringify!(contents)
        )
    );
}
impl symbolHashNode {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x1 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x2 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn neededSymbol(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x4 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededSymbol(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xfffffff8 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0xfffffff8 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        permanent: ::std::os::raw::c_uint,
        markedEphemeral: ::std::os::raw::c_uint,
        neededSymbol: ::std::os::raw::c_uint,
        bucket: ::std::os::raw::c_uint,
    ) -> u32 {
        ((((0 | ((permanent as u32 as u32) << 0usize) & (0x1 as u32)) |
               ((markedEphemeral as u32 as u32) << 1usize) & (0x2 as u32)) |
              ((neededSymbol as u32 as u32) << 2usize) & (0x4 as u32)) |
             ((bucket as u32 as u32) << 3usize) & (0xfffffff8 as u32))
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct floatHashNode {
    pub next: *mut floatHashNode,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: f64,
}
#[test]
fn bindgen_test_layout_floatHashNode() {
    assert_eq!(
        ::std::mem::size_of::<floatHashNode>(),
        32usize,
        concat!("Size of: ", stringify!(floatHashNode))
    );
    assert_eq!(
        ::std::mem::align_of::<floatHashNode>(),
        8usize,
        concat!("Alignment of ", stringify!(floatHashNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const floatHashNode)).next as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(floatHashNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const floatHashNode)).count as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(floatHashNode),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const floatHashNode)).contents as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(floatHashNode),
            "::",
            stringify!(contents)
        )
    );
}
impl floatHashNode {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x1 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x2 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn neededFloat(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x4 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededFloat(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xfffffff8 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0xfffffff8 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        permanent: ::std::os::raw::c_uint,
        markedEphemeral: ::std::os::raw::c_uint,
        neededFloat: ::std::os::raw::c_uint,
        bucket: ::std::os::raw::c_uint,
    ) -> u32 {
        ((((0 | ((permanent as u32 as u32) << 0usize) & (0x1 as u32)) |
               ((markedEphemeral as u32 as u32) << 1usize) & (0x2 as u32)) |
              ((neededFloat as u32 as u32) << 2usize) & (0x4 as u32)) |
             ((bucket as u32 as u32) << 3usize) & (0xfffffff8 as u32))
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct integerHashNode {
    pub next: *mut integerHashNode,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_integerHashNode() {
    assert_eq!(
        ::std::mem::size_of::<integerHashNode>(),
        32usize,
        concat!("Size of: ", stringify!(integerHashNode))
    );
    assert_eq!(
        ::std::mem::align_of::<integerHashNode>(),
        8usize,
        concat!("Alignment of ", stringify!(integerHashNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const integerHashNode)).next as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(integerHashNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const integerHashNode)).count as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(integerHashNode),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const integerHashNode)).contents as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(integerHashNode),
            "::",
            stringify!(contents)
        )
    );
}
impl integerHashNode {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x1 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x2 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn neededInteger(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x4 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededInteger(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xfffffff8 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0xfffffff8 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        permanent: ::std::os::raw::c_uint,
        markedEphemeral: ::std::os::raw::c_uint,
        neededInteger: ::std::os::raw::c_uint,
        bucket: ::std::os::raw::c_uint,
    ) -> u32 {
        ((((0 | ((permanent as u32 as u32) << 0usize) & (0x1 as u32)) |
               ((markedEphemeral as u32 as u32) << 1usize) & (0x2 as u32)) |
              ((neededInteger as u32 as u32) << 2usize) & (0x4 as u32)) |
             ((bucket as u32 as u32) << 3usize) & (0xfffffff8 as u32))
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitMapHashNode {
    pub next: *mut bitMapHashNode,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub contents: *const ::std::os::raw::c_char,
    pub size: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_bitMapHashNode() {
    assert_eq!(
        ::std::mem::size_of::<bitMapHashNode>(),
        40usize,
        concat!("Size of: ", stringify!(bitMapHashNode))
    );
    assert_eq!(
        ::std::mem::align_of::<bitMapHashNode>(),
        8usize,
        concat!("Alignment of ", stringify!(bitMapHashNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const bitMapHashNode)).next as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(bitMapHashNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const bitMapHashNode)).count as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(bitMapHashNode),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const bitMapHashNode)).contents as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(bitMapHashNode),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const bitMapHashNode)).size as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(bitMapHashNode),
            "::",
            stringify!(size)
        )
    );
}
impl bitMapHashNode {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x1 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x2 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn neededBitMap(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x4 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededBitMap(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xfffffff8 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0xfffffff8 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        permanent: ::std::os::raw::c_uint,
        markedEphemeral: ::std::os::raw::c_uint,
        neededBitMap: ::std::os::raw::c_uint,
        bucket: ::std::os::raw::c_uint,
    ) -> u32 {
        ((((0 | ((permanent as u32 as u32) << 0usize) & (0x1 as u32)) |
               ((markedEphemeral as u32 as u32) << 1usize) & (0x2 as u32)) |
              ((neededBitMap as u32 as u32) << 2usize) & (0x4 as u32)) |
             ((bucket as u32 as u32) << 3usize) & (0xfffffff8 as u32))
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct externalAddressHashNode {
    pub next: *mut externalAddressHashNode,
    pub count: ::std::os::raw::c_long,
    pub _bitfield_1: u32,
    pub externalAddress: *mut ::std::os::raw::c_void,
    pub type_: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_externalAddressHashNode() {
    assert_eq!(
        ::std::mem::size_of::<externalAddressHashNode>(),
        40usize,
        concat!("Size of: ", stringify!(externalAddressHashNode))
    );
    assert_eq!(
        ::std::mem::align_of::<externalAddressHashNode>(),
        8usize,
        concat!("Alignment of ", stringify!(externalAddressHashNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const externalAddressHashNode)).next as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(externalAddressHashNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const externalAddressHashNode)).count as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(externalAddressHashNode),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const externalAddressHashNode)).externalAddress as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(externalAddressHashNode),
            "::",
            stringify!(externalAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const externalAddressHashNode)).type_ as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(externalAddressHashNode),
            "::",
            stringify!(type_)
        )
    );
}
impl externalAddressHashNode {
    #[inline]
    pub fn permanent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x1 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_permanent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn markedEphemeral(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x2 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_markedEphemeral(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn neededPointer(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x4 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_neededPointer(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn bucket(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xfffffff8 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bucket(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0xfffffff8 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        permanent: ::std::os::raw::c_uint,
        markedEphemeral: ::std::os::raw::c_uint,
        neededPointer: ::std::os::raw::c_uint,
        bucket: ::std::os::raw::c_uint,
    ) -> u32 {
        ((((0 | ((permanent as u32 as u32) << 0usize) & (0x1 as u32)) |
               ((markedEphemeral as u32 as u32) << 1usize) & (0x2 as u32)) |
              ((neededPointer as u32 as u32) << 2usize) & (0x4 as u32)) |
             ((bucket as u32 as u32) << 3usize) & (0xfffffff8 as u32))
    }
}
pub type SYMBOL_HN = symbolHashNode;
extern "C" {
    pub fn EnvAddSymbol(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvAddDouble(
        arg1: *mut ::std::os::raw::c_void,
        arg2: f64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvAddLong(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_longlong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvAddBitMap(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvAddExternalAddress(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFalseSymbol(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvTrueSymbol(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn AllocateEnvironmentData(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DeallocateEnvironmentData() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CreateEnvironment() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CreateRuntimeEnvironment(
        arg1: *mut *mut symbolHashNode,
        arg2: *mut *mut floatHashNode,
        arg3: *mut *mut integerHashNode,
        arg4: *mut *mut bitMapHashNode,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DestroyEnvironment(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AddEnvironmentCleanupFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetEnvironmentContext(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SetEnvironmentContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GetEnvironmentRouterContext(
        arg1: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SetEnvironmentRouterContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GetEnvironmentFunctionContext(
        arg1: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SetEnvironmentFunctionContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GetEnvironmentCallbackContext(
        arg1: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SetEnvironmentCallbackContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct constructHeader {
    pub name: *mut symbolHashNode,
    pub ppForm: *const ::std::os::raw::c_char,
    pub whichModule: *mut defmoduleItemHeader,
    pub bsaveID: ::std::os::raw::c_long,
    pub next: *mut constructHeader,
    pub usrData: *mut userData,
}
#[test]
fn bindgen_test_layout_constructHeader() {
    assert_eq!(
        ::std::mem::size_of::<constructHeader>(),
        48usize,
        concat!("Size of: ", stringify!(constructHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<constructHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(constructHeader))
    );
    assert_eq!(
        unsafe { &(*(0 as *const constructHeader)).name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(constructHeader),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constructHeader)).ppForm as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(constructHeader),
            "::",
            stringify!(ppForm)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constructHeader)).whichModule as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(constructHeader),
            "::",
            stringify!(whichModule)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constructHeader)).bsaveID as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(constructHeader),
            "::",
            stringify!(bsaveID)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constructHeader)).next as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(constructHeader),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constructHeader)).usrData as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(constructHeader),
            "::",
            stringify!(usrData)
        )
    );
}
extern "C" {
    pub fn EnvClear(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvReset(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvSave(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddResetFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRemoveResetFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddClearFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRemoveClearFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvIncrementClearReadyLocks(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvDecrementClearReadyLocks(arg1: *mut ::std::os::raw::c_void);
}

extern "C" {
    pub fn EnvAddPeriodicFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRemovePeriodicFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvIncrementGCLocks(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvDecrementGCLocks(arg1: *mut ::std::os::raw::c_void);
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct defmodule {
    pub name: *mut symbolHashNode,
    pub ppForm: *mut ::std::os::raw::c_char,
    pub itemsArray: *mut *mut defmoduleItemHeader,
    pub importList: *mut portItem,
    pub exportList: *mut portItem,
    pub visitedFlag: ::std::os::raw::c_uint,
    pub bsaveID: ::std::os::raw::c_long,
    pub usrData: *mut userData,
    pub next: *mut defmodule,
}
#[test]
fn bindgen_test_layout_defmodule() {
    assert_eq!(
        ::std::mem::size_of::<defmodule>(),
        72usize,
        concat!("Size of: ", stringify!(defmodule))
    );
    assert_eq!(
        ::std::mem::align_of::<defmodule>(),
        8usize,
        concat!("Alignment of ", stringify!(defmodule))
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).ppForm as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(ppForm)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).itemsArray as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(itemsArray)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).importList as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(importList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).exportList as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(exportList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).visitedFlag as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(visitedFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).bsaveID as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(bsaveID)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).usrData as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(usrData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmodule)).next as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmodule),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct portItem {
    pub moduleName: *mut symbolHashNode,
    pub constructType: *mut symbolHashNode,
    pub constructName: *mut symbolHashNode,
    pub next: *mut portItem,
}
#[test]
fn bindgen_test_layout_portItem() {
    assert_eq!(
        ::std::mem::size_of::<portItem>(),
        32usize,
        concat!("Size of: ", stringify!(portItem))
    );
    assert_eq!(
        ::std::mem::align_of::<portItem>(),
        8usize,
        concat!("Alignment of ", stringify!(portItem))
    );
    assert_eq!(
        unsafe { &(*(0 as *const portItem)).moduleName as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(portItem),
            "::",
            stringify!(moduleName)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const portItem)).constructType as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(portItem),
            "::",
            stringify!(constructType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const portItem)).constructName as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(portItem),
            "::",
            stringify!(constructName)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const portItem)).next as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(portItem),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct defmoduleItemHeader {
    pub theModule: *mut defmodule,
    pub firstItem: *mut constructHeader,
    pub lastItem: *mut constructHeader,
}
#[test]
fn bindgen_test_layout_defmoduleItemHeader() {
    assert_eq!(
        ::std::mem::size_of::<defmoduleItemHeader>(),
        24usize,
        concat!("Size of: ", stringify!(defmoduleItemHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<defmoduleItemHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(defmoduleItemHeader))
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmoduleItemHeader)).theModule as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmoduleItemHeader),
            "::",
            stringify!(theModule)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmoduleItemHeader)).firstItem as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmoduleItemHeader),
            "::",
            stringify!(firstItem)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defmoduleItemHeader)).lastItem as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(defmoduleItemHeader),
            "::",
            stringify!(lastItem)
        )
    );
}
extern "C" {
    pub fn EnvFindDefmodule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetDefmoduleName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefmodulePPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetNextDefmodule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetCurrentModule(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvSetCurrentModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvRtnArgCount(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvArgCountCheck(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvArgRangeCheck(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRtnLexeme(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvRtnDouble(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn EnvRtnLong(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn EnvRtnUnknown(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut dataObject,
    ) -> *mut dataObject;
}
extern "C" {
    pub fn EnvArgTypeCheck(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut dataObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvMemUsed(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvMemRequests(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvReleaseMem(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvSetConserveMemory(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetConserveMemory(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvLoad(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetParsingFileName(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvSetParsingFileName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvGetErrorFileName(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvSetErrorFileName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvGetWarningFileName(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvSetWarningFileName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvDribbleOn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDribbleActive(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDribbleOff(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvBatchStar(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvBuild(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvEval(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: DATA_OBJECT_PTR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvPrintRouter(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetcRouter(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvUngetcRouter(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvExitRouter(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EnvAddRouterWithContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int,
        >,
        arg6: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int,
        >,
        arg7: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: ::std::os::raw::c_int,
                                 arg3: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int,
        >,
        arg8: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: ::std::os::raw::c_int)
                                 -> ::std::os::raw::c_int,
        >,
        arg9: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddRouter(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int,
        >,
        arg6: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int,
        >,
        arg7: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: ::std::os::raw::c_int,
                                 arg3: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int,
        >,
        arg8: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: ::std::os::raw::c_int)
                                 -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeleteRouter(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeactivateRouter(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvActivateRouter(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvInitializeEnvironment(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut symbolHashNode,
        arg3: *mut *mut floatHashNode,
        arg4: *mut *mut integerHashNode,
        arg5: *mut *mut bitMapHashNode,
        arg6: *mut *mut externalAddressHashNode,
    );
}
extern "C" {
    pub fn SetPauseEnvFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn SetContinueEnvFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: ::std::os::raw::c_int),
        >,
    );
}
extern "C" {
    pub fn GetPauseEnvFunction(
        arg1: *mut ::std::os::raw::c_void,
    ) -> ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
}
extern "C" {
    pub fn GetContinueEnvFunction(
        arg1: *mut ::std::os::raw::c_void,
    ) -> ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
}
extern "C" {
    pub fn EnvGetAutoFloatDividend(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetAutoFloatDividend(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvUnwatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetWatchItem(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
        arg4: *mut expr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetWatchItem(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDefmoduleList(arg1: *mut ::std::os::raw::c_void, arg2: DATA_OBJECT_PTR);
}
extern "C" {
    pub fn EnvListDefmodules(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvBload(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvBsave(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct constraintRecord {
    pub _bitfield_1: [u8; 3usize],
    pub bsaveIndex: ::std::os::raw::c_ushort,
    pub classList: *mut expr,
    pub restrictionList: *mut expr,
    pub minValue: *mut expr,
    pub maxValue: *mut expr,
    pub minFields: *mut expr,
    pub maxFields: *mut expr,
    pub multifield: *mut constraintRecord,
    pub next: *mut constraintRecord,
    pub bucket: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_constraintRecord() {
    assert_eq!(
        ::std::mem::size_of::<constraintRecord>(),
        80usize,
        concat!("Size of: ", stringify!(constraintRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<constraintRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(constraintRecord))
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).bsaveIndex as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(bsaveIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).classList as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(classList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).restrictionList as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(restrictionList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).minValue as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(minValue)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).maxValue as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(maxValue)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).minFields as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(minFields)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).maxFields as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(maxFields)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).multifield as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(multifield)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).next as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).bucket as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(bucket)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const constraintRecord)).count as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(constraintRecord),
            "::",
            stringify!(count)
        )
    );
}
impl constraintRecord {
    #[inline]
    pub fn anyAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x1 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_anyAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn symbolsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x2 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_symbolsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn stringsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x4 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_stringsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn floatsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x8 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_floatsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x8 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn integersAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x10 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_integersAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x10 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn instanceNamesAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x20 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_instanceNamesAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x20 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn instanceAddressesAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x40 as u32;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_instanceAddressesAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x40 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn externalAddressesAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x80 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_externalAddressesAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x80 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn factAddressesAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x100 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_factAddressesAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x100 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn voidAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x200 as u32;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_voidAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x200 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn anyRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x400 as u32;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_anyRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x400 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn symbolRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x800 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_symbolRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x800 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn stringRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x1000 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_stringRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn floatRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x2000 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_floatRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn integerRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x4000 as u32;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_integerRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn classRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x8000 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_classRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x8000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn instanceNameRestriction(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x10000 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_instanceNameRestriction(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x10000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn multifieldsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x20000 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_multifieldsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x20000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn singlefieldsAllowed(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x40000 as u32;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_singlefieldsAllowed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x40000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        anyAllowed: ::std::os::raw::c_uint,
        symbolsAllowed: ::std::os::raw::c_uint,
        stringsAllowed: ::std::os::raw::c_uint,
        floatsAllowed: ::std::os::raw::c_uint,
        integersAllowed: ::std::os::raw::c_uint,
        instanceNamesAllowed: ::std::os::raw::c_uint,
        instanceAddressesAllowed: ::std::os::raw::c_uint,
        externalAddressesAllowed: ::std::os::raw::c_uint,
        factAddressesAllowed: ::std::os::raw::c_uint,
        voidAllowed: ::std::os::raw::c_uint,
        anyRestriction: ::std::os::raw::c_uint,
        symbolRestriction: ::std::os::raw::c_uint,
        stringRestriction: ::std::os::raw::c_uint,
        floatRestriction: ::std::os::raw::c_uint,
        integerRestriction: ::std::os::raw::c_uint,
        classRestriction: ::std::os::raw::c_uint,
        instanceNameRestriction: ::std::os::raw::c_uint,
        multifieldsAllowed: ::std::os::raw::c_uint,
        singlefieldsAllowed: ::std::os::raw::c_uint,
    ) -> u32 {
        (((((((((((((((((((0 | ((anyAllowed as u32 as u32) << 0usize) & (0x1 as u32)) |
                              ((symbolsAllowed as u32 as u32) << 1usize) & (0x2 as u32)) |
                             ((stringsAllowed as u32 as u32) << 2usize) & (0x4 as u32)) |
                            ((floatsAllowed as u32 as u32) << 3usize) & (0x8 as u32)) |
                           ((integersAllowed as u32 as u32) << 4usize) & (0x10 as u32)) |
                          ((instanceNamesAllowed as u32 as u32) << 5usize) & (0x20 as u32)) |
                         ((instanceAddressesAllowed as u32 as u32) << 6usize) & (0x40 as u32)) |
                        ((externalAddressesAllowed as u32 as u32) << 7usize) & (0x80 as u32)) |
                       ((factAddressesAllowed as u32 as u32) << 8usize) & (0x100 as u32)) |
                      ((voidAllowed as u32 as u32) << 9usize) & (0x200 as u32)) |
                     ((anyRestriction as u32 as u32) << 10usize) & (0x400 as u32)) |
                    ((symbolRestriction as u32 as u32) << 11usize) & (0x800 as u32)) |
                   ((stringRestriction as u32 as u32) << 12usize) & (0x1000 as u32)) |
                  ((floatRestriction as u32 as u32) << 13usize) & (0x2000 as u32)) |
                 ((integerRestriction as u32 as u32) << 14usize) & (0x4000 as u32)) |
                ((classRestriction as u32 as u32) << 15usize) & (0x8000 as u32)) |
               ((instanceNameRestriction as u32 as u32) << 16usize) & (0x10000 as u32)) |
              ((multifieldsAllowed as u32 as u32) << 17usize) & (0x20000 as u32)) |
             ((singlefieldsAllowed as u32 as u32) << 18usize) & (0x40000 as u32))
    }
}
pub type CONSTRAINT_RECORD = constraintRecord;
extern "C" {
    pub fn EnvSetDynamicConstraintChecking(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDynamicConstraintChecking(
        arg1: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetStaticConstraintChecking(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetStaticConstraintChecking(
        arg1: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetConstructNameString(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut constructHeader,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct patternNodeHeader {
    pub firstHash: *mut alphaMemoryHash,
    pub lastHash: *mut alphaMemoryHash,
    pub entryJoin: *mut joinNode,
    pub rightHash: *mut expr,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_patternNodeHeader() {
    assert_eq!(
        ::std::mem::size_of::<patternNodeHeader>(),
        40usize,
        concat!("Size of: ", stringify!(patternNodeHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<patternNodeHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(patternNodeHeader))
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternNodeHeader)).firstHash as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternNodeHeader),
            "::",
            stringify!(firstHash)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternNodeHeader)).lastHash as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternNodeHeader),
            "::",
            stringify!(lastHash)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternNodeHeader)).entryJoin as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternNodeHeader),
            "::",
            stringify!(entryJoin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternNodeHeader)).rightHash as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternNodeHeader),
            "::",
            stringify!(rightHash)
        )
    );
}
impl patternNodeHeader {
    #[inline]
    pub fn singlefieldNode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x1 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_singlefieldNode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn multifieldNode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x2 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_multifieldNode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn stopNode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x4 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_stopNode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn initialize(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x8 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_initialize(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x8 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn marked(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x10 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_marked(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x10 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn beginSlot(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x20 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_beginSlot(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x20 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn endSlot(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x40 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_endSlot(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x40 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn selector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x80 as u8;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_selector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x80 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        singlefieldNode: ::std::os::raw::c_uint,
        multifieldNode: ::std::os::raw::c_uint,
        stopNode: ::std::os::raw::c_uint,
        initialize: ::std::os::raw::c_uint,
        marked: ::std::os::raw::c_uint,
        beginSlot: ::std::os::raw::c_uint,
        endSlot: ::std::os::raw::c_uint,
        selector: ::std::os::raw::c_uint,
    ) -> u8 {
        ((((((((0 | ((singlefieldNode as u32 as u8) << 0usize) & (0x1 as u8)) |
                   ((multifieldNode as u32 as u8) << 1usize) & (0x2 as u8)) |
                  ((stopNode as u32 as u8) << 2usize) & (0x4 as u8)) |
                 ((initialize as u32 as u8) << 3usize) & (0x8 as u8)) |
                ((marked as u32 as u8) << 4usize) & (0x10 as u8)) |
               ((beginSlot as u32 as u8) << 5usize) & (0x20 as u8)) |
              ((endSlot as u32 as u8) << 6usize) & (0x40 as u8)) |
             ((selector as u32 as u8) << 7usize) & (0x80 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alphaMemoryHash {
    pub bucket: ::std::os::raw::c_ulong,
    pub owner: *mut patternNodeHeader,
    pub alphaMemory: *mut partialMatch,
    pub endOfQueue: *mut partialMatch,
    pub nextHash: *mut alphaMemoryHash,
    pub prevHash: *mut alphaMemoryHash,
    pub next: *mut alphaMemoryHash,
    pub prev: *mut alphaMemoryHash,
}
#[test]
fn bindgen_test_layout_alphaMemoryHash() {
    assert_eq!(
        ::std::mem::size_of::<alphaMemoryHash>(),
        64usize,
        concat!("Size of: ", stringify!(alphaMemoryHash))
    );
    assert_eq!(
        ::std::mem::align_of::<alphaMemoryHash>(),
        8usize,
        concat!("Alignment of ", stringify!(alphaMemoryHash))
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMemoryHash)).bucket as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMemoryHash),
            "::",
            stringify!(bucket)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMemoryHash)).owner as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMemoryHash),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMemoryHash)).alphaMemory as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMemoryHash),
            "::",
            stringify!(alphaMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMemoryHash)).endOfQueue as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMemoryHash),
            "::",
            stringify!(endOfQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMemoryHash)).nextHash as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMemoryHash),
            "::",
            stringify!(nextHash)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMemoryHash)).prevHash as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMemoryHash),
            "::",
            stringify!(prevHash)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMemoryHash)).next as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMemoryHash),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMemoryHash)).prev as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMemoryHash),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct betaMemory {
    pub size: ::std::os::raw::c_ulong,
    pub count: ::std::os::raw::c_ulong,
    pub beta: *mut *mut partialMatch,
    pub last: *mut *mut partialMatch,
}
#[test]
fn bindgen_test_layout_betaMemory() {
    assert_eq!(
        ::std::mem::size_of::<betaMemory>(),
        32usize,
        concat!("Size of: ", stringify!(betaMemory))
    );
    assert_eq!(
        ::std::mem::align_of::<betaMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(betaMemory))
    );
    assert_eq!(
        unsafe { &(*(0 as *const betaMemory)).size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(betaMemory),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const betaMemory)).count as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(betaMemory),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const betaMemory)).beta as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(betaMemory),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const betaMemory)).last as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(betaMemory),
            "::",
            stringify!(last)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct joinLink {
    pub enterDirection: ::std::os::raw::c_char,
    pub join: *mut joinNode,
    pub next: *mut joinLink,
    pub bsaveID: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_joinLink() {
    assert_eq!(
        ::std::mem::size_of::<joinLink>(),
        32usize,
        concat!("Size of: ", stringify!(joinLink))
    );
    assert_eq!(
        ::std::mem::align_of::<joinLink>(),
        8usize,
        concat!("Alignment of ", stringify!(joinLink))
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinLink)).enterDirection as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinLink),
            "::",
            stringify!(enterDirection)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinLink)).join as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinLink),
            "::",
            stringify!(join)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinLink)).next as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinLink),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinLink)).bsaveID as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinLink),
            "::",
            stringify!(bsaveID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct joinNode {
    pub _bitfield_1: [u16; 2usize],
    pub bsaveID: ::std::os::raw::c_long,
    pub memoryLeftAdds: ::std::os::raw::c_longlong,
    pub memoryRightAdds: ::std::os::raw::c_longlong,
    pub memoryLeftDeletes: ::std::os::raw::c_longlong,
    pub memoryRightDeletes: ::std::os::raw::c_longlong,
    pub memoryCompares: ::std::os::raw::c_longlong,
    pub leftMemory: *mut betaMemory,
    pub rightMemory: *mut betaMemory,
    pub networkTest: *mut expr,
    pub secondaryNetworkTest: *mut expr,
    pub leftHash: *mut expr,
    pub rightHash: *mut expr,
    pub rightSideEntryStructure: *mut ::std::os::raw::c_void,
    pub nextLinks: *mut joinLink,
    pub lastLevel: *mut joinNode,
    pub rightMatchNode: *mut joinNode,
    pub ruleToActivate: *mut defrule,
}
#[test]
fn bindgen_test_layout_joinNode() {
    assert_eq!(
        ::std::mem::size_of::<joinNode>(),
        144usize,
        concat!("Size of: ", stringify!(joinNode))
    );
    assert_eq!(
        ::std::mem::align_of::<joinNode>(),
        8usize,
        concat!("Alignment of ", stringify!(joinNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).bsaveID as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(bsaveID)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).memoryLeftAdds as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(memoryLeftAdds)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).memoryRightAdds as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(memoryRightAdds)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).memoryLeftDeletes as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(memoryLeftDeletes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).memoryRightDeletes as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(memoryRightDeletes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).memoryCompares as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(memoryCompares)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).leftMemory as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(leftMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).rightMemory as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(rightMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).networkTest as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(networkTest)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).secondaryNetworkTest as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(secondaryNetworkTest)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).leftHash as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(leftHash)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).rightHash as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(rightHash)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).rightSideEntryStructure as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(rightSideEntryStructure)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).nextLinks as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(nextLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).lastLevel as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(lastLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).rightMatchNode as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(rightMatchNode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinNode)).ruleToActivate as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinNode),
            "::",
            stringify!(ruleToActivate)
        )
    );
}
impl joinNode {
    #[inline]
    pub fn firstJoin(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x1 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_firstJoin(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn logicalJoin(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x2 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_logicalJoin(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn joinFromTheRight(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x4 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_joinFromTheRight(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn patternIsNegated(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x8 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_patternIsNegated(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x8 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn patternIsExists(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x10 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_patternIsExists(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x10 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn initialize(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x20 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_initialize(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x20 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn marked(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x40 as u32;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_marked(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x40 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn rhsType(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x380 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rhsType(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x380 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn depth(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0x3fffc00 as u32;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_depth(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x3fffc00 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        firstJoin: ::std::os::raw::c_uint,
        logicalJoin: ::std::os::raw::c_uint,
        joinFromTheRight: ::std::os::raw::c_uint,
        patternIsNegated: ::std::os::raw::c_uint,
        patternIsExists: ::std::os::raw::c_uint,
        initialize: ::std::os::raw::c_uint,
        marked: ::std::os::raw::c_uint,
        rhsType: ::std::os::raw::c_uint,
        depth: ::std::os::raw::c_uint,
    ) -> u32 {
        (((((((((0 | ((firstJoin as u32 as u32) << 0usize) & (0x1 as u32)) |
                    ((logicalJoin as u32 as u32) << 1usize) & (0x2 as u32)) |
                   ((joinFromTheRight as u32 as u32) << 2usize) & (0x4 as u32)) |
                  ((patternIsNegated as u32 as u32) << 3usize) & (0x8 as u32)) |
                 ((patternIsExists as u32 as u32) << 4usize) & (0x10 as u32)) |
                ((initialize as u32 as u32) << 5usize) & (0x20 as u32)) |
               ((marked as u32 as u32) << 6usize) & (0x40 as u32)) |
              ((rhsType as u32 as u32) << 7usize) & (0x380 as u32)) |
             ((depth as u32 as u32) << 10usize) & (0x3fffc00 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct patternEntityRecord {
    pub base: entityRecord,
    pub decrementBasisCount:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
    pub incrementBasisCount:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
    pub matchFunction:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
    pub synchronized:
        ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void)
                                 -> ::std::os::raw::c_int,
        >,
    pub isDeleted: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut ::std::os::raw::c_void)
                             -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_patternEntityRecord() {
    assert_eq!(
        ::std::mem::size_of::<patternEntityRecord>(),
        152usize,
        concat!("Size of: ", stringify!(patternEntityRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<patternEntityRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(patternEntityRecord))
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntityRecord)).base as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntityRecord),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntityRecord)).decrementBasisCount as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntityRecord),
            "::",
            stringify!(decrementBasisCount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntityRecord)).incrementBasisCount as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntityRecord),
            "::",
            stringify!(incrementBasisCount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntityRecord)).matchFunction as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntityRecord),
            "::",
            stringify!(matchFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntityRecord)).synchronized as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntityRecord),
            "::",
            stringify!(synchronized)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntityRecord)).isDeleted as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntityRecord),
            "::",
            stringify!(isDeleted)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct patternEntity {
    pub theInfo: *mut patternEntityRecord,
    pub dependents: *mut ::std::os::raw::c_void,
    pub busyCount: ::std::os::raw::c_uint,
    pub timeTag: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_patternEntity() {
    assert_eq!(
        ::std::mem::size_of::<patternEntity>(),
        32usize,
        concat!("Size of: ", stringify!(patternEntity))
    );
    assert_eq!(
        ::std::mem::align_of::<patternEntity>(),
        8usize,
        concat!("Alignment of ", stringify!(patternEntity))
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntity)).theInfo as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntity),
            "::",
            stringify!(theInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntity)).dependents as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntity),
            "::",
            stringify!(dependents)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntity)).busyCount as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntity),
            "::",
            stringify!(busyCount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const patternEntity)).timeTag as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(patternEntity),
            "::",
            stringify!(timeTag)
        )
    );
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct genericMatch {
    pub gm: genericMatch__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]pub union genericMatch__bindgen_ty_1 { pub theValue : * mut :: std :: os :: raw :: c_void , pub theMatch : * mut alphaMatch , _bindgen_union_align : u64 , }#[test]
fn bindgen_test_layout_genericMatch__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<genericMatch__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(genericMatch__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<genericMatch__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(genericMatch__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const genericMatch__bindgen_ty_1)).theValue as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(genericMatch__bindgen_ty_1),
            "::",
            stringify!(theValue)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const genericMatch__bindgen_ty_1)).theMatch as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(genericMatch__bindgen_ty_1),
            "::",
            stringify!(theMatch)
        )
    );
}
#[test]
fn bindgen_test_layout_genericMatch() {
    assert_eq!(
        ::std::mem::size_of::<genericMatch>(),
        8usize,
        concat!("Size of: ", stringify!(genericMatch))
    );
    assert_eq!(
        ::std::mem::align_of::<genericMatch>(),
        8usize,
        concat!("Alignment of ", stringify!(genericMatch))
    );
    assert_eq!(
        unsafe { &(*(0 as *const genericMatch)).gm as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(genericMatch),
            "::",
            stringify!(gm)
        )
    );
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct partialMatch {
    pub _bitfield_1: u8,
    pub bcount: ::std::os::raw::c_ushort,
    pub hashValue: ::std::os::raw::c_ulong,
    pub owner: *mut ::std::os::raw::c_void,
    pub marker: *mut ::std::os::raw::c_void,
    pub dependents: *mut ::std::os::raw::c_void,
    pub nextInMemory: *mut partialMatch,
    pub prevInMemory: *mut partialMatch,
    pub children: *mut partialMatch,
    pub rightParent: *mut partialMatch,
    pub nextRightChild: *mut partialMatch,
    pub prevRightChild: *mut partialMatch,
    pub leftParent: *mut partialMatch,
    pub nextLeftChild: *mut partialMatch,
    pub prevLeftChild: *mut partialMatch,
    pub blockList: *mut partialMatch,
    pub nextBlocked: *mut partialMatch,
    pub prevBlocked: *mut partialMatch,
    pub binds: [genericMatch; 1usize],
}
#[test]
fn bindgen_test_layout_partialMatch() {
    assert_eq!(
        ::std::mem::size_of::<partialMatch>(),
        144usize,
        concat!("Size of: ", stringify!(partialMatch))
    );
    assert_eq!(
        ::std::mem::align_of::<partialMatch>(),
        8usize,
        concat!("Alignment of ", stringify!(partialMatch))
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).bcount as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(bcount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).hashValue as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(hashValue)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).owner as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).marker as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).dependents as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(dependents)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).nextInMemory as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(nextInMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).prevInMemory as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(prevInMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).children as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).rightParent as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(rightParent)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).nextRightChild as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(nextRightChild)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).prevRightChild as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(prevRightChild)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).leftParent as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(leftParent)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).nextLeftChild as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(nextLeftChild)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).prevLeftChild as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(prevLeftChild)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).blockList as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(blockList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).nextBlocked as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(nextBlocked)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).prevBlocked as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(prevBlocked)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const partialMatch)).binds as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(partialMatch),
            "::",
            stringify!(binds)
        )
    );
}
impl partialMatch {
    #[inline]
    pub fn betaMemory(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x1 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_betaMemory(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn busy(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x2 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_busy(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn rhsMemory(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x4 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rhsMemory(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        betaMemory: ::std::os::raw::c_uint,
        busy: ::std::os::raw::c_uint,
        rhsMemory: ::std::os::raw::c_uint,
    ) -> u8 {
        (((0 | ((betaMemory as u32 as u8) << 0usize) & (0x1 as u8)) |
              ((busy as u32 as u8) << 1usize) & (0x2 as u8)) |
             ((rhsMemory as u32 as u8) << 2usize) & (0x4 as u8))
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alphaMatch {
    pub matchingItem: *mut patternEntity,
    pub markers: *mut multifieldMarker,
    pub next: *mut alphaMatch,
    pub bucket: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_alphaMatch() {
    assert_eq!(
        ::std::mem::size_of::<alphaMatch>(),
        32usize,
        concat!("Size of: ", stringify!(alphaMatch))
    );
    assert_eq!(
        ::std::mem::align_of::<alphaMatch>(),
        8usize,
        concat!("Alignment of ", stringify!(alphaMatch))
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMatch)).matchingItem as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMatch),
            "::",
            stringify!(matchingItem)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMatch)).markers as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMatch),
            "::",
            stringify!(markers)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMatch)).next as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMatch),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const alphaMatch)).bucket as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(alphaMatch),
            "::",
            stringify!(bucket)
        )
    );
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct multifieldMarker {
    pub whichField: ::std::os::raw::c_int,
    pub where_: multifieldMarker__bindgen_ty_1,
    pub startPosition: ::std::os::raw::c_long,
    pub endPosition: ::std::os::raw::c_long,
    pub next: *mut multifieldMarker,
}
#[repr(C)]
#[derive(Copy, Clone)]pub union multifieldMarker__bindgen_ty_1 { pub whichSlot : * mut :: std :: os :: raw :: c_void , pub whichSlotNumber : :: std :: os :: raw :: c_short , _bindgen_union_align : u64 , }#[test]
fn bindgen_test_layout_multifieldMarker__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<multifieldMarker__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(multifieldMarker__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<multifieldMarker__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(multifieldMarker__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifieldMarker__bindgen_ty_1)).whichSlot as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifieldMarker__bindgen_ty_1),
            "::",
            stringify!(whichSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const multifieldMarker__bindgen_ty_1)).whichSlotNumber as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifieldMarker__bindgen_ty_1),
            "::",
            stringify!(whichSlotNumber)
        )
    );
}
#[test]
fn bindgen_test_layout_multifieldMarker() {
    assert_eq!(
        ::std::mem::size_of::<multifieldMarker>(),
        40usize,
        concat!("Size of: ", stringify!(multifieldMarker))
    );
    assert_eq!(
        ::std::mem::align_of::<multifieldMarker>(),
        8usize,
        concat!("Alignment of ", stringify!(multifieldMarker))
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifieldMarker)).whichField as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifieldMarker),
            "::",
            stringify!(whichField)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifieldMarker)).where_ as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifieldMarker),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifieldMarker)).startPosition as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifieldMarker),
            "::",
            stringify!(startPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifieldMarker)).endPosition as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifieldMarker),
            "::",
            stringify!(endPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const multifieldMarker)).next as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(multifieldMarker),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn EnvGetNextActivation(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetActivationBasis(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut partialMatch;
}
extern "C" {
    pub fn EnvGetActivationName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetActivationRule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut defrule;
}
extern "C" {
    pub fn EnvGetActivationSalience(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetActivationSalience(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetActivationPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetActivationBasisPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvDeleteActivation(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAgenda(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetAgendaChanged(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetAgendaChanged(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EnvGetSalienceEvaluation(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetSalienceEvaluation(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRefreshAgenda(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvReorderAgenda(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvRefresh(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct defrule {
    pub header: constructHeader,
    pub salience: ::std::os::raw::c_int,
    pub localVarCnt: ::std::os::raw::c_int,
    pub _bitfield_1: u16,
    pub dynamicSalience: *mut expr,
    pub actions: *mut expr,
    pub logicalJoin: *mut joinNode,
    pub lastJoin: *mut joinNode,
    pub disjunct: *mut defrule,
}
#[test]
fn bindgen_test_layout_defrule() {
    assert_eq!(
        ::std::mem::size_of::<defrule>(),
        104usize,
        concat!("Size of: ", stringify!(defrule))
    );
    assert_eq!(
        ::std::mem::align_of::<defrule>(),
        8usize,
        concat!("Alignment of ", stringify!(defrule))
    );
    assert_eq!(
        unsafe { &(*(0 as *const defrule)).header as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(defrule),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defrule)).salience as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(defrule),
            "::",
            stringify!(salience)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defrule)).localVarCnt as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(defrule),
            "::",
            stringify!(localVarCnt)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defrule)).dynamicSalience as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(defrule),
            "::",
            stringify!(dynamicSalience)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defrule)).actions as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(defrule),
            "::",
            stringify!(actions)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defrule)).logicalJoin as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(defrule),
            "::",
            stringify!(logicalJoin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defrule)).lastJoin as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(defrule),
            "::",
            stringify!(lastJoin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const defrule)).disjunct as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(defrule),
            "::",
            stringify!(disjunct)
        )
    );
}
impl defrule {
    #[inline]
    pub fn complexity(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x7ff as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_complexity(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x7ff as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn afterBreakpoint(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x800 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_afterBreakpoint(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x800 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn watchActivation(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x1000 as u16;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_watchActivation(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1000 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn watchFiring(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x2000 as u16;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_watchFiring(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2000 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn autoFocus(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x4000 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_autoFocus(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4000 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn executing(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        let mask = 0x8000 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_executing(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x8000 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u16 as *mut u8,
                ::std::mem::size_of::<u16>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u16>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        complexity: ::std::os::raw::c_uint,
        afterBreakpoint: ::std::os::raw::c_uint,
        watchActivation: ::std::os::raw::c_uint,
        watchFiring: ::std::os::raw::c_uint,
        autoFocus: ::std::os::raw::c_uint,
        executing: ::std::os::raw::c_uint,
    ) -> u16 {
        ((((((0 | ((complexity as u32 as u16) << 0usize) & (0x7ff as u16)) |
                 ((afterBreakpoint as u32 as u16) << 11usize) & (0x800 as u16)) |
                ((watchActivation as u32 as u16) << 12usize) & (0x1000 as u16)) |
               ((watchFiring as u32 as u16) << 13usize) & (0x2000 as u16)) |
              ((autoFocus as u32 as u16) << 14usize) & (0x4000 as u16)) |
             ((executing as u32 as u16) << 15usize) & (0x8000 as u16))
    }
}
extern "C" {
    pub fn EnvFindDefrule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindDefruleInModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextDefrule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvIsDefruleDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDisjunctCount(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvGetNthDisjunct(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvDefruleModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefruleName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefrulePPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvUndefrule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDefruleList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: DATA_OBJECT_PTR,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvListDefrules(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetDefruleWatchFirings(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvGetDefruleWatchActivations(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvSetDefruleWatchFirings(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvSetDefruleWatchActivations(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvRun(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn EnvAddRunFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddRunFunctionWithContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRemoveRunFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddBeforeRunFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddBeforeRunFunctionWithContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRemoveBeforeRunFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetBreak(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvHalt(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvRemoveBreak(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvShowBreaks(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvDefruleHasBreakpoint(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvClearFocusStack(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvGetNextFocus(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFocus(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EnvGetFocusChanged(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetFocusChanged(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EnvListFocusStack(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvGetFocusStack(arg1: *mut ::std::os::raw::c_void, arg2: DATA_OBJECT_PTR);
}
extern "C" {
    pub fn EnvPopFocus(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetFocus(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetHaltRules(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetHaltRules(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EnvGetIncrementalReset(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetIncrementalReset(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct joinInformation {
    pub whichCE: ::std::os::raw::c_int,
    pub theJoin: *mut joinNode,
    pub patternBegin: ::std::os::raw::c_int,
    pub patternEnd: ::std::os::raw::c_int,
    pub marked: ::std::os::raw::c_int,
    pub theMemory: *mut betaMemory,
    pub nextJoin: *mut joinNode,
}
#[test]
fn bindgen_test_layout_joinInformation() {
    assert_eq!(
        ::std::mem::size_of::<joinInformation>(),
        48usize,
        concat!("Size of: ", stringify!(joinInformation))
    );
    assert_eq!(
        ::std::mem::align_of::<joinInformation>(),
        8usize,
        concat!("Alignment of ", stringify!(joinInformation))
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinInformation)).whichCE as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinInformation),
            "::",
            stringify!(whichCE)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinInformation)).theJoin as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinInformation),
            "::",
            stringify!(theJoin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinInformation)).patternBegin as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinInformation),
            "::",
            stringify!(patternBegin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinInformation)).patternEnd as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinInformation),
            "::",
            stringify!(patternEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinInformation)).marked as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinInformation),
            "::",
            stringify!(marked)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinInformation)).theMemory as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinInformation),
            "::",
            stringify!(theMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const joinInformation)).nextJoin as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(joinInformation),
            "::",
            stringify!(nextJoin)
        )
    );
}
extern "C" {
    pub fn EnvGetBetaMemoryResizing(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetBetaMemoryResizing(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvMatches(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvJoinActivity(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvAlphaJoinCount(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvBetaJoinCount(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvCreateJoinArray(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_long,
    ) -> *mut joinInformation;
}
extern "C" {
    pub fn EnvFreeJoinArray(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut joinInformation,
        arg3: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn EnvAlphaJoins(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
        arg4: *mut joinInformation,
    );
}
extern "C" {
    pub fn EnvBetaJoins(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
        arg4: *mut joinInformation,
    );
}
extern "C" {
    pub fn EnvSetStrategy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetStrategy(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvFindDeffacts(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindDeffactsInModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextDeffacts(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvIsDeffactsDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeffactsModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDeffactsName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDeffactsPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvUndeffacts(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDeffactsList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: DATA_OBJECT_PTR,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvListDeffacts(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct factPatternNode {
    pub header: patternNodeHeader,
    pub bsaveID: ::std::os::raw::c_long,
    pub whichField: ::std::os::raw::c_ushort,
    pub whichSlot: ::std::os::raw::c_ushort,
    pub leaveFields: ::std::os::raw::c_ushort,
    pub networkTest: *mut expr,
    pub nextLevel: *mut factPatternNode,
    pub lastLevel: *mut factPatternNode,
    pub leftNode: *mut factPatternNode,
    pub rightNode: *mut factPatternNode,
}
#[test]
fn bindgen_test_layout_factPatternNode() {
    assert_eq!(
        ::std::mem::size_of::<factPatternNode>(),
        96usize,
        concat!("Size of: ", stringify!(factPatternNode))
    );
    assert_eq!(
        ::std::mem::align_of::<factPatternNode>(),
        8usize,
        concat!("Alignment of ", stringify!(factPatternNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).header as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).bsaveID as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(bsaveID)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).whichField as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(whichField)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).whichSlot as *const _ as usize },
        50usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(whichSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).leaveFields as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(leaveFields)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).networkTest as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(networkTest)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).nextLevel as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(nextLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).lastLevel as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(lastLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).leftNode as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(leftNode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const factPatternNode)).rightNode as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(factPatternNode),
            "::",
            stringify!(rightNode)
        )
    );
}
extern "C" {
    pub fn EnvGetFactDuplication(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetFactDuplication(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fact {
    pub factHeader: patternEntity,
    pub whichDeftemplate: *mut deftemplate,
    pub list: *mut ::std::os::raw::c_void,
    pub factIndex: ::std::os::raw::c_longlong,
    pub hashValue: ::std::os::raw::c_ulong,
    pub _bitfield_1: u8,
    pub previousFact: *mut fact,
    pub nextFact: *mut fact,
    pub previousTemplateFact: *mut fact,
    pub nextTemplateFact: *mut fact,
    pub theProposition: multifield,
}
#[test]
fn bindgen_test_layout_fact() {
    assert_eq!(
        ::std::mem::size_of::<fact>(),
        144usize,
        concat!("Size of: ", stringify!(fact))
    );
    assert_eq!(
        ::std::mem::align_of::<fact>(),
        8usize,
        concat!("Alignment of ", stringify!(fact))
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).factHeader as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(factHeader)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).whichDeftemplate as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(whichDeftemplate)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).list as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).factIndex as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(factIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).hashValue as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(hashValue)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).previousFact as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(previousFact)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).nextFact as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(nextFact)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).previousTemplateFact as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(previousTemplateFact)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).nextTemplateFact as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(nextTemplateFact)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const fact)).theProposition as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(fact),
            "::",
            stringify!(theProposition)
        )
    );
}
impl fact {
    #[inline]
    pub fn garbage(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x1 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_garbage(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(garbage: ::std::os::raw::c_uint) -> u8 {
        (0 | ((garbage as u32 as u8) << 0usize) & (0x1 as u8))
    }
}
extern "C" {
    pub fn EnvAssert(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvAssertString(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvCreateFact(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut fact;
}
extern "C" {
    pub fn EnvDecrementFactCount(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvFactIndex(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn EnvGetFactSlot(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRetract(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetNextFact(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetFactPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetFactListChanged(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetFactListChanged(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EnvIncrementFactCount(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvPutFactSlot(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAssignFactSlotDefaults(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddAssertFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddAssertFunctionWithContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRemoveAssertFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddRetractFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddRetractFunctionWithContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void),
        >,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRemoveRetractFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddModifyFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void,
                                 arg3: *mut ::std::os::raw::c_void),
        >,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvAddModifyFunctionWithContext(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *mut ::std::os::raw::c_void,
                                 arg3: *mut ::std::os::raw::c_void),
        >,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvRemoveModifyFunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct deftemplate {
    pub header: constructHeader,
    pub slotList: *mut templateSlot,
    pub _bitfield_1: u8,
    pub numberOfSlots: ::std::os::raw::c_ushort,
    pub busyCount: ::std::os::raw::c_long,
    pub patternNetwork: *mut factPatternNode,
    pub factList: *mut fact,
    pub lastFact: *mut fact,
}
#[test]
fn bindgen_test_layout_deftemplate() {
    assert_eq!(
        ::std::mem::size_of::<deftemplate>(),
        96usize,
        concat!("Size of: ", stringify!(deftemplate))
    );
    assert_eq!(
        ::std::mem::align_of::<deftemplate>(),
        8usize,
        concat!("Alignment of ", stringify!(deftemplate))
    );
    assert_eq!(
        unsafe { &(*(0 as *const deftemplate)).header as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(deftemplate),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const deftemplate)).slotList as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(deftemplate),
            "::",
            stringify!(slotList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const deftemplate)).numberOfSlots as *const _ as usize },
        58usize,
        concat!(
            "Alignment of field: ",
            stringify!(deftemplate),
            "::",
            stringify!(numberOfSlots)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const deftemplate)).busyCount as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(deftemplate),
            "::",
            stringify!(busyCount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const deftemplate)).patternNetwork as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(deftemplate),
            "::",
            stringify!(patternNetwork)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const deftemplate)).factList as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(deftemplate),
            "::",
            stringify!(factList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const deftemplate)).lastFact as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(deftemplate),
            "::",
            stringify!(lastFact)
        )
    );
}
impl deftemplate {
    #[inline]
    pub fn implied(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x1 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_implied(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn watch(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x2 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_watch(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn inScope(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x4 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inScope(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        implied: ::std::os::raw::c_uint,
        watch: ::std::os::raw::c_uint,
        inScope: ::std::os::raw::c_uint,
    ) -> u8 {
        (((0 | ((implied as u32 as u8) << 0usize) & (0x1 as u8)) |
              ((watch as u32 as u8) << 1usize) & (0x2 as u8)) |
             ((inScope as u32 as u8) << 2usize) & (0x4 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct templateSlot {
    pub slotName: *mut symbolHashNode,
    pub _bitfield_1: u8,
    pub constraints: *mut CONSTRAINT_RECORD,
    pub defaultList: *mut expr,
    pub facetList: *mut expr,
    pub next: *mut templateSlot,
}
#[test]
fn bindgen_test_layout_templateSlot() {
    assert_eq!(
        ::std::mem::size_of::<templateSlot>(),
        48usize,
        concat!("Size of: ", stringify!(templateSlot))
    );
    assert_eq!(
        ::std::mem::align_of::<templateSlot>(),
        8usize,
        concat!("Alignment of ", stringify!(templateSlot))
    );
    assert_eq!(
        unsafe { &(*(0 as *const templateSlot)).slotName as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(templateSlot),
            "::",
            stringify!(slotName)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const templateSlot)).constraints as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(templateSlot),
            "::",
            stringify!(constraints)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const templateSlot)).defaultList as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(templateSlot),
            "::",
            stringify!(defaultList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const templateSlot)).facetList as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(templateSlot),
            "::",
            stringify!(facetList)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const templateSlot)).next as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(templateSlot),
            "::",
            stringify!(next)
        )
    );
}
impl templateSlot {
    #[inline]
    pub fn multislot(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x1 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_multislot(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x1 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn noDefault(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x2 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_noDefault(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x2 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn defaultPresent(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x4 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_defaultPresent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x4 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn defaultDynamic(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        let mask = 0x8 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_defaultDynamic(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 0x8 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u8 as *mut u8,
                ::std::mem::size_of::<u8>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u8>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multislot: ::std::os::raw::c_uint,
        noDefault: ::std::os::raw::c_uint,
        defaultPresent: ::std::os::raw::c_uint,
        defaultDynamic: ::std::os::raw::c_uint,
    ) -> u8 {
        ((((0 | ((multislot as u32 as u8) << 0usize) & (0x1 as u8)) |
               ((noDefault as u32 as u8) << 1usize) & (0x2 as u8)) |
              ((defaultPresent as u32 as u8) << 2usize) & (0x4 as u8)) |
             ((defaultDynamic as u32 as u8) << 3usize) & (0x8 as u8))
    }
}
extern "C" {
    pub fn EnvFindDeftemplate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindDeftemplateInModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextDeftemplate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvIsDeftemplateDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetNextFactInTemplate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvDeftemplateModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDeftemplateName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDeftemplatePPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvUndeftemplate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDeftemplateList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: DATA_OBJECT_PTR,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvListDeftemplates(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetDeftemplateWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvSetDeftemplateWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvDeftemplateSlotNames(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvDeftemplateSlotDefaultValue(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeftemplateSlotCardinality(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvDeftemplateSlotAllowedValues(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvDeftemplateSlotRange(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvDeftemplateSlotTypes(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvDeftemplateSlotMultiP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeftemplateSlotSingleP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeftemplateSlotExistP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeftemplateSlotDefaultP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeftemplateSlotFacetExistP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDeftemplateSlotFacetValue(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut DATA_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvFacts(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_longlong,
        arg5: ::std::os::raw::c_longlong,
        arg6: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn EnvSaveFacts(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSaveFactsDriver(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut expr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvLoadFacts(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvLoadFactsFromString(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvFactDeftemplate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFactExistp(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvFactSlotNames(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvGetFactList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut DATA_OBJECT,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvPPFact(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EnvFindDefglobal(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindDefglobalInModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextDefglobal(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvIsDefglobalDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDefglobalValueForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetGlobalsChanged(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetGlobalsChanged(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EnvGetDefglobalValue(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: DATA_OBJECT_PTR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetDefglobalValue(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: DATA_OBJECT_PTR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDefglobalModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefglobalName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefglobalPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvUndefglobal(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDefglobalList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: DATA_OBJECT_PTR,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetDefglobalWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvListDefglobals(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvSetDefglobalWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvSetResetGlobals(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetResetGlobals(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvShowDefglobals(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvDeffunctionModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvFindDeffunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindDeffunctionInModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetDeffunctionList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut DATA_OBJECT,
        arg3: *mut defmodule,
    );
}
extern "C" {
    pub fn EnvGetDeffunctionName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDeffunctionNamePointer(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut SYMBOL_HN;
}
extern "C" {
    pub fn EnvGetDeffunctionPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetNextDeffunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvIsDeffunctionDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetDeffunctionPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvUndeffunction(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDeffunctionWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvListDeffunctions(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut defmodule,
    );
}
extern "C" {
    pub fn EnvSetDeffunctionWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvFindDefgeneric(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindDefgenericInModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextDefgeneric(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextDefmethod(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvIsDefgenericDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvIsDefmethodDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvUndefgeneric(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvUndefmethod(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDefmethodDescription(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
        arg5: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn EnvGetDefgenericWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvSetDefgenericWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetDefmethodWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvSetDefmethodWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn EnvGetDefmethodPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvListDefgenerics(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut defmodule,
    );
}
extern "C" {
    pub fn EnvListDefmethods(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetDefgenericList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut DATA_OBJECT,
        arg3: *mut defmodule,
    );
}
extern "C" {
    pub fn EnvGetDefmethodList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvGetMethodRestrictions(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvDefgenericModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefgenericName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefgenericPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefgenericNamePointer(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut SYMBOL_HN;
}
extern "C" {
    pub fn EnvSetDefgenericPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvGetDefclassName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefclassPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefclassModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut defmoduleItemHeader;
}
extern "C" {
    pub fn EnvDefclassModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvSetDefclassPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvFindDefclass(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindDefclassInModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextDefclass(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvIsDefclassDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetClassDefaultsMode(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn EnvGetClassDefaultsMode(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn EnvListDefclasses(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut defmodule,
    );
}
extern "C" {
    pub fn EnvGetDefclassWatchInstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvSetDefclassWatchInstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetDefclassWatchSlots(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvSetDefclassWatchSlots(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetDefclassList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut DATA_OBJECT,
        arg3: *mut defmodule,
    );
}
extern "C" {
    pub fn EnvUndefclass(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvBrowseClasses(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvDescribeClass(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvSuperclassP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSubclassP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSlotExistP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSlotWritableP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSlotInitableP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSlotPublicP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSlotDirectAccessP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSlotDefaultValue(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: DATA_OBJECT_PTR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSlotDefaultP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvClassAbstractP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvClassReactiveP(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvClassSlots(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut DATA_OBJECT,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EnvGetDefmessageHandlerList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut DATA_OBJECT,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EnvClassSuperclasses(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut DATA_OBJECT,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EnvClassSubclasses(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut DATA_OBJECT,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EnvSlotFacets(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvSlotSources(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvSlotTypes(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvSlotAllowedValues(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvSlotAllowedClasses(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvSlotRange(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvSlotCardinality(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvDefinstancesModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvDefinstancesModuleName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvFindDefinstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindDefinstancesInModule(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetDefinstancesList(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut DATA_OBJECT,
        arg3: *mut defmodule,
    );
}
extern "C" {
    pub fn EnvGetDefinstancesName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefinstancesNamePointer(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut SYMBOL_HN;
}
extern "C" {
    pub fn EnvGetDefinstancesPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetNextDefinstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvIsDefinstancesDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetDefinstancesPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn EnvUndefinstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvListDefinstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut defmodule,
    );
}
extern "C" {
    pub fn EnvIncrementInstanceCount(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvDecrementInstanceCount(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvGetInstancesChanged(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvSetInstancesChanged(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EnvDeleteInstance(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvUnmakeInstance(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvInstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EnvMakeInstance(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvCreateRawInstance(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvFindInstance(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvValidInstanceAddress(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvDirectGetSlot(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvDirectPutSlot(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut DATA_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetInstanceName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetInstanceClass(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextInstance(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextInstanceInClass(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetNextInstanceInClassAndSubclasses(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut DATA_OBJECT,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EnvGetInstancePPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EnvSaveInstancesDriver(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut EXPRESSION,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvSaveInstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvBinarySaveInstancesDriver(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut EXPRESSION,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvBinarySaveInstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvBinaryLoadInstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvLoadInstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvLoadInstancesFromString(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvRestoreInstances(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvRestoreInstancesFromString(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn EnvSend(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut DATA_OBJECT,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut DATA_OBJECT,
    );
}
extern "C" {
    pub fn EnvGetDefmessageHandlerName(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetDefmessageHandlerType(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvGetNextDefmessageHandler(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDefmessageHandlerWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvSetDefmessageHandlerWatch(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EnvFindDefmessageHandler(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EnvIsDefmessageHandlerDeletable(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvUndefmessageHandler(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnvGetDefmessageHandlerPPForm(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnvListDefmessageHandlers(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EnvPreviewSend(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *const ::std::os::raw::c_char,
    );
}
